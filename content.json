{"meta":{"title":"Shanruo's Blog","subtitle":"前端初学者","description":"不积跬步，无以至千里；不积小流，无以成江海。","author":"Shanruo Peng","url":"http://shanruopeng.github.io/shanruopeng.github.io"},"pages":[{"title":"","date":"2018-12-04T11:22:30.349Z","updated":"2017-11-29T05:58:12.000Z","comments":true,"path":"404.html","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/404.html","excerpt":"","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function(_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0;i < scs.length;i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function() { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0;i < len;i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function(a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function(d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function() { _Callback({tm_now:(new Date).getTime() / 1E3}); }, 2E3); _w.share = function(target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = {\"surl\":\"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\":\"QQ\\u7a7a\\u95f4\", \"summary\":summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\":stitle, \"pics\":current.child_pic, \"desc\":desc, \"origin_url\":current.url}; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = {weibo:{method:function(evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, qzone:{method:function(evt) { var buff = [], ps = {url:surl + \"#via=404-qzoneshare\", desc:desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary:summary, title:stitle, pics:pics, site:site}; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, sina:{method:function() { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); }}, kaixin:{method:function() { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); }}, renren:{method:function() { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } }}, weixin:{method:function() { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } }}}; var openit = function(u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function(id) { for (var i = 0;i < $scope.otherdata.length;i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function() { function a(a, b) { return(/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length;d > c;c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\");e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({filename:b, name:\"Render Error\", message:\"Template not found\"}); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c); }; } var d = j[a] = function(c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = {\"\":\"&#62;\", '\"':\"&#34;\", \"'\":\"&#39;\", \"&\":\"&#38;\"}, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = {$helpers:{}, $include:function(a, b, c) { return a = f(c, a), g(a, b); }, $string:b, $escape:d, $each:e}, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function(a, b) { o[a] = b; }, \"function\" == typeof define ? define(function() { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function(a) { r += ' '; }), r += \" \", new k(r); }); }();"},{"title":"","date":"2018-12-04T11:22:30.351Z","updated":"2017-11-30T09:24:54.000Z","comments":true,"path":"about/index.html","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/about/index.html","excerpt":"","text":"关于我90后、女汉纸、伪文青、狮子座、吃货…… 前端初学者； 熟悉使用 HTML(5)、javascript、css(3) 等前端开发技术； 熟悉jQuery、Angular、VUE等前端开发框架； 熟悉基于java、+ SpringMVC、+ Mybatis的后台开发环境； 对Nodejs，Python等后端语言有一定的了解; …… 走在终身学习的路上 关于工作坐标：成都 关于学习前端学习中，近期恶补基础中…… 座右铭 业精于勤荒于嬉,行成于思毁于随。 关于爱好热爱美食，尤其喜爱火锅，喜欢阅读、写鸡汤文、电影，渴望旅行、赚很多钱。 联系我 Blog: pengyanyan.cn Email: shanruopeng@gmail.com GitHub: shanruopeng"}],"posts":[{"title":"ECMAScript 6.0介绍","slug":"ECMAScript 6.0","date":"2018-12-04T17:45:28.000Z","updated":"2018-12-04T12:26:30.506Z","comments":true,"path":"2018/12/05/ECMAScript 6.0/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/12/05/ECMAScript 6.0/","excerpt":"","text":"1、历史 1. ECMAScript和JavaScript - ECMA是标准，JS是实现 - 类似于HTML5是标准，IE10、Chrome、FF都是实现 - 换句话说，将来也能有其他XXXScript来实现ECMA - ECMAScript简称**ECMA或ES** - 目前版本 - 低级浏览器主要支持ES 3.1 - 高级浏览器正在从ES 5过渡到ES 6 2. 历史版本 时间 ECMA JS 解释 1996.11 ES 1.0 JS稳定 Netscape将JS提交给ECMA组织，ES正式出现 1998.06 ES 2.0 ES2正式发布 1999.12 ES 3.0 ES3被广泛支持 2007.10 ES 4.0 ES4过于激进，被废了 2008.07 ES 3.1 4.0退化为严重缩水版的3.1因为吵得太厉害，所以ES 3.1代号为Harmony(和谐) 2009.12 ES 5.0 ES 5.0正式发布同时公布了JavaScript.next也就是后来的ES 6.0 2011.06 ES 5.1 ES 5.1成为了ISO国际标准 2013.03 ES 6.0 ES 6.0草案定稿 2013.12 ES 6.0 ES 6.0草案发布 2015.06 ES 6.0 ES 6.0预计发布正式版JavaScript.next开始指向ES 7.0 2、兼容性http://kangax.github.io/compat-table/es5/http://kangax.github.io/compat-table/es6/ ES6(ES2015)——IE10+、Chrome、FireFox、移动端、NodeJS 编译、转换1.在线转换2.提前编译babel==browser.js 3.ES6 新特性1.变量2.函数3.数组4.字符串5.面向对象6.Promise7.generator8.模块化 3、let和const var 无法重复声明 无法限制修改（没有常量） 没有块级作用域 let 不能重复声明，变量-可以修改，块级作用域 const 不能重复声明，常量-不可修改，块级作用域 块级作用域举例 123&lt;input type=\"button\" value = \"按钮\"/&gt;&lt;input type=\"button\" value = \"按钮\"/&gt;&lt;input type=\"button\" value = \"按钮\"/&gt; 123456789window.onload = function()&#123; var btn = document.getElementByTagName(&apos;input&apos;); for(var i = 0; i&lt; btn.length; i++)&#123; btn[i].onclick = function()&#123; alert(i); &#125; &#125;&#125;// 点击三个按钮，都会弹出的是3 123456789//利用函数作为作用域window.onload = function()&#123; var btn = document.getElementByTagName(&apos;input&apos;); (function(i)&#123; btn[i].onclick = function()&#123; alert(i); &#125; &#125;)(i);&#125; 123456789//ES6window.onload = function()&#123; var btn = document.getElementByTagName(&apos;input&apos;); for(let i = 0; i&lt; btn.length; i++)&#123; btn[i].onclick = function()&#123; alert(i); &#125; &#125;&#125; 4、函数-箭头函数123456789//ES5function 名字()&#123;&#125;//ES6()=&gt;&#123;&#125; 举例1234567let arr=[12, 5, 8, 99, 33, 14, 26];arr.sort(function (n1, n2)&#123; return n1-n2;&#125;);arr.sort((n1, n2)=&gt;n1-n2); 1、如果只有一个参数，()可以省去。2、如果只有一个return，{}可以省去。1234567891011121314151617var let = function(a)&#123; return a*2;&#125;//ES6 var let = (a)=&gt;a*2;//省略圆括号 省略花括号var let = a =&gt;a*2;// 省略花括号let arr=[12, 5, 8, 99, 33, 14, 26];arr.sort((n1, n2)=&gt; n1-n2); 5、函数 - 参数1、参数扩展，数组展开 收集剩余的参数12345function show(a, b , ...args)&#123; alert(a); alert(b);&#125;//Rest parameter 必须是最后一个 123456789function show(...args)&#123; fn(...args);&#125;function fn(a,b)&#123; alert(a+b);&#125;show (12,5);//17 展开数组 展开后的效果，跟直接把数组的内容写在这儿一样1234567891011121314151617function show(a,b,c)&#123; alert(a); alert(b); alert(c);&#125;show(1,2,3);//等价写法let arr = [1,2,3];show(...arr);var arr1 = [1,2,3];var arr2 = [4,5,6];var arr = [...arr1,...arr2];//等价于arr = [1,2,3,4,5,6,7] 2、默认参数 123//jquery 中常见默认参数$(&apos;#div1&apos;).animate(&#123;width: &apos;200px&apos;&#125;);$(&apos;#div1&apos;).animate(&#123;width: &apos;200px&apos;&#125;, 1000); 123456function show(a,b=5,c=10)&#123; console.log(a,b,c);&#125;show(99);//99 5 10show(99,10);// 99 10 10show(99,12,12);//99 12 12 6、解构赋值 左右两边结构必须一样 右边必须是个有效的东西 声明和赋值不能分开(必须在一句话里完成) 12345678let [a,b,c]=[12,5,8];let &#123;a,b,c&#125;=&#123;a: 12, b: 5, c: 8&#125;;let [json,arr,num,str] = [&#123;a:12,b:5&#125;,[12,5,8],8,&apos;xxxx&apos;];console.log(json,arr,num,str);//错误写法let [a,b] ;[a,b] = [1,2]; 7、数组 map 映射 一个对一个 12345[12, 58, 99, 86, 45, 91][不及格, 不及格, 及格, 及格, 不及格, 及格]let score = [12, 58, 99, 86, 45, 91];let res = score.map(item=&gt;item&gt;=60?&apos;及格&apos;:&apos;不及格&apos;); reduce 汇总 一堆出来一个 123456789101112131415161718//算个总数// [12,60,18] =&gt; 90 let arr = [12,60,18]; let res = arr.reduce(function(tmp, item, index)&#123; return tmp+item; &#125;); //算个平均数// [12,60,18] =&gt; 30 let arr = [12,60,18]; let res = arr.reduce(function(tmp, item, index)&#123; if(index != arr.length-1)&#123; return tmp+item; &#125;else&#123; return (tmp+item)/arr.length; &#125; &#125;); filter 过滤器 1234567891011let arr = [12,5,8,99,27,36,11];let result = arr.filter(item=&gt;&#123; if(item % 3 == 0 )&#123; return true; &#125;else&#123; return false; &#125;&#125;)//简写let result = arr.filter(item =&gt; item%3 ==0); forEach 循环/迭代1234let a = [12,5,8,9];arr.forEach((item,index)=&gt;&#123; alert(index+&quot;:&quot;+item);&#125;); 8、字符串1、多了两个新方法 startsWith 12345678let str = &quot;https://www.baidu.com/&quot;;if(str.startsWith(&apos;http://&apos;))&#123; alert(&apos;普通网址&apos;);&#125;else if(str.startsWith(&apos;https://&apos;))&#123; alert(&apos;加密网址&apos;);&#125;else&#123; alert(&apos;其它&apos;);&#125; endsWith 123456let str = &apos;1.txt&apos;;if(str.endsWith(&apos;.txt&apos;))&#123; alert(&apos;文本文件&apos;);&#125;else&#123; alert(&apos;其它文件&apos;);&#125; 2、字符串模板 字符串连接 可以直接将内容放入字符串里面 ${内容} 可以折行 123let a = 12;let str = `a$&#123;a&#125;bc`; console.log(str);//a12bc 9、面向对象-基础 class 关键字、构造器和类分开了 class 里面可以直接加方法 12345678910111213141516171819202122232425262728293031//ES5function User(name,pass)&#123; this.name = name; this.pass = pass;&#125;User.prototype.showName = function()&#123; alert(this.name);&#125;;User.prototype.showPass = function()&#123; alert(this.pass);&#125;;//ES6class User&#123; constructor(name,pass)&#123; this.name = name; this.pass = pass; &#125; showName()&#123; alert(this.name); &#125; showPass()&#123; alert(this.pass); &#125;&#125;var user = new User('meggie','123456'); 继承 super 超类 == 父类 1234567891011121314151617181920212223//ES5function VipUser(name,pass,level)&#123; User.call(this,name,pass); this.level = level;&#125;VipUser.prototype = new User();VipUser.prototype.constructor = VipUser;VipUser.prototype.showLevel = function()&#123; alert(this.level);&#125;//ES6class VipUser extends User&#123; constructor(name,pass,level)&#123; super(name,pass); this.level = level; &#125; showLevel()&#123; alert(this.level); &#125;&#125; 10、面向对象 - 实例React :1、组件化-class2、JSX-JS扩展版 jsx ==babel==browser.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"react.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"react-dom.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"browser.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/babel\"&gt; class Item extends React.Component&#123; constructor(...args)&#123; super(...args); &#125; render()&#123; return &lt;li&gt;&#123;this.props.str&#125;&lt;/li&gt;; &#125; &#125; class List extends React.Component&#123; constructor(...args)&#123; super(...args); &#125; render()&#123; return &lt;ul&gt; &#123;this.props.arr.map(a=&gt;&lt;Item str=&#123;a&#125;&gt;&lt;/Item&gt;)&#125; &lt;/ul&gt;; &#125; &#125; window.onload=function ()&#123; let oDiv=document.getElementById('div1'); ReactDOM.render( &lt;List arr=&#123;['abc', 'erw', 'sdfasdf', 'dfasdfsdfds']&#125;&gt;&lt;/List&gt;, oDiv ); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 11、JSON1、JSON对象 JSON.stringify JSON.parse 2、简写 名字跟值(key和value)一样的 ，留一个就行 123let a = 12;let b = 5;let json = &#123;a,b,c:55&#125;; 方法 :function一块删 123456789show: function ()&#123;...&#125;show()&#123;...&#125;let json = &#123; a:12, show()&#123; alert(this.a); &#125;&#125; 3、json的标准写法：1.只能用双引号2.所有的名字都必须用引号包起来 {a: 12, b: 5} ×{“a”: 12, “b”: 5} √ {a: ‘abc’, b: 5} ×{“a”: “abc”, “b”: 5} √ 12、Promise 异步：操作之间没啥关系，同时进行多个操作 同步：同时只能做一件事 异步：代码更复杂 同步：代码简单 异步，伪代码 12345678910111213141516ajax('/banners', function (banner_data)&#123; ajax('/hotItems', function (hotitem_data)&#123; ajax('/slides', function (slide_data)&#123; ajax('/slides', function (slide_data)&#123; &#125;, function ()&#123; alert('读取失败'); &#125;); &#125;, function ()&#123; alert('读取失败'); &#125;); &#125;, function ()&#123; alert('读取失败'); &#125;);&#125;, function ()&#123; alert('读取失败');&#125;); 同步,伪代码 1234let banner_data=ajax_async('/banners');let hotitem_data=ajax_async('/hotItems');let slide_data=ajax_async('/slides');let banner_data=ajax_async('/banners'); Promise 消除异步操作,用同步一样的方式，来书写异步代码 1234567891011121314151617181920212223242526272829/**Promise.all([$.ajax(), $.ajax()]).then(results=&gt;&#123; //对了&#125;, err=&gt;&#123; //错了&#125;);**/let p=new Promise(function (resolve, reject)&#123; //异步代码 //resolve——成功了 //reject——失败了 $.ajax(&#123; url: 'data/arr2.txt', dataType: 'json', success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;)&#125;);p.then(function (arr)&#123; alert('成功'+arr);&#125;, function (err)&#123; console.log(err); alert('失败了'+err);&#125;); Promise.all 123456789101112131415161718192021222324252627function createPromise(url)&#123; return new Promise(function (resolve, reject)&#123; $.ajax(&#123; url, dataType: 'json', success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;) &#125;);&#125;Promise.all([ createPromise('data/arr.txt'), createPromise('data/json.txt')]).then(function (arr)&#123; let [res1, res2]=arr; alert('全都成功了'); alert(res1); alert(res2);&#125;, function ()&#123; alert('至少有一个失败了');&#125;); //更好的写法 12345678910Promise.all([ $.ajax(&#123;url: 'data/arr.txt', dataType: 'json'&#125;), $.ajax(&#123;url: 'data/json.txt', dataType: 'json'&#125;) ]).then(function (results)&#123; let [arr, json]=results; alert('成功了'); console.log(arr, json); &#125;, function ()&#123; alert('失败了'); &#125;); promise.race 123456Promise.race([ $.ajax(&#123;url: &apos;http://a2.taobao.com/data/users&apos;&#125;), $.ajax(&#123;url: &apos;http://a15.taobao.com/data/users&apos;&#125;), $.ajax(&#123;url: &apos;http://a3.taobao.com/data/users&apos;&#125;), $.ajax(&#123;url: &apos;http://a7.taobao.com/data/users&apos;&#125;)]); 13、Generator -认识生成器函数 generator-生成器 是一种函数 generate-生成 普通函数—— 一路到底 generator函数—— 中间能停 123456789101112131415function* show()&#123; alert(&apos;a&apos;); yield; alert(&apos;b&apos;);&#125;function show_1()&#123; alert(&apos;a&apos;);&#125;function show_2()&#123; alert(&apos;b&apos;);&#125;//next 一次走一次let genObj=show();genObj.next(); //show_1genObj.next(); //show_2 1234567891011121314151617//伪代码function 函数()&#123; 代码... ajax(xxx, function ()&#123; 代码... &#125;);&#125;function* 函数()&#123; 代码... yield ajax(xxx); 代码...&#125; 14、Generator yield yield 可以传参 12345678910function* show()&#123; alert('a'); let a = yield; alert('b'); alert(a); //5_&#125; let gen = show();gen.next(12); //第一个yield没法给yield传参gen.next(5); yield 可以返回 1234567891011function *show()&#123; alert('a'); yield 12; alert('b'); return 55; &#125; let gen=show(); let res1=gen.next(); //a console.log(res1); //&#123;value: 12, done: false&#125; let res2=gen.next();//b console.log(res2); //&#123;value: 55, done: true&#125; 15、Generator - 实例 runner123456789101112131415161718192021222324252627282930313233//runner.jsfunction runner(_gen)&#123; return new Promise((resolve, reject)=&gt;&#123; var gen=_gen(); _next(); function _next(_last_res)&#123; var res=gen.next(_last_res); if(!res.done)&#123; var obj=res.value; if(obj.then)&#123; obj.then((res)=&gt;&#123; _next(res); &#125;, (err)=&gt;&#123; reject(err); &#125;); &#125;else if(typeof obj=='function')&#123; if(obj.constructor.toString().startsWith('function GeneratorFunction()'))&#123; runner(obj).then(res=&gt;_next(res), reject); &#125;else&#123; _next(obj()); &#125; &#125;else&#123; _next(obj); &#125; &#125;else&#123; resolve(res.value); &#125; &#125; &#125;);&#125; 123456runner(function *()&#123; let data1=yield $.ajax(&#123;url: 'data/1.txt', dataType: 'json'&#125;); let data2=yield $.ajax(&#123;url: 'data/2.txt', dataType: 'json'&#125;); let data3=yield $.ajax(&#123;url: 'data/3.txt', dataType: 'json'&#125;); console.log(data1, data2, data3); &#125;); 异步操作 123456789101112131415161718//带逻辑-普通回调$.ajax(&#123;url: &apos;getUserData&apos;, dataType: &apos;json&apos;, success(userData)&#123; if(userData.type==&apos;VIP&apos;)&#123; $.ajax(&#123;url: &apos;getVIPItems&apos;, dataType: &apos;json&apos;, success(items)&#123; //生成列表、显示... &#125;, error(err)&#123; alert(&apos;错了&apos;); &#125;&#125;); &#125;else&#123; $.ajax(&#123;url: &apos;getItems&apos;, dataType: &apos;json&apos;, success(items)&#123; //生成列表、显示... &#125;, error(err)&#123; alert(&apos;错了&apos;); &#125;&#125;); &#125;&#125;, error(err)&#123; alert(&apos;错了&apos;);&#125;&#125;); Promise 123456789101112131415161718192021222324252627282930//带逻辑-PromisePromise.all([ $.ajax(&#123;url: &apos;getUserData&apos;, dataType: &apos;json&apos;&#125;)]).then(results=&gt;&#123; let userData=results[0]; if(userData.type==&apos;VIP&apos;)&#123; Promise.all([ $.ajax(&#123;url: &apos;getVIPItems&apos;, dataType: &apos;json&apos;&#125;) ]).then(results=&gt;&#123; let items=results[0]; //生成列表、显示... &#125;, err=&gt;&#123; alert(&apos;错了&apos;); &#125;); &#125;else&#123; Promise.all([ $.ajax(&#123;url: &apos;getItems&apos;, dataType: &apos;json&apos;&#125;) ]).then(results=&gt;&#123; let items=results[0]; //生成列表、显示... &#125;, err=&gt;&#123; alert(&apos;错了&apos;); &#125;); &#125;&#125;, err=&gt;&#123; alert(&apos;失败&apos;);&#125;); generator 123456789101112//带逻辑-generatorrunner(function *()&#123; let userData=yield $.ajax(&#123;url: 'getUserData', dataType: 'json'&#125;); if(userData.type=='VIP')&#123; let items=yield $.ajax(&#123;url: 'getVIPItems', dataType: 'json'&#125;); &#125;else&#123; let items=yield $.ajax(&#123;url: 'getItems', dataType: 'json'&#125;); &#125; //生成&#125;); 16、Gernerator实例 KOA1234567891011121314const koa=require('koa');const mysql=require('koa-mysql');let db=mysql.createPool(&#123;host: 'localhost', user: 'root', password: '123456', database: '20180602'&#125;);let server=new koa();server.use(function *()&#123; let data=yield db.query(`SELECT * FROM user_table`); this.body=data;&#125;);server.listen(8080);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript高级技巧-高级函数","slug":"JavaScript 高级技巧-高级函数","date":"2018-02-28T17:45:28.000Z","updated":"2018-02-28T08:47:50.000Z","comments":true,"path":"2018/03/01/JavaScript 高级技巧-高级函数/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/03/01/JavaScript 高级技巧-高级函数/","excerpt":"","text":"1、安全的类型检测 JavaScript 内置的类型检测机制并非完全可靠。事实上，发生错误否定及错误肯定的情况也不在少数。例如： Safari（直至第4 版）在对正则表达式应用typeof 操作符时会返回”function”。 instanceof 操作符在存在多个全局作用域的情况下，存在问题。 浏览器开始原生支持JSON对象后，是开发人员很难确定页面中的JSON对象到底是不是原生的。 解决方法： 在任何值上调用Object 原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]]属性，这个属性中就指定了上述字符串中的构造函数名。 1alert(Object.prototype.toString.call(value)); //\"[object Array]\" 由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。利用这一点，可以创建如下函数。 123456789function isArray(value)&#123; return Object.prototype.toString.call(value) == \"[object Array]\";&#125;function isFunction(value)&#123; return Object.prototype.toString.call(value) == \"[object Function]\";&#125;function isRegExp(value)&#123; return Object.prototype.toString.call(value) == \"[object RegExp]\";&#125; 这一技巧也广泛应用于检测原生JSON对象。Object的toString()方法不能检测非原生构造函数的构造函数名。因此，开发人员定义的任何构造函数都将返回[object Object]。 12 var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON) ==\"[object JSON]\"; 2、作用域安全函数 创建一个构造函数Person，使用this 对象给三个属性赋值：name、age 和job。 12345function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job;&#125; 当和new操作符连用时，则会创建一个新的Person 对象，同时会给它分配这些属性。 12var person = new Person(\"Nicholas\", 29, \"Software Engineer\");alert(person.name); //\"Nicholas\" 在当没有使用new操作符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person()，this 会映射到全局对象window 上，导致错误对象属性的意外增加。 1234var person = Person(\"Nicholas\", 29, \"Software Engineer\");alert(window.name); //\"Nicholas\"alert(window.age); //29alert(window.job); //\"Software Engineer\" 解决方案：创建一个作用域安全的构造函数。作用域安全的构造函数在进行任何更改前，首先确认this 对象是正确类型的实例。如果不是，那么会创建新的实例并返回。 12345678910111213141516function Person(name, age, job)&#123; if (this instanceof Person)&#123; this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125;var person1 = Person(\"Nicholas\", 29, \"Software Engineer\");alert(window.name); //\"\"alert(person1.name); //\"Nicholas\"var person2 = new Person(\"Shelby\", 34, \"Ergonomist\");alert(person2.name); //\"Shelby\" 注意：实现这个模式后，你就锁定了可以调用构造函数的环境。如果你使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏。 1234567891011121314151617181920function Polygon(sides)&#123; if (this instanceof Polygon) &#123; this.sides = sides; this.getArea = function()&#123; return 0; &#125;; &#125; else &#123; return new Polygon(sides); &#125;&#125;function Rectangle(width, height)&#123; Polygon.call(this, 2); this.width = width; this.height = height; this.getArea = function()&#123; return this.width * this.height; &#125;;&#125;var rect = new Rectangle(5, 10);alert(rect.sides); //undefined 如果构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题。 123Rectangle.prototype = new Polygon();var rect = new Rectangle(5, 10);alert(rect.sides); //2 3、惰性载入函数 因为浏览器之间行为的差异，多数JavaScript代码包含了大量的if语句，将执行引导到正确的代码中，如果if 语句不必每次执行，那么代码可以运行地更快一些。解决方案就是称之为惰性载入的技巧。 1234567891011121314151617181920212223function createXHR()&#123; if (typeof XMLHttpRequest != \"undefined\")&#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != \"undefined\")&#123; if (typeof arguments.callee.activeXString != \"string\")&#123; var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\", \"MSXML2.XMLHttp\"], i,len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error(\"No XHR object available.\"); &#125;&#125; 惰性载入表示函数执行的分支仅会发生一次。 有两种实现惰性载入的方式，第一种就是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。 12345678910111213141516function createXHR()&#123; if (typeof XMLHttpRequest != \"undefined\")&#123; createXHR = function()&#123; return new XMLHttpRequest(); &#125;; &#125; else if (typeof ActiveXObject != \"undefined\")&#123; createXHR = function()&#123; /**省略**/ &#125;; &#125; else &#123; createXHR = function()&#123; throw new Error(\"No XHR object available.\"); &#125;; &#125; return createXHR();&#125; 第二种实现惰性载入的方式是在声明函数时就指定适当的函数。 123456789101112131415var createXHR = (function()&#123; if (typeof XMLHttpRequest != \"undefined\")&#123; return function()&#123; return new XMLHttpRequest(); &#125;; &#125; else if (typeof ActiveXObject != \"undefined\")&#123; return function()&#123; /**省略**/ &#125;; &#125; else &#123; return function()&#123; throw new Error(\"No XHR object available.\"); &#125;; &#125;&#125;)(); 4、函数绑定 函数绑定要创建一个函数，可以在特定的this 环境中以指定参数调用另一个函数。 JavaScript 库实现了一个可以将函数绑定到指定环境的函数，一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。语法如下： 1234567891011121314function bind(fn, context)&#123; return function()&#123; return fn.apply(context, arguments); &#125;;&#125;var handler = &#123; message: \"Event handled\", handleClick: function(event)&#123; alert(this.message + \":\" + event.type); &#125;&#125;;var btn = document.getElementById(\"my-btn\");EventUtil.addHandler(btn, \"click\", bind(handler.handleClick, handler)); ECMAScript 5 为所有函数定义了一个原生的bind()方法，进一步简单了操作。它们主要用于事件处理程序以及 setTimeout() 和 setInterval()。 1EventUtil.addHandler(btn, \"click\", handler.handleClick.bind(handler)); 函数柯里化 函数柯里化，用于创建已经设置好了一个或多个参数的函数，基本方法与函数绑定相同：使用闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些参数。 12345678function add(num1, num2)&#123; return num1 + num2;&#125;function curriedAdd(num2)&#123; return add(5, num2);&#125;alert(add(2, 3)); //5alert(curriedAdd(3)); //8 柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。创建柯里化函数的通用方式如下。 12345678function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;;&#125; curry()函数可以按以下方式应用。 12345678function add(num1, num2)&#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);alert(curriedAdd(3)); //8var curriedAdd = curry(add, 5, 12);alert(curriedAdd()); //17","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"PS-修图美化","slug":"PS 修图美化","date":"2018-01-17T17:45:28.000Z","updated":"2018-01-17T06:40:18.000Z","comments":true,"path":"2018/01/18/PS 修图美化/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/18/PS 修图美化/","excerpt":"","text":"用修复工具修饰图 污点修复工具 祛除污点，如人物祛痘时使用。 主要注意调节画笔大小和硬度。它可以智能的去掉相应涂抹部分内容后，补充智能图案。适用于小范围修复。 修复画笔工具 历史记录临时保存，可以新建快照。 取样（按住Alt键，点击取样），去覆盖（Alt键放掉，鼠标左键按住不放，放在要涂抹区域） 修补工具 -选中【源】， 从目标修补源，先在要修改部分建立选区，鼠标按住不放，拖动到正确的地方，再放开。 选择【目标】，从源修补目标，先在正确的地方建立选区，鼠标按住不放，拖动到要修补的地方，再放开。 运用历史记录画笔实现雀斑美女美容 滤镜-》模糊-》表面模糊（半径22， 阈值 53） 打开历史记录面板，将历史记录画笔位置切换到原图。涂抹到要还原为原图的区域。设置不透明度为30%-40%，一层一层涂抹慢慢还原。画笔大小根据操作区块大小做相应调整。 通过蒙版实现人像美容 Ctrl+ J 复制背景层新建图层1。 在图层1 -》模糊-》高斯模糊（半径值设置为10像素左右），确定。 按住Alt键，点击新建蒙版，新建黑色蒙版。 在黑色蒙版上利用画笔，在黑色蒙版上涂抹白色。不透明度更改到30%左右。依次涂抹。 思路为：做一张模糊的“面膜”覆盖在原图的脸上 利用通道实现皮肤去皱美容 例子一 在通道面板，按住Ctrl键，点击缩略图。选中图片中比较亮的部分。 新建图层，在选区去填充白色背景色。Ctrl+Delete键。 在新建的图层中，新建蒙版，画笔涂抹黑色，作相应的调整。 例子二 红绿蓝三个通道，根据色彩明暗区分通道颜色的多少。 黄皮肤通常用蓝色通道，调整黄色（调整绿色和红色，或单独调整蓝色） 在蓝色通道-》右键复制，选中新复制的通道，滤镜-》其它-》高反差保留，确定。 选择画笔，按住Alt键，吸管工具，吸取颜色，并涂抹掉不想改变的地方。 图像-》计算-》混合（叠加），重复操作三次。 按住Ctrl键，点击通道，载入选区，选择-》反向 回到图层面板，调整-》曲线，往左上方拖动。","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/Photoshop/"}],"tags":[{"name":"Photoshop学习笔记","slug":"Photoshop学习笔记","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/Photoshop学习笔记/"}]},{"title":"PS-图层和蒙版","slug":"图层和蒙版","date":"2018-01-16T17:45:28.000Z","updated":"2018-01-16T08:08:52.000Z","comments":true,"path":"2018/01/17/图层和蒙版/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/17/图层和蒙版/","excerpt":"","text":"蒙版概念及应用 魔棒等工具抠图时，对图是存在损伤的，操作是不可持续的。如按住delete键删除了图片相关部分时，当需要修改时，需要退回去重新做。蒙版的好处是并没有把内容真删除掉，只是遮挡起来而已。 新增蒙版切换前景色背景色快捷键：【X】，复位初始值为【D】 利用蒙版可反复修改蒙版中，黑色为透明，白色为不透明，灰色为半透明。 修改时主要用到画笔工具，画笔硬度越大，边缘羽化越小。 利用蒙版对智能对象进行抠图 智能对象，或置入的图，不能直接进行编辑，必须用蒙版才能抠图。 按住ALT键，点击蒙版，即可创建反向蒙版。（蒙版-》属性面板-》反相） 图层概念 图层有多种类别，多种图层相互之间可以进行转换 需要掌握图层的分配，什么时候需要新建图层，图层层次关系。 按住ctrl，点击，可全部展开或关闭组。 新建图层，选中某一图层，点新建，则新图层在选中图层的上方。 删除图层 Delete键删除，当有选区存在时，将图层直接拖入垃圾桶。 复制图层 Ctrl+【J】 复制，图层和图层效果，在按住Alt键，拖动时可复制，复制后位置是重叠的 按住键盘Alt键，左键按住不放，拖动，即可复制。要想保持水平移动复制，拖动后按住shift键。 剪切图层 快捷键：Ctrl+Shift+J，将图层上剪切一部分建立新图层。 图层合并 向下合并 Ctrl+【E】 合并可见图层 Ctrl+Shift+【E】 合并并新建图层 Ctrl+Alt+Shift+【E】 群组 选中多个图层，Ctrl + 【G】新建组 取消群组：Ctrl+Shift+【G】或右键，取消编组 利用图层制作五环 新建图层 3000*2000像素，白底。 新建图层，椭圆选框工具，绘制圆，Alt+Delete填充。 选择-&gt;变换选区，按住Shift+Alt，在选区角上，拖动缩小选区。 缩小后，按住Delete删除，Ctrl+D取消选区 按住Alt键，光标放在圆环上，拖动，复制圆环。拖动时按住Shift键控制水平线上。 重复，复制出5个相同的环，分别给各个图层重命名为蓝黑红绿黄 锁定透明，锁定图像像素，锁定位置，锁定全部。 选中黑色图层框，调整锁定透明，Alt+Delete填充黑色。 其它几个环同理，完成填充。 层次关系处理：1、删除重叠部分，2、复制多余一块，盖在要覆盖的图层上。 选中蓝色图层，建立选区，按住Ctrl+J，复制图层，将新图层移动到黄色图层上方，覆盖两个环交叉的部分。 后面绿色环交叉部分同理处理。 合并图层，完成。 图层混合模式 Ctrl + Shift + U 为去色 图像-》调整-》去色 正片叠底，调暗，图片上的颜色为黑色，正片叠底后仍为黑色；图片上的颜色为白色，正片叠底后为自叠底图层的颜色。 滤色，调亮，图片上的颜色是白色时，滤色后仍为白色；图片上颜色为黑色时，滤色后为滤色图层的颜色； 蒙版反向快捷键： Ctrl+I 抠出玻璃杯示例 Ctrl+ A 全选Ctrl+ C 复制创建蒙版按住ALT键，点击蒙版Ctrl+V 粘贴选中蒙版，右键，停用蒙版。利用多边形套索工具抠出玻璃杯启用蒙版选区方向，填充黑色，透明效果出来了。复制图层，叠加，或图像-》调整-》色阶","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/Photoshop/"}],"tags":[{"name":"Photoshop学习笔记","slug":"Photoshop学习笔记","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/Photoshop学习笔记/"}]},{"title":"PS-常用基础操作","slug":"PS 常用基础操作","date":"2018-01-11T17:45:28.000Z","updated":"2018-01-11T09:03:18.000Z","comments":true,"path":"2018/01/12/PS 常用基础操作/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/12/PS 常用基础操作/","excerpt":"","text":"图像及画布大小调整 背景图层不可移动，在背景图层上双击，可以更改为普通图层后，便可以移动。 修改图片大小 图像-》图像大小-》根据实际需要调整，修改图像大小时，画布大小跟着改变了。 修改画布大小 图像-》画布大小-》根据实际需要调整，可以定位。 ps中裁剪图像 裁切工具，在选型卡勾选使用经典模式，方便调整。 裁小，拖动即可。 裁大，可以调整裁剪线至图片边缘外。 快捷键 Ctrl+【T】为自由变换 工具选项栏的【拉直工具】对旋转图像很有用。 切片工具操作及应用详解 taobao详情页经常需要切片，切片加快加载速度， 也方便加链接。 裁剪工具-》按住ctrl键变成切片工具 手动切 按住鼠标左键，拖动可形成自动切片和用户切片。在自动切片可以转换为用户切片。 自动切 如果图片各部分大小比例相同，则可以直接：右键-》划分切片 文件，存储为web所用格式。快捷键：CTRL+【E】 合并图层 透视裁剪，吸管颜色取样，标尺注释等工具 透视裁剪工具 透视裁剪工具 ，图片本身带有透视效果时使用。鼠标左键点击，新建一个点，重复，绘制出要裁切的网格，可以拖动调整。 吸管工具 吸取工具，鼠标左键按住不放，点击吸管，吸取颜色为前景色，按住ALT键，吸取颜色为背景色。 画笔工具需按住ALT键吸取颜色，吸取的是前景色。 颜色取样工具 选择“颜色取样工具，点击或移动鼠标，可以查看RGB或CMYK值 标尺工具 拖动，可测量两个点之间的宽度和高度 注释工具 给每一个需要修改的地方加上相应的注释 计数工具 鼠标点击，可以在图片上添加数值标记，可以计数 橡皮擦及背景橡皮擦和魔术橡皮擦工具 几个橡皮擦在简单抠图中很常用。 橡皮擦工具 画笔大小，硬度可以自己在工具栏调整 当图层为背景图层时，橡皮擦涂抹会涂上背景色。应该先转换为普通图层。 拖动鼠标涂抹即可擦除 背景橡皮擦 背景橡皮擦工具，光标形状有一个+号，代表取样点。 连续取样，当+号没有取样时，不会擦除掉未取样颜色 一次取样，最近一次点击时取得色为擦除颜色。 背景色板，根据背景色和容差设置，可以擦除掉和背景色相近的颜色。容差越小，处理越相近的范围的颜色。 保护前景色，设置后，相应颜色可收到保护。 魔术橡皮擦 类似于魔棒工具，删除比魔棒更快速，简单抠图可以用。 图像选区操作详解 矩形选框工具，按住鼠标不放，拖动可建立选区，此时，进行图像-&gt;调整，可以调整选区局部。 四种选区模式： 新建选区； 增加选区（先按住shift）； 减选（先按住alt）； 交叉选（shift+alt，只保留交叉部分区域） 建立正方形选区：先拖动，再按住shift键。 从中心建立选区：先左键按住拖动，再按住alt键。 中心建立正方形选区：先按住左键拖动，再按住shift和alt； 快捷键： Ctrl+【D】取消选区 按住空格键，调整选区。完成时，应该是先鼠标，再放键盘。 判断区域是选中或者未选中？ 使用选区工具，鼠标放入图片区域。未选中光标未十字形，选中区域光标未小方块。 选区移动要使用选区工具来移动 羽化 羽化半径比实际值大，羽化后可调整亮度，差别没那么大 样式 可设置为等比例或固定大小 椭圆选框工具 填充前景色：Alt+Delete，填充背景色：Ctrl+Delete 和矩形选框区别，多消除锯齿。 单行选框和单列选框，为水平和竖直方向一像素的选区 套索工具的使用 套索工具，用于随意选区和选区调整。 多边形套索工具，通过定点控制。鼠标要控制好，定点取消：delete键，点不要双击，双击为收尾连接。 去除选区外多余部分，选择-》反选（Shift+Ctrl+I） 磁性套索工具，色彩差异大的图像时，比较方便。 频率越大，定点数更多，更适合细节处理。 选区调整，Ctrl + Alt+R，调整边缘，羽化1-2像素,移动边缘-50%（往外羽化，往内收边）； 魔棒工具应用 魔棒利用颜色来进行识别选择的，所以使用前要设置好容差、连续、取样大小 背景单一时，可以用魔棒选择背景，再选择-》反选 快速选择工具，建议勾选自动增强，抠出来的边缘会比较平滑。 画笔大小调整，快捷键为键盘上的中括号。 Ctrl + T 快速调整图层 自由变换","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/Photoshop/"}],"tags":[{"name":"Photoshop学习笔记","slug":"Photoshop学习笔记","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/Photoshop学习笔记/"}]},{"title":"PS-基础知识","slug":"PS 基础知识","date":"2018-01-11T17:45:28.000Z","updated":"2018-01-11T09:01:36.000Z","comments":true,"path":"2018/01/12/PS 基础知识/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/12/PS 基础知识/","excerpt":"","text":"ALT + F1 ， ALT+ F2 调亮 或 调暗 工作界面 位图与矢量图及图像颜色模式的认识 分辨率淘宝美工、电脑手机等 72 分辨率打印印刷品 300分辨率打印要求不高的，可能会用到150分辨率左右图片分辨率：图片本身的分辨率输入分辨率：如相机输出分辨率：打印机、显示器、电视机等 色彩模式重点掌握的色彩模式 CMYK 和 RGB ，如果是打印，那是CMYK，如果是电子设备上呈现，那么使用RGB ，RGB颜色要鲜艳一点。 ps图像文件打开方式详解 新建文件对于网页上用的图片，以像素为单位新建，限制好宽度。分辨率和颜色模式都设置好Ctrl + R 显示标尺 （视图菜单下拉） 打开文件 鼠标左键双击，打开选择图片；或文件-》打开 拖动文件 当文档中有一个图片时，拖动文件进来，光标放在选项卡上，为单独打开。光标放入文档，则拖入文件为置入。 ps文件储存 文件-》储存为 （Ctrl + Shift + S）图片要备份好源文件滤镜-》色彩范围，提供了全新的肤色识别和蒙版 PS功能面板设置 所有界面菜单都在【窗口】菜单内 还原面板设置： 窗口-》工作区-》复位工作区 标尺上会显示不同单位的数据，在标尺上鼠标右键，可以选择标尺的单位。 通过标尺可以快速创建参考线（从标尺处按住鼠标不放，拖动即可） 图像显示的调整 图像-》图像旋转，即可调整横竖排版 快捷键【F】进入全屏模式，快捷键【Tab】进入预览模式 文档缩小和放大 常用工具：抓手工具和缩放工具 快捷键，Ctrl +【+】，Ctrl+【-】，Ctrl+【0】，Ctrl+【1】 利用鼠标滚轮，按住【Alt】键，滚动以光标为中心进行缩放 按住空格键，拖动鼠标，可快速使用抓手工具。 取消参考线，拖动回去，清除单个。视图-》清除参考线，清除所有。","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/Photoshop/"}],"tags":[{"name":"Photoshop学习笔记","slug":"Photoshop学习笔记","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/Photoshop学习笔记/"}]},{"title":"javascript-Ajax 与 Comet","slug":"Ajax 与 Comet","date":"2018-01-09T17:45:28.000Z","updated":"2018-01-15T09:26:34.000Z","comments":true,"path":"2018/01/10/Ajax 与 Comet/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/10/Ajax 与 Comet/","excerpt":"","text":"1、XMLHttpRequest 对象 在浏览器中创建XHR 对象 123456789101112131415161718192021222324function createXHR()&#123; if (typeof XMLHttpRequest != \"undefined\")&#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != \"undefined\")&#123; //兼容IE7以下浏览器 if (typeof arguments.callee.activeXString != \"string\")&#123; var versions = [ \"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\", \"MSXML2.XMLHttp\"], i, len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error(\"No XHR object available.\"); &#125;&#125; 1var xhr = createXHR(); 1.1 XHR 的用法 在使用XHR 对象时，要调用的第一个方法是open()，它接受3个参数：要发送的请求的类型（”get”、”post”等）、请求的URL 和表示是否异步发送请求的布尔值。 调用open()方法并不会真正发送请求，而只是启动一个请求以备发送。要发送特定的请求,需要调用send(),它接受一个参数，即要作为请求主体发送的数据。 如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。 12xhr.open(\"get\", \"example.txt\", false);xhr.send(null); 由于请求是同步的，JavaScript代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR 对象的属性。(1)responseText:作为响应主体被返回的文本。(2)responseXML:如果响应的内容类型是“text/xml”或者“application/xml”，这个属性将保存包含响应数据的XML DOM 文档。(3)status:响应的HTTP状态(4)statusText:HTTP 状态的说明 一般来说，可以将HTTP状态代码为200 作为成功的标志。 状态代码为304 表示请求的资源并没有被修改。 1234567xhr.open(\"get\", \"example.txt\", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText);&#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status);&#125; 发送异步请求时，可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下。 0：未初始化。尚未调用open()方法。 1：启动。已经调用open()方法，但尚未调用send()方法。 2：发送。已经调用send()方法，但尚未收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\", \"example.txt\", true);xhr.send(null); 在接收到响应之前还可以调用abort()方法来取消异步请求。 1xhr.abort(); 调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。 在终止请求之后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR 对象。 1.2 HTTP头部信息 每个HTTP 请求和响应都会带有相应的头部信息。XHR对象也提供了操作这两种头部信息的方法。 默认情况下，在发送XHR请求的同时，还会发出下列头部信息。 Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语音。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何Cookie。 Host：发出请求的页面所在的域。 Referer：发出请求的页面的URI。 User-Agent：浏览器的用户代理字符串。 使用setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。 要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader() 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 )&#123; alert(xhr.responseText); &#125;else&#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\",\"example.php\",true);xhr.setRequestHeader(\"MyHeader\",\"MyValue\");xhr.send(null); 调用XHR 对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。 调用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。 12var myHeader = xhr.getResponseHeader(\"MyHeader\");var allHeaders = xhr.getAllResponseHeaders(); 1.3 GET 请求 GET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL 的末尾，以便将信息发送给服务器。 对XHR 而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。 查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，然后才能放到URL的末尾；而且所有名-值对儿都必须由和号（&amp;）分隔。 1234567891011121314xhr.open(\"get\", \"example.php?name1=value1&amp;name2=value2\", true);//向现有URL 的末尾添加查询字符串参数function addURLParam(url, name, value) &#123; url += (url.indexOf(\"?\") == -1 ? \"?\" : \"&amp;\"); url += encodeURIComponent(name) + \"=\" + encodeURIComponent(value); return url;&#125;var url = \"example.php\";//添加参数url = addURLParam(url, \"name\", \"Nicholas\");url = addURLParam(url, \"book\", \"Professional JavaScript\");//初始化请求xhr.open(\"get\", url, false); 1.4 POST 请求 POST请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交，主体可以包含非常多的数据，而且格式不限。 可以使用XHR 来模仿表单提交：首先将Content-Type头部信息设置为application/x-www-form-urlencoded，也就是表单提交时的内容类型，其次是以适当的格式创建一个字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**以查询字符串的格式输出序列化之后的字符串**/function serialize(form)&#123; var parts = [],field = null,i,len,j,optLen,option,optValue; for (i=0, len=form.elements.length; i &lt; len; i++)&#123; field = form.elements[i]; switch(field.type)&#123; case \"select-one\": case \"select-multiple\": if (field.name.length)&#123; for (j=0, optLen = field.options.length; j &lt; optLen; j++)&#123; option = field.options[j]; if (option.selected)&#123; optValue = \"\"; if (option.hasAttribute)&#123; optValue = (option.hasAttribute(\"value\") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[\"value\"].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + \"=\" + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case \"file\": //文件输入 case \"submit\": //提交按钮 case \"reset\": //重置按钮 case \"button\": //自定义按钮 break; case \"radio\": //单选按钮 case \"checkbox\": //复选框 if (!field.checked)&#123; break; &#125; /* 执行默认操作 */ default: //不包含没有名字的表单字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + \"=\" + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(\"&amp;\");&#125; 1234567891011121314151617function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125; &#125;; xhr.open(\"post\", \"postexample.php\", true); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); var form = document.getElementById(\"user-info\"); xhr.send(serialize(form));&#125; 与GET 请求相比，POST 请求消耗的资源会更多一些。从性能角度来看，以发送相同的数据计，GET 请求的速度最多可达到POST 请求的两倍。 2、XMLHttpRequest 2 级 并非所有浏览器都完整地实现了XMLHttpRequest2级规范，但所有浏览器都实现了它规定的部分内容。 2.1 formData XMLHttpRequest 2 级定义了FormData类型。FormData为序列化表单以及创建与表单格式相同的数据（用于通过XHR 传输）提供了便利。 12var data = new FormData();data.append(\"name\", \"Nicholas\"); 这个append()方法接受两个参数：键和值。分别对应表单字段名和字段中包含的值。 通过formData构造函数传入表单元素，也可以用表单元素的数据预先向其中填入键值对。 1var data = new FormData(document.forms[0]); 创建了FormData 的实例后，可以将它直接传给XHR 的send()方法。 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"post\",\"postexample.php\", true);var form = document.getElementById(\"user-info\");xhr.send(new FormData(form)); 使用FormData 的方便之处体现在不必明确地在XHR 对象上设置请求头部。XHR 对象能够识别传入的数据类型是FormData 的实例，并配置适当的头部信息。 支持FormData 的浏览器有Firefox 4+、Safari 5+、Chrome 和Android3+版WebKit。 2.2 超时设定 IE8 为XHR 对象添加了一个timeout属性，表示请求在等待响应多少毫秒之后就终止。在给timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout 事件，进而会调用ontimeout 事件处理程序。 123456789101112131415161718192021var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125; catch (ex)&#123; //假设由ontimeout 事件处理程序处理 &#125; &#125;&#125;;xhr.open(\"get\", \"timeout.php\", true);xhr.timeout = 1000; //将超时设置为1 秒钟（仅适用于IE8+）xhr.ontimeout = function()&#123; alert(\"Request did not return in a second.\");&#125;;xhr.send(null); 2.3 overrideMimeType()方法 Firefox 最早引入了overrideMimeType()方法，用于重写XHR 响应的MIME 类型。 因为返回响应的MIME类型决定了XHR对象如何处理它，所以提供一种方法能够重写服务器返回的MIME 类型是很有用的。 123456var xhr = createXHR();xhr.open(\"get\", \"text.php\", true);//强迫XHR 对象将响应当作XML 而非纯文本来处理xhr.overrideMimeType(\"text/xml\");xhr.send(null); 支持overrideMimeType()方法的浏览器有Firefox、Safari 4+、Opera 10.5 和Chrome。 3、进度事件 具有6个进度事件 loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断的触发。 error：在请求发生错误时触发。 abort：在因为调用abort()方法而终止连接时触发。 load：在接收到完整的响应数据时触发。 loadend：在通信完成或者触发error、abort或load事件后触发。 3.1 load 事件 Firefox 实现中引入了load事件，用以替代readystatechange事件。响应接收完毕后将触发load事件，因此也就没有必要去检查readyState 属性了。 12345678910var xhr = createXHR();xhr.onload = function()&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125;&#125;;xhr.open(\"get\", \"altevents.php\", true);xhr.send(null); 3.2 progress 事件 Mozilla 对XHR 的另一个革新是添加了progress事件，这个事件会在浏览器接收新数据期间周期性地触发。 onprogress 事件处理程序会接收到一个event 对象，其target 属性是XHR 对象，但包含着三个额外的属性：lengthComputable、position 和totalSize。 lengthComputable是一个表示进度信息是否可用的布尔值，position表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。 123456789101112131415161718var xhr = createXHR();xhr.onload = function()&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125;&#125;;//每次触发progress 事件，都会以新的状态信息更新HTML 元素的内容。xhr.onprogress = function(event)&#123; var divStatus = document.getElementById(\"status\"); if (event.lengthComputable)&#123; divStatus.innerHTML = \"Received \" + event.position + \" of \" + event.totalSize +\" bytes\"; &#125;&#125;;xhr.open(\"get\", \"altevents.php\", true);xhr.send(null); 4、跨源资源共享 通过XHR 实现Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。 CORS定义了在必须访问跨源资源时，浏览器与服务器应该怎么沟通。其背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应应该是成功还是失败。 比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。 12345//Origin 头部的一个示例：Origin: http://www.nczonline.net//如果服务器认为这个请求可以接受Access-Control-Allow-Origin: http://www.nczonline.net 4.1 IE 对CORS 的实现 微软在IE8 中引入了XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。 XDR 与XHR 有一些不同之处。 cookie 不会随请求发送，也不会随响应返回。 只能设置请求头部信息中的Content-Type字段。 不能访问响应头部信息 只支持GET和POST请求 XDR对象的使用方法与XHR对象非常相似。也是创建一个XDomainRequest的实例，调用open()方法，再调用send()方法。但与XHR对象的open()方法不同，XDR对象的open()方法只接收两个参数：请求的类型和URL。 所有XDR 请求都是异步执行的，不能用它来创建同步请求。请求返回之后，会触发load 事件，响应的数据也会保存在responseText 属性中。 12345678910111213var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert(\"An error occurred.\");&#125;;xdr.timeout = 1000;xdr.ontimeout = function()&#123; alert(\"Request took too long.\");&#125;;xdr.open(\"get\", \"http://www.somewhere-else.com/page/\");xdr.send(null); 为支持POST 请求，XDR对象提供了contentType属性，用来表示发送数据的格式,这个属性是通过XDR 对象影响头部信息的唯一方式。 123xdr.open(\"post\", \"http://www.somewhere-else.com/page/\");xdr.contentType = \"application/x-www-form-urlencoded\";xdr.send(\"name1=value1&amp;name2=value2\"); 4.2 其它浏览器对CORS的实现 Firefox 3.5+、Safari 4+、Chrome、iOS 版Safari 和Android 平台中的WebKit 都通过XMLHttpRequest对象实现了对CORS 的原生支持。 要请求位于另一个域中的资源，使用标准的XHR 对象并在open()方法中传入绝对URL 即可。 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\", \"http://www.somewhere-else.com/page/\", true);xhr.send(null); 跨域XHR 对象也有一些限制，但为了安全这些限制是必需的。 不能使用setRequestHeader()设置自定义头部。 不能发送和接收cookie。 调用getAllResponseHeaders()方法总会返回空字符串。 4.3 Preflighted Reqeusts CORS 通过一种叫做PreflightedRequests的透明服务器验证机制支持开发人员使用自定义的头部、GET 或POST 之外的方法，以及不同类型的主体内容。 在使用下列高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS 方法，发送下列头部。 Origin：与简单的请求相同。 Access-Control-Request-Method：请求自身使用的方法。 Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。 1234//一个带有自定义头部NCZ 的使用POST 方法发送的请求。Origin: http://www.nczonline.netAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。 Access-Control-Allow-Origin：与简单的请求相同。 Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔。 Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔。 Access-Control-Max-Age：应该将这个Preflight请求缓存多长时间（以秒表示）。 支持Preflight 请求的浏览器包括Firefox 3.5+、Safari 4+和Chrome。IE 10 及更早版本都不支持。 4.4 带凭据的请求 默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的HTTP 头部来响应。 1Access-Control-Allow-Credentials: true 如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript.（于是，responseText 中将是空字符串，status 的值为0，而且会调用onerror()事件处理程序） 4.5 跨浏览器的CORS 有必要实现一个跨浏览器的方案。检测XHR 是否支持CORS 的最简单方式，就是检查是否存在withCredentials属性。再结合检测XDomainRequest对象是否存在，就可以兼顾所有浏览器。 1234567891011121314151617181920function createCORSRequest(method, url)&#123; var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr)&#123; xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != \"undefined\")&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest(\"get\",\"http://www.somewhere-else.com/page/\");if (request)&#123; request.onload = function()&#123; //对request.responseText 进行处理 &#125;; request.send();&#125; Firefox、Safari 和Chrome 中的XMLHttpRequest 对象与IE 中的XDomainRequest 对象类似，都提供了够用的接口，这两个对象共同的属性/方法如下。 abort()：用于停止正在进行的请求。 onerror：用于替代onreadystatechange 检测错误。 onload：用于替代onreadystatechange 检测成功。 responseText：用于取得响应内容。 send()：用于发送请求。 5、其它跨域技术 利用DOM 中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。 5.1 图像Ping 第一种跨域请求技术是使用&lt;img&gt;标签。 动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204 响应。 通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。 12345var img = new Image();img.onload = img.onerror = function()&#123; alert(\"Done!\");&#125;;img.src = \"http://www.example.com/test?name=Nicholas\"; 图像Ping 最常用于跟踪用户点击页面或动态广告曝光次数 图像Ping 有两个主要的缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。因此，图像Ping 只能用于浏览器与服务器间的单向通信。 5.2 JSONP JSONP 是JSON with padding（填充式JSON 或参数式JSON）的简写，是应用JSON 的一种新方法。 JSONP 看起来与JSON 差不多，只不过是被包含在函数调用中的JSON。 1callback(&#123; \"name\": \"Nicholas\" &#125;); JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。 1http://freegeoip.net/json/?callback=handleResponse JSONP 是通过动态元素来使用的，使用时可以为src 属性指定一个跨域URL. 12345678910//通过查询地理定位服务来显示你的IP 地址和位置信息。function handleResponse(response)&#123; alert(\"You’re at IP address \" + response.ip + \", which is in \" + response.city + \", \" + response.region_name);&#125;var script = document.createElement(\"script\");//典型的JSONP请求，请求一个JSONP 地理定位服务script.src = \"http://freegeoip.net/json/?callback=handleResponse\";document.body.insertBefore(script, document.body.firstChild); JSONP优点： 简单易用 能够直接访问响应文本，支持在浏览器与服务器之间双向通信 JSONP不足： JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。 要确定JSONP 请求是否失败并不容易，开发人员不得不使用计时器检测指定时间内是否接收到了响应。 5.3 Comet Ajax 是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。 有两种实现Comet 的方式：长轮询和流。 (1)长轮询 长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。 无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。 长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。 两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR 对象和setTimeout()就能实现。而你要做的就是决定什么时候发送请求。 (2)HTTP 流 第二种流行的Comet 实现是HTTP流。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个HTTP连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据 在Firefox、Safari、Opera 和Chrome 中，通过侦听readystatechange 事件及检测readyState的值是否为3，就可以利用XHR 对象实现HTTP 流。 123456789101112131415161718192021222324function createStreamingClient(url, progress, finished)&#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open(\"get\", url, true); xhr.onreadystatechange = function()&#123; var result; if (xhr.readyState == 3)&#123; //只取得最新数据并调整计数器 result = xhr.responseText.substring(received); received += result.length; //调用progress 回调函数 progress(result); &#125; else if (xhr.readyState == 4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.send(null); return xhr;&#125;var client = createStreamingClient(\"streaming.php\", function(data)&#123; alert(\"Received: \" + data); &#125;, function(data)&#123; alert(\"Done!\"); &#125;); 5.4 服务器发送事件 SSE（Server-Sent Events，服务器发送事件）是围绕只读Comet 交互推出的API 或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。 服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的JavaScript API 能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。 支持SSE 的浏览器有Firefox 6+、Safari 5+、Opera11+、Chrome和iOS4+版Safari。 (1)SSE API SSE 的JavaScript API与其他传递消息的JavaScriptAPI很相似。要预订新的事件流，首先要创建一个新的EventSource 对象，并传进一个入口点： 1var source = new EventSource(\"myevents.php\"); 传入的URL 必须与创建对象的页面同源（相同的URL模式、域及端口）。 EventSource 的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2 表示关闭了连接。 另外，还有以下三个事件。 open：在建立连接时触发。 message：在从服务器接收到新事件时触发。 error：在无法建立连接时触发。 123456789source.onmessage = function(event)&#123; //服务器发回的数据以字符串形式保存在event.data 中。 var data = event.data; //处理数据 /**如果想强制立即断开连接并且不再重新连接，可以调用close()方法。**/ source.close();&#125;; (2)事件流 所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data: 1234data: foodata: bardata: foodata: bar 通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面皆可。 12data: fooid: 1 设置了ID 后，EventSource对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 5.5 Web Sockets 由于Web Sockets 使用了自定义的协议，所以URL模式也略有不同。。未加密的连接不再是http://，而是ws://；加密的连接也不是https://，而是wss://。 使用自定义协议而非HTTP协议的好处能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP 那样字节级的开销。由于传递的数据包很小，因此Web Sockets 非常适合移动应用。 使用自定义协议的缺点在于，制定协议的时间比制定JavaScript API 的时间还要长. (1) Web Sokets API 要创建Web Socket，先实例一个WebSocket 对象并传入要连接的URL： 1var socket = new WebSocket(\"ws://www.example.com/server.php\"); 与XHR 类似，WebSocket 也有一个表示当前状态的readyState 属性。 WebSocket.OPENING (0)：正在建立连接。 WebSocket.OPEN (1)：已经建立连接。 WebSocket.CLOSING (2)：正在关闭连接。 WebSocket.CLOSE (3)：已经关闭连接。 要关闭Web Socket 连接，可以在任何时候调用close()方法。 12socket.close();/**调用了close()之后，readyState的值立即变为2（正在关闭），而在关闭连接后就会变成3。**/ (2)发送和接收数据 Web Socket 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用send()方法并传入任意字符串。 12var socket = new WebSocket(\"ws://www.example.com/server.php\");socket.send(\"Hello world!\"); 因为Web Sockets 只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。 123456var message = &#123; time: new Date(), text: \"Hello world!\", clientId: \"asdfp8734rew\"&#125;;socket.send(JSON.stringify(message)); 当服务器向客户端发来消息时，WebSocket 对象就会触发message事件。这个message 事件与其他传递消息的协议类似，也是把返回的数据保存在event.data 属性中。 1234socket.onmessage = function(event)&#123; var data = event.data; //处理数据&#125;; (3)其它事件 WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发。 open：在成功建立连接时触发。 error：在发生错误时触发，连接不能持续。 close：在连接关闭时触发。 WebSocket 对象不支持DOM2级事件侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序。 12345678910var socket = new WebSocket(\"ws://www.example.com/server.php\");socket.onopen = function()&#123; alert(\"Connection established.\");&#125;;socket.onerror = function()&#123; alert(\"Connection error.\");&#125;;socket.onclose = function()&#123; alert(\"Connection closed.\");&#125;; 6、安全 对于未被授权系统有权访问某个资源的情况，我们称之为CSRF（Cross-Site Request Forgery，跨站点请求伪造）。未被授权系统会伪装自己，让处理请求的服务器认为它是合法的。 受到CSRF 攻击的Ajax程序有大有小，攻击行为既有旨在揭示系统漏洞的恶作剧，也有恶意的数据窃取或数据销毁。 为确保通过XHR 访问的URL安全，通行的做法就是验证发送请求者是否有权限访问相应的资源。 要求以SSL 连接来访问可以通过XHR 请求的资源。 要求每一次请求都要附带经过相应算法计算得到的验证码。 下列措施对防范CSRF 攻击不起作用。 要求发送POST 而不是GET 请求——很容易改变。 检查来源URL 以确定是否可信——来源记录很容易伪造。 基于cookie 信息进行验证——同样很容易伪造。 小结 Ajax 是无需刷新页面就能够从服务器取得数据的一种方法。关于Ajax，可以从以下几方面来总结一下。(1)负责Ajax 运作的核心对象是XMLHttpRequest（XHR）对象。(2)XHR 对象由微软最早在IE5 中引入，用于通过JavaScript 从服务器取得XML 数据。(3)在此之后，Firefox、Safari、Chrome 和Opera 都实现了相同的特性，使XHR 成为了Web 的一个事实标准。(4)虽然实现之间存在差异，但XHR对象的基本用法在不同浏览器间还是相对规范的，因此可以放心地用在Web 开发当中。 同源策略是对XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。 这个解决方案叫做CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8 通过XDomainRequest 对象支持CORS，其他浏览器通过XHR对象原生支持CORS。图像Ping 和JSONP 是另外两种跨域通信的技术，但不如CORS 稳妥。 Comet 是对Ajax 的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现Comet 的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，而只有部分浏览器原生支持HTTP 流。SSE（Server-SentEvents，服务器发送事件）是一种实现Comet 交互的浏览器API，既支持长轮询，也支持HTTP 流。 Web Sockets 是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets 不使用HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的Web 服务器，但却具有速度上的优势。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-JSON","slug":"JSON","date":"2018-01-05T17:45:28.000Z","updated":"2018-01-05T09:13:56.000Z","comments":true,"path":"2018/01/06/JSON/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/06/JSON/","excerpt":"","text":"1、语法 JSON 的语法可以表示以下三种类型的值。(1)简单值：使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。但JSON 不支持JavaScript 中的特殊值undefined。(2)对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。(3) 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。 JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与JavaScript 中表示数据的某些语法相同，但它并不局限于JavaScript 的范畴。 1.1 简单值 JavaScript 字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号（单引号会导致语法错误）。 布尔值和null 也是有效的JSON 形式。 在实际应用中，JSON更多地用来表示更复杂的数据结构，而简单值只是整个数据结构中的一部分。 1.2 对象 JSON 中的对象与JavaScript 字面量稍微有一些不同。(1)没有声明变量（JSON中没有变量的概念）。(2)没有末尾的分号（因为这不是JavaScript 语句，所以不需要分号）。(3)JSON中，对象的属性必须加双引号。 1234567891011//JavaScript 中的对象字面量var person = &#123; name: \"Nicholas\", age: 29&#125;;//JSON 表示上述对象的方式&#123; \"name\": \"Nicholas\", \"age\": 29&#125; 1.3 数组 JSON 数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。 123456789101112131415161718[ &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011 &#125;, &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 2, year: 2009 &#125;] 2、解析与序列化 JSON 之所以流行，拥有与JavaScript类似的语法并不是全部原因。更重要的一个原因是，可以把JSON数据结构解析为有用的JavaScript 对象。 2.1 JSON 对象 ECMAScript 5 对解析JSON的行为进行规范，定义了全局对象JSON。 支持这个对象的浏览器有IE 8+、Firefox3.5+、Safari 4+、Chrome和Opera 10.5+ JSON 对象有两个方法：stringify()和parse()。在最简单的情况下，这两个方法分别用于把JavaScript 对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript 值。 123456789var book = &#123; title: \"Professional JavaScript\", authors: [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book); 12//序列化之后&#123;\"title\":\"Professional JavaScript\",\"authors\":[\"Nicholas C. Zakas\"],\"edition\":3,\"year\":2011&#125; 将JSON 字符串直接传递给JSON.parse()就可以得到相应的JavaScript 值。 1var bookCopy = JSON.parse(jsonText); 虽然book 与bookCopy具有相同的属性，但它们是两个独立的、没有任何关系的对象。 2.2 序列化选项 JSON.stringify()除了要序列化的JavaScript对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript 对象。 一个参数是个过滤器，可以是一个数组，也可以是一个函数；；另一个参数是一个选项，表示是否在JSON 字符串中保留缩进。 单独或组合使用这两个参数，可以更全面深入地控制JSON 的序列化。 (1)过滤结果 如果过滤器参数是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性。 123456789var book = &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, [\"title\", \"edition\"]); 12//jsonText ：&#123;\"title\":\"Professional JavaScript\",\"edition\":3&#125; 如果过滤器参数是函数，那么传入的函数接受两个参数，属性名和属性值。根据属性名可以知道该如何处理序列化对象中的属性。 属性名只能是字符串，而在值并非是键值对结构时，键名可以为空字符串。 为了改变序列化的结果，函数返回的值就是相应的键的值，如果函数返回了undefined，那么相应的属性会被忽略。 1234567891011121314151617181920var book = &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, function(key, value)&#123; switch(key)&#123; case \"authors\": return value.join(\",\") case \"year\": return 5000; case \"edition\": return undefined; default: return value; &#125;&#125;); 12//jsonText &#123;\"title\":\"Professional JavaScript\",\"authors\":\"Nicholas C.Zakas\",\"year\":5000&#125; Firefox 3.5 和3.6 对JSON.stringify()的实现有一个bug，在将函数作为该方法的第二个参数时这个bug 就会出现，即这个函数只能作为过滤器：返回undefined意味着要跳过某个属性，而返回其他任何值都会在结果中包含相应的属性。Firefox4修复了这个bug。 (2)字符串缩进 JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。 如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。 123456789var book = &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, null, 4); 12345678910//jsonText &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], \"edition\": 3, \"year\": 2011&#125; (3)toJSON()方法 有时候，JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，可以给对象定义toJSON()方法，返回其自身的JSON 数据格式。 可以为任何对象添加toJSON()方法 123456789101112var book = &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011, toJSON: function()&#123; return this.title; &#125;&#125;;var jsonText = JSON.stringify(book); 12//jsonText \"Professional JavaScript\" (4) 序列化顺序 toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。 假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下。(1)如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。(2)如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。(3)对第(2)步返回的每个值进行相应的序列化。(4)如果提供了第三个参数，执行相应的格式化。 2.3 解析选项 JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用。 为了区别JSON.stringify()接收的替换（过滤）函数（replacer），这个函数被称为还原函数（reviver），但实际上这两个函数的签名是相同的——它们都接收两个参数，一个键和一个值，而且都需要返回一个值。 如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。 123456789101112131415161718var book = &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011, releaseDate: new Date(2011, 11, 1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == \"releaseDate\")&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);alert(bookCopy.releaseDate.getFullYear());","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-错误处理和调试","slug":"错误处理和调试","date":"2018-01-04T17:45:28.000Z","updated":"2018-01-04T09:13:42.000Z","comments":true,"path":"2018/01/05/错误处理和调试/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/05/错误处理和调试/","excerpt":"","text":"1、错误处理 任何有影响力的Web应用程序都需要一套完善的错误处理机制，良好的错误处理机制可以让用户及时得到提醒。 1.1 try-catch语句 12345try&#123; // 可能会导致错误的代码&#125; catch(error)&#123; // 在错误发生时怎么处理&#125; (1)finally 子句 虽然在try-catch 语句中是可选的，但finally子句一经使用，其代码无论如何都会执行。 只要代码中包含finally子句，则无论try或catch语句块中包含什么代码——甚至return 语句，都不会阻止finally 子句的执行 12345678910function testFinally()&#123; try &#123; return 2; &#125; catch (error)&#123; return 1; &#125; finally &#123; return 0; &#125;&#125;/**调用这个函数只能返回0**/ (2)错误类型 执行代码期间可能会发生的错误有多种类型。每种错误都有对应的错误类型，而当错误发生时，就会抛出相应类型的错误对象。 Error EvalError RangeError ReferenceError SyntaxError TypeError URIError EvalError 类型的错误会在使用eval()函数而发生异常时被抛出。 12new eval(); //抛出EvalErroreval = foo; //抛出EvalError RangeError 类型的错误会在数值超出相应范围时触发。 12var items1 = new Array(-20); //抛出RangeErrorvar items2 = new Array(Number.MAX_VALUE); //抛出RangeError 在找不到对象的情况下，会发生ReferenceError。 1var obj = x; //在x 并未声明的情况下抛出 ReferenceError 当我们把语法错误的JavaScript字符串传入eval()函数时，就会导致此SyntaxError。 1eval(\"a ++ b\"); //抛出SyntaxError 在执行特定于类型的操作时，变量的类型不符合要求,会导致TypeError。 123var o = new 10; //抛出TypeErroralert(\"name\" in true); //抛出TypeErrorFunction.prototype.toString.call(\"name\"); //抛出TypeError 在使用encodeURI()或decodeURI()，而URI 格式不正确时，就会导致URIError 错误。 利用不同的错误类型，可以获悉更多有关异常的信息，从而有助于对错误作出恰当的处理。 1234567891011try &#123; someFunction();&#125; catch (error)&#123; if (error instanceof TypeError)&#123; //处理类型错误 &#125; else if (error instanceof ReferenceError)&#123; //处理引用错误 &#125; else &#123; //处理其他类型的错误 &#125;&#125; (3)合理使用try-catch 使用try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型JavaScript 库中的函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函数的调用放在try-catch语句当中，万一有什么错误发生，也好恰当地处理它们。 在明明白白地知道自己的代码会发生错误时，再使用try-catch 语句就不太合适了。 1.2 抛出错误 与try-catch 语句相配的还有一个throw 操作符，用于随时抛出自定义错误。 抛出错误时，必须要给throw 操作符指定一个值，这个值是什么类型，没有要求。 在遇到throw 操作符时，代码会立即停止执行。仅当有try-catch语句捕获到被抛出的值时，代码才会继续执行。 利用原型链还可以通过继承Error 来创建自定义错误类型。 123456function CustomError(message)&#123; this.name = \"CustomError\"; this.message = message;&#125;CustomError.prototype = new Error();throw new CustomError(\"My message\"); (1)抛出错误的时机 要针对函数为什么会执行失败给出更多信息，抛出自定义错误是一种很方便的方式。 123456789101112function process(values)&#123; if (!(values instanceof Array))&#123; throw new Error(\"process(): Argument must be an array.\"); &#125; values.sort(); for (var i=0, len=values.length; i &lt; len; i++)&#123; if (values[i] &gt; 100)&#123; return values[i]; &#125; &#125; return -1;&#125; (2) 抛出错误与使用try-catch 如果你打算编写一个要在很多应用程序中使用的JavaScript库，甚至只编写一个可能会在应用程序内部多个地方使用的辅助函数，我都强烈建议你在抛出错误时提供详尽的信息。然后，即可在应用程序中捕获并适当地处理这些错误。 捕获那些确切地知道该如何处理的错误。捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。 1.3 错误事件 在任何Web 浏览器中，onerror事件处理程序都不会创建event对象，但它可以接收三个参数：错误消息、错误所在的URL 和行号。 只要发生错误，无论是不是浏览器生成的，都会触发error事件，并执行这个事件处理程序。 12345window.onerror = function(message, url, line)&#123; alert(message); //阻止浏览器报告错误的默认行为。 return false;&#125;; 1.4 常见的错误类型 由于JavaScript 是松散类型的，而且也不会验证函数的参数，因此错误只会在代码运行期间出现。一般来说，需要关注三种错误： 类型转换错误 数据类型错误 通信错误 (1)类型转换错误 建议使用全等（===）和不全等（!==）操作符，以避免类型转换。 容易发生类型转换错误的另一个地方，就是流控制语句。像if之类的语句在确定下一步操作之前，会自动把任何值转换成布尔值。尤其是if语句，如果使用不当，最容易出错。 123456789101112131415function concat(str1, str2, str3)&#123; var result = str1 + str2; if (str3)&#123; //绝对不要这样!!! result += str3; &#125; return result;&#125;function concat(str1, str2, str3)&#123; var result = str1 + str2; if (typeof str3 == \"string\")&#123; //恰当的比较 result += str3; &#125; return result;&#125; (2) 数据类型错误 为了保证不会发生数据类型错误，只能依靠开发人员编写适当的数据类型检测代码。在将预料之外的值传递给函数的情况下，最容易发生数据类型错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**例子一**///不安全的函数，任何非字符串值都会导致错误function getQueryString(url)&#123; var pos = url.indexOf(\"?\"); if (pos &gt; -1)&#123; return url.substring(pos +1); &#125; return \"\";&#125;function getQueryString(url)&#123; if (typeof url == \"string\")&#123; //通过检查类型确保安全 var pos = url.indexOf(\"?\"); if (pos &gt; -1)&#123; return url.substring(pos +1); &#125; &#125; return \"\";&#125;/**例子二**///不安全的函数，任何非数组值都会导致错误function reverseSort(values)&#123; if (values)&#123; //绝对不要这样!!! values.sort(); values.reverse(); &#125;&#125;//不安全的函数，任何非数组值都会导致错误function reverseSort(values)&#123; if (values != null)&#123; //绝对不要这样!!! values.sort(); values.reverse(); &#125;&#125;//还是不安全，任何非数组值都会导致错误function reverseSort(values)&#123; if (typeof values.sort == \"function\")&#123; //绝对不要这样!!! values.sort(); values.reverse(); &#125;&#125;//安全，非数组值将被忽略function reverseSort(values)&#123; if (values instanceof Array)&#123; //问题解决了 values.sort(); values.reverse(); &#125;&#125; (3)通信错误 第一种通信错误与格式不正确的URL或发送的数据有关。最常见的问题是在将数据发送给服务器之前，没有使用encodeURIComponent()对数据进行编码。 对于查询字符串，应该记住必须要使用encodeURIComponent()方法。为了确保这一点，有时候可以定义一个处理查询字符串的函数。 123456789function addQueryStringArg(url, name, value)&#123; if (url.indexOf(\"?\") == -1)&#123; url += \"?\"; &#125; else &#123; url += \"&amp;\"; &#125; url += encodeURIComponent(name) + \"=\" + encodeURIComponent(value); return url;&#125; 1.5 区分致命错误和非致命错误 对于非致命错误，可以根据下列一或多个条件来确定： 不影响用户的主要任务； 只影响页面的一部分； 可以恢复； 重复相同操作可以消除错误。 致命错误，可以通过以下一或多个条件来确定： 应用程序根本无法继续运行； 错误明显影响到了用户的主要操作； 会导致其他连带错误。 1234567891011for (var i=0, len=mods.length; i &lt; len; i++)&#123; mods[i].init(); //可能会导致致命错误&#125;for (var i=0, len=mods.length; i &lt; len; i++)&#123; try &#123; mods[i].init(); &#125; catch (ex) &#123; //在这里处理错误 &#125;&#125; 1.6 把错误记录到服务器 开发Web 应用程序过程中的一种常见的做法，就是集中保存错误日志，以便查找重要错误的原因。 要建立这样一种JavaScript错误记录系统，首先需要在服务器上创建一个页面用于处理错误数据。这个页面的作用无非就是从查询字符串中取得数据，然后再将数据写入错误日志中。 这个页面可能会使用如下所示的函数： 12345function logError(sev, msg)&#123; var img = new Image(); img.src = \"log.php?sev=\" + encodeURIComponent(sev) + \"&amp;msg=\" + encodeURIComponent(msg);&#125; 使用了Image 对象来发送请求，这样做非常灵活，主要表现如下几方面。(1)所有浏览器都支持Image 对象，包括那些不支持XMLHttpRequest 对象的浏览器。(2)可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误，而这种情况下使用XMLHttpRequest 是不行的。(3)在记录错误的过程中出问题的概率比较低。 1234567for (var i=0, len=mods.length; i &lt; len; i++)&#123; try &#123; mods[i].init(); &#125; catch (ex)&#123; logError(\"nonfatal\", \"Module init failed: \" + ex.message); &#125;&#125; 2、调试技术 (1)将消息记录到控制台 可以通过console 对象向JavaScript 控制台中写入消息。 error(message)：将错误消息记录到控制台 info(message)：将信息性消息记录到控制台 log(message)：将一般消息记录到控制台 warn(message)：将警告消息记录到控制台 (2)将消息记录到当前页面 在页面中开辟一小块区域，用以显示消息 (3)抛出错误 123456function divide(num1, num2)&#123; if (typeof num1 != \"number\" || typeof num2 != \"number\")&#123; throw new Error(\"divide(): Both arguments must be numbers.\"); &#125; return num1 / num2;&#125; 对于大型应用程序来说，自定义的错误通常都使用assert()函数抛出。这个函数接受两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。 123456//基本的assert()函数function assert(condition, message)&#123; if (!condition)&#123; throw new Error(message); &#125;&#125; 使用assert()函数可以减少抛出错误所需的代码量.12345function divide(num1, num2)&#123; assert(typeof num1 == \"number\" &amp;&amp; typeof num2 == \"number\", \"divide(): Both arguments must be numbers.\"); return num1 / num2;&#125;","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-html5 脚本编程","slug":"HTML5 脚本编程","date":"2018-01-03T17:45:28.000Z","updated":"2018-01-04T09:13:16.000Z","comments":true,"path":"2018/01/04/HTML5 脚本编程/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2018/01/04/HTML5 脚本编程/","excerpt":"","text":"1、跨文档消息传递 跨文档消息传送（cross-documentmessaging），有时候简称为XDM，指的是在来自不同域的页面间传递消息。 XDM 的核心是postMessage()方法。 postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。 12345//注意：所有支持XDM 的浏览器也支持iframe 的contentWindow 属性var iframeWindow = document.getElementById(\"myframe\").contentWindow;iframeWindow.postMessage(\"A secret\", \"http://www.wrox.com\");//如果来源匹配，消息会传递到内嵌框架中；否则，postMessage()什么也不做。 接收到XDM消息时，会触发window对象的message事件。这个事件是以异步形式触发的，因此从发送消息到接收消息（触发接收窗口的message事件）可能要经过一段时间的延迟。 触发message事件后，传递给onmessage处理程序的事件对象包含以下三方面的重要信息。（1）data：作为postMessage()第一个参数传入的字符串数据。（2）origin：发送消息的文档所在的域（3）source：发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是window。 在onmessage 处理程序中检测消息来源可以确保传入的消息来自已知的页面。基本的检测模式如下。 123456789EventUtil.addHandler(window, \"message\", function(event)&#123; //确保发送消息的域是已知的域 if (event.origin == \"http://www.wrox.com\")&#123; //处理接收到的数据 processMessage(event.data); //可选：向来源窗口发送回执 event.source.postMessage(\"Received!\", \"http://p2p.wrox.com\"); &#125;&#125;); 2、原生拖放 HTML5 以IE 的实例为基础制定了拖放规范。Firefox 3.5、Safari 3+和Chrome 也根据HTML5 规范实现了原生拖放功能。 2.1 拖放事件 拖动某元素时，将依次触发下列事件。(1) dragstart(2) drag(3) dragend 当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：(1) dragenter(2) dragover(3) dragleave 或drop 2.2 自定义放置目标 虽然所有元素都支持放置目标事件，但这些元素默认是不允许放置的。如果拖动元素经过不允许放置的元素，无论用户如何操作，都不会发生drop 事件。 可以把任何元素变成有效的放置目标，方法是重写dragenter 和dragover 事件的默认行为。 12345678var droptarget = document.getElementById(\"droptarget\");EventUtil.addHandler(droptarget, \"dragover\", function(event)&#123; EventUtil.preventDefault(event);&#125;);EventUtil.addHandler(droptarget, \"dragenter\", function(event)&#123; EventUtil.preventDefault(event);&#125;); 在Firefox 3.5+中，放置事件的默认行为是打开被放到放置目标上的URL。 为了让Firefox 支持正常的拖放，还要取消drop 事件的默认行为，阻止它打开URL。 123EventUtil.addHandler(droptarget, \"drop\", function(event)&#123; EventUtil.preventDefault(event);&#125;); 2.3 dataTransfer 对象 dataTransfer 对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。 因为它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问dataTransfer 对象。 在事件处理程序中，可以使用这个对象的属性和方法来完善拖放功能。 dataTransfer 对象有两个主要方法：getData()和setData()。 123456//设置和接收文本数据event.dataTransfer.setData(\"text\", \"some text\");var text = event.dataTransfer.getData(\"text\");//设置和接收URLevent.dataTransfer.setData(\"URL\", \"http://www.wrox.com/\");var url = event.dataTransfer.getData(\"URL\"); 为了更好地在跨浏览器的情况下从dataTransfer 对象取得数据，最好在取得URL 数据时检测两个值，而在取得文本数据时使用”Text”。 12345var dataTransfer = event.dataTransfer;//读取URLvar url = dataTransfer.getData(\"url\") ||dataTransfer.getData(\"text/uri-list\");//读取文本var text = dataTransfer.getData(\"Text\"); 2.4 dropEffect 和 effectAllowed 通过dropEffect 属性可以知道被拖动的元素能够执行哪种放置行为。这个属性有下列4个可能的值。(1) “none”：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。(2) “move”：应该把拖动的元素移动到放置目标。(3) “copy”：应该把拖动的元素复制到放置目标。(4) “link”：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。 要使用dropEffect属性，必须在ondragenter事件处理程序中针对放置目标来设置它。 dropEffect 属性只有搭配effectAllowed 属性才有用。 effectAllowed 属性表示允许拖动元素的哪种dropEffect，effectAllowed 属性可能的值如下。(1) “uninitialized”：没有给被拖动的元素设置任何放置行为。(2) “none”：被拖动的元素不能有任何行为。(3) “copy”：只允许值为”copy”的dropEffect。(4) “link”：只允许值为”link”的dropEffect。(5) “move”：只允许值为”move”的dropEffect。(6) “copyLink”：允许值为”copy”和”link”的dropEffect。(7) “copyMove”：允许值为”copy”和”move”的dropEffect。(8) “linkMove”：允许值为”link”和”move”的dropEffect。(9) “all”：允许任意dropEffect。 必须在ondragstart 事件处理程序中设置effectAllowed 属性。 2.5 可拖动 HTML5 为所有HTML 元素规定了一个draggable 属性，表示元素是否可以拖动 图像和链接的draggable属性自动被设置成了true，而其他元素这个属性的默认值都是false。 1234&lt;!-- 让这个图像不可以拖动 --&gt;&lt;img src=\"smile.gif\" draggable=\"false\" alt=\"Smiley face\"&gt;&lt;!-- 让这个元素可以拖动 --&gt;&lt;div draggable=\"true\"&gt;...&lt;/div&gt; 2.6 其他成员 HTML5 规范规定dataTransfer 对象还应该包含下列方法和属性。(1) addElement(element)：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而响应回调的对象），不会影响拖动操作时页面元素的外观。(2) clearData(format)：清除以特定格式保存的数据(3) setDragImage(element, x, y)：指定一幅图像，当拖动发生时，显示在光标下方。(4) types：当前保存的数据类型。这是一个类似数组的集合，以”text”这样的字符串形式保存着数据类型。 3、媒体元素 HTML5 新增了两个与媒体相关的标签&lt;audio&gt;和&lt;video&gt;。，让开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容。 1234&lt;!-- 嵌入视频 --&gt;&lt;video src=\"conference.mpg\" id=\"myVideo\"&gt;Video player not available.&lt;/video&gt;&lt;!-- 嵌入音频 --&gt;&lt;audio src=\"song.mp3\" id=\"myAudio\"&gt;Audio player not available.&lt;/audio&gt; 因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源。为此，不用在标签中指定src 属性，而是要像下面这样使用一或多个&lt;source&gt;元素。 12345678910111213&lt;!-- 嵌入视频 --&gt;&lt;video id=\"myVideo\"&gt;&lt;source src=\"conference.webm\" type=\"video/webm; codecs='vp8, vorbis'\"&gt;&lt;source src=\"conference.ogv\" type=\"video/ogg; codecs='theora, vorbis'\"&gt;&lt;source src=\"conference.mpg\"&gt;Video player not available.&lt;/video&gt;&lt;!-- 嵌入音频 --&gt;&lt;audio id=\"myAudio\"&gt;&lt;source src=\"song.ogg\" type=\"audio/ogg\"&gt;&lt;source src=\"song.mp3\" type=\"audio/mpeg\"&gt;Audio player not available.&lt;/audio&gt; 3.1 属性 &lt;video&gt;和&lt;audio&gt;元素都提供了完善的JavaScript 接口。 下表列出了这两个元素共有的属性，通过这些属性可以知道媒体的当前状态。 属性 数据类型 说明 autoplay 布尔值 取得或设置autoplay标志 buffered 时间范围 表示已下载的缓冲的时间范围的对象 bufferedBytes 字节范围 表示已下载的缓冲的字节范围的对象 bufferingRate 整数 下载过程中每秒钟平均接收到的位数 bufferingThrottled 布尔值 表示浏览器是否对缓冲进行了节流 controls 布尔值 取得或设置controls属性，用于显示或隐藏浏览器内置的控件 currentLoop 整数 媒体文件已经循环的次数 currentSrc 字符串 当前播放的媒体文件的URL currentTime 浮点数 已经播放的秒数 defaultPlaybackRate 浮点数 取得或设置默认的播放速度。默认值为1.0秒 duration 浮点数 媒体的总播放时间（秒数） ended 布尔值 表示媒体文件是否播放完成 loop 布尔值 取得或设置媒体文件在播放完成后是否再从头开始播放 muted 布尔值 取得或设置媒体文件是否静音 networkState 整数 表示当前媒体的网络连接状态：0表示空，1表示正在加载，2表示正在加载元数据，3表示已经加载了第一帧，4表示加载完成 paused 布尔值 表示播放器是否暂停 playbackRate 浮点数 取得或设置当前的播放速度 played 时间范围 到目前为止已经播放的时间范围 readyState 整数 表示媒体是否已经就绪（可以播放了）。0表示数据不可用，1表示可以显示当前帧，2表示可以开始播放，3表示媒体可以从头到尾播放 seekable 时间范围 可以搜索的时间范围 seeking 布尔值 表示播放器是否正移动到媒体文件中的新位置 src 字符串 媒体文件的来源。任何时候都可以重写这个属性 start 浮点数 取得或设置媒体文件中开始播放的位置，以秒表示 totalBytes 整数 当前资源所需的总字节数 videoHeight 整数 返回视频（不一定是元素）的高度。只适用于&lt;video&gt; videoWidth 整数 返回视频（不一定是元素）的宽度。只适用于&lt;video&gt; volume 浮点数 取得或设置当前音量，值为0.0到1.0 3.2 事件 除了大量属性之外，这两个媒体元素还可以触发很多事件。下表列出了媒体元素相关的事件。 事件 触发时机 abort 下载中断 canplay 可以播放时；readyState值为2 canplaythrough 播放可继续，而且应该不会中断；readyState值为3 canshowcurrentframe 当前帧已经下载完成；readyState值为1 dataunavailable 因为没有数据而不能播放；readyState值为0 durationchange duration属性的值改变 emptied 网络连接关闭 empty 发生错误阻止了媒体下载 ended 媒体已播放到末尾，播放停止 error 下载期间发生网络错误 loadeddata 媒体的第一帧已加载完成 loadedmetadata 媒体的元数据已加载完成 loadstart 下载已开始 pause 播放已暂停 play 媒体已接收到指令开始播放 playing 媒体已实际开始播放 progress 正在下载 ratechange 播放媒体的速度改变 seeked 搜索结束 seeking 正移动到新位置 stalled 浏览器尝试下载，但未接收到数据 timeupdate currentTime被以不合理或意外的方式更新 volumechange volume属性值或muted属性值已改变 waiting 播放暂停，等待下载更多数据 3.3 自定义媒体播放器 使用和元素的play()和pause()方法，可以手工控制媒体文件的播放。 组合使用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器。 123456789101112&lt;div class=\"mediaplayer\"&gt; &lt;div class=\"video\"&gt; &lt;video id=\"player\" src=\"movie.mov\" poster=\"mymovie.jpg\" width=\"300\" height=\"200\"&gt; Video player not available. &lt;/video&gt; &lt;/div&gt; &lt;div class=\"controls\"&gt; &lt;input type=\"button\" value=\"Play\" id=\"video-btn\"&gt; &lt;span id=\"curtime\"&gt;0&lt;/span&gt;/&lt;span id=\"duration\"&gt;0&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031//取得元素的引用var player = document.getElementById(\"player\"),btn = document.getElementById(\"video-btn\"),curtime = document.getElementById(\"curtime\"),duration = document.getElementById(\"duration\");//更新播放时间duration.innerHTML = player.duration;//为按钮添加事件处理程序var EventUtil = &#123;addHander:function(element,type,handler) if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(\"on\"+type,handler,false); &#125;else&#123; element[\"on\"+type] = handler; &#125;&#125;;EventUtil.addHandler(btn, \"click\", function(event)&#123; if (player.paused)&#123; player.play(); btn.value = \"Pause\"; &#125; else &#123; player.pause(); btn.value = \"Play\"; &#125;&#125;);//定时更新当前时间setInterval(function()&#123; curtime.innerHTML = player.currentTime;&#125;, 250); 3.4 检测编码解码支持情况 两个媒体元素都有一个canPlayType()方法，该方法接收一种格式/编解码器字符串，返回”probably”、”maybe”或””（ 空字符串）。 1234567var audio = document.getElementById(\"audio-player\");//很可能\"maybe\"if (audio.canPlayType(\"audio/mpeg\"))&#123;//进一步处理&#125;//可能是\"probably\"if (audio.canPlayType(\"audio/ogg; codecs=\\\"vorbis\\\"\"))&#123; 3.5 Audio 类型 &lt;audio&gt;元素还有一个原生的JavaScript构造函数Audio，可以在任何时候播放音频。 Audio 与Image 很相似，但Audio 不用像Image那样必须插入到文档中。只要创建一个新实例，并传入音频源文件即可。 1234var audio = new Audio(\"sound.mp3\");EventUtil.addHandler(audio, \"canplaythrough\", function(event)&#123; audio.play();&#125;); 创建新的Audio 实例即可开始下载指定的文件。下载完成后，调用play()就可以播放音频。 4、历史状态管理 HTML5 新增了hashchange事件，以便在URL的参数列表（及URL中“#”号后面的所有字符串）发生变化时通知开发人员。 HTML5 通过更新history 对象为管理历史状态提供了方便 通过hashchange 事件，可以知道URL的参数什么时候发生了变化，即什么时候该有所反应。 通过状态管理API ， 能够在不加载新页面的情况下改变浏览器的URL 。 使用history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对URL。 1history.pushState(&#123;name:\"Nicholas\"&#125;, \"Nicholas' page\", \"nicholas.html\"); 要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。 1history.replaceState(&#123;name:\"Greg\"&#125;, \"Greg's page\");","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-Canvas绘图详解","slug":"Canvas绘图详解","date":"2017-12-21T17:45:28.000Z","updated":"2018-01-03T09:50:22.000Z","comments":true,"path":"2017/12/22/Canvas绘图详解/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/22/Canvas绘图详解/","excerpt":"","text":"Canvas绘图 HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域，您可以控制其每一像素。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 浏览器支持 Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持&lt;canvas&gt; 及其属性和方法。 注释：Internet Explorer 8 以及更早的版本不支持 &lt;canvas&gt; 元素。 HTML 5 Canvas 参考手册 1、基本用法 (1)创建 Canvas 元素 向 HTML5 页面添加 canvas 元素。 规定元素的 id、宽度和高度。 开始和结束标签中的内容是后备信息，如果浏览器不支持&lt;canvas&gt;元素，就会显示这些信息。 1&lt;canvas id = \"drawing\" width = \"200\" height= \"200\"&gt;A drawing of something&lt;/canvas&gt; (2)通过 JavaScript 来绘制 canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成。 要在这块画布（canvas）上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用getContext()方法并传入上下文的名字。 123456var drawing = document.getElementById(\"drawing\");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext(\"2d\"); //更多代码&#125; 使用toDataURL()方法，可以导出在&lt;canvas&gt;元素上绘制的图像。这个方法接受一个参数，即图像的MIME 类型格式，而且适合用于创建图像的任何上下文。 123456789101112var drawing = document.getElementById(\"drawing\");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; //取得图像的数据URI var imgURI = drawing.toDataURL(\"image/png\"); //显示图像 var image = document.createElement(\"img\"); image.src = imgURI; document.body.appendChild(image);&#125; 2、2D上下文 使用2D 绘图上下文提供的方法，可以绘制简单的2D 图形，比如矩形、弧线和路径。 2D 上下文的坐标开始于&lt;canvas&gt;元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算，x 值越大表示越靠右，y 值越大表示越靠下。 默认情况下，width 和height 表示水平和垂直两个方向上可用的像素数目。 2.1 填充和描边 填充，就是用指定的样式（颜色、渐变或图像）填充图形； 描边，就是只在图形的边缘画线。 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是”#000000”。 如果为它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色名、十六进制码、rgb、rgba、hsl 或hsla。 12345678var drawing = document.getElementById(\"drawing\");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext(\"2d\"); context.strokeStyle = \"red\"; context.fillStyle = \"#0000ff\";&#125; 2.2 绘制矩形 矩形是唯一一种可以直接在2D上下文中绘制的形状。 与矩形有关的有四个方法。 方法 描述 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 这几个方法都能接收4个参数 参数 描述 x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 1234&lt;!--示例画布--&gt;&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt;Your browser does not support the HTML5 canvas tag.&lt;/canvas&gt; (1) rect() 使用 stroke() 或 fill() 方法在画布上实际地绘制矩形。 javascript 语法 1context.rect(x,y,width,height); 示例 12345678910111213141516171819202122232425/**通过 rect() 方法来创建三个矩形**/var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 红色矩形ctx.beginPath();ctx.lineWidth=\"6\";ctx.strokeStyle=\"red\";ctx.rect(5,5,290,140); ctx.stroke();// 绿色矩形ctx.beginPath();ctx.lineWidth=\"4\";ctx.strokeStyle=\"green\";ctx.rect(30,30,50,50);ctx.stroke();// 蓝色矩形ctx.beginPath();ctx.lineWidth=\"10\";ctx.strokeStyle=\"blue\";ctx.rect(50,50,150,80);ctx.stroke(); (2)fillRect() fillRect()方法在画布上绘制的矩形会填充指定的颜色。填充的颜色通过fillStyle 属性指定。 javascript 语法 1context.fillRect(x,y,width,height); 示例 123456789101112/**绘制填充矩形**/var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");//绘制红色矩形context.fillStyle = \"#ff0000\";context.fillRect(10, 10, 50, 50);//绘制半透明的蓝色矩形context.fillStyle = \"rgba(0,0,255,0.5)\";context.fillRect(30, 30, 50, 50); (3)strokeRect() strokeRect() 方法绘制矩形（不填色）。笔触的默认颜色是黑色。 strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边。描边颜色通过strokeStyle 属性指定。 javascript 语法 1context.strokeRect(x,y,width,height); 示例 123456789var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");//绘制红色描边矩形context.strokeStyle = \"#ff0000\";context.strokeRect(10, 10, 50, 50);//绘制半透明的蓝色描边矩形context.strokeStyle = \"rgba(0,0,255,0.5)\";context.strokeRect(30, 30, 50, 50); (4)clearRect() clearRect()方法用于清除画布上的矩形区域。 本质上，这个方法可以把绘制上下文中的某一矩形区域变透明。通过绘制形状然后再清除指定区域，就可以生成有意思的效果。 javascript 语法 1context.clearRect(x,y,width,height); 示例 12345678910111213var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");//绘制红色矩形context.fillStyle = \"#ff0000\";context.fillRect(10, 10, 50, 50);//绘制半透明的蓝色矩形context.fillStyle = \"rgba(0,0,255,0.5)\";context.fillRect(30, 30, 50, 50);//在两个矩形重叠的地方清除一个小矩形context.clearRect(40, 40, 10, 10); 2.3 绘制路径 2D 绘制上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复杂的形状和线条。 方法 描述 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false (1)fill() fill() 方法填充当前的图像（路径）。默认颜色是黑色。 使用 fillStyle 属性来填充另一种颜色/渐变。 javascript 语法 1context.fill(); 示例 12345var c=document.getElementById(\"myCanvas\");var context = c.getContext('2d');context.rect(20,20,150,100)context.fillStyle = \"green\";context.fill(); (2)stroke() stroke() 方法会实际地绘制出通过moveTo()和lineTo()方法定义的路径。默认颜色是黑色。 使用 strokeStyle 属性来绘制另一种颜色/渐变。 javascript 语法 1context.stroke(); 示例 12345678var c=document.getElementById(\"myCanvas\");var context = c.getContext('2d');context.beginPath();context.moveTo(20,20);context.lineTo(20,100);context.lineTo(70,100);context.strokeStyle = \"green\";context.stroke(); (3)beginPath()、moveTo()、lineTo() beginPath() 方法开始一条路径，或重置当前的路径。 moveTo(x, y)：将绘图游标移动到(x,y)，不画线。 lineTo(x, y)：从上一点开始绘制一条直线，到(x,y)为止。 javascript 语法 123context.beginPath();context.moveTo(x,y);context.lineTo(x,y); 示例 1234567891011121314var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath(); ctx.strokeStyle=\"red\"; // 绿色路径ctx.moveTo(0,75);ctx.lineTo(300,75);ctx.stroke(); // 进行绘制ctx.beginPath();ctx.strokeStyle=\"blue\"; // 紫色路径ctx.moveTo(150,0);ctx.lineTo(150,150); ctx.stroke(); // 进行绘制 (4)closePath() closePath() 方法创建从当前点到开始点的路径。 使用 stroke() 方法在画布上绘制确切的路径。 使用 fill() 方法来填充图像（默认是黑色）。请使用fillStyle属性来填充另一个颜色/渐变。 javascript 语法 1context.closePath(); 示例12345678910var c = document.getElementById(\"myCanvas\");var context = c.getContext('2d');context.beginPath();context.moveTo(20,20);context.lineTo(20,100);context.lineTo(100,100);context.closePath();context.stroke();context.fillStyle = \"green\";context.fill(); (5)clip() clip() 方法从原始画布中剪切任意形状和尺寸。 javascript语法 1context.clip(); 示例 123456789101112131415161718var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// Draw a rectanglectx.rect(50,20,200,120);ctx.stroke();// Draw green rectanglectx.fillStyle=\"green\";ctx.fillRect(0,0,150,100);var c=document.getElementById(\"myCanvas2\");var ctx=c.getContext(\"2d\");// Clip a rectangular areactx.rect(50,20,200,120);ctx.stroke();ctx.clip();// Draw red rectangle after clip()ctx.fillStyle=\"red\";ctx.fillRect(0,0,150,100); (6)quadraticCurveTo() quadraticCurveTo() 方法通过使用表示二次贝塞尔曲线的指定控制点，向当前路径添加一个点。 javascript 语法 1context.quadraticCurveTo(cpx,cpy,x,y); 从上一点开始绘制一条二次曲线，到(x,y)为止，并且以(cpx,cpy)作为控制点。 示例 123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); 二次贝塞尔曲线需要两个点。第一个点是用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点。 曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 (7)bezierCurveTo() bezierCurveTo() 方法通过使用表示三次贝塞尔曲线的指定控制点，向当前路径添加一个点。 javascript 语法 1context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); 从上一点开始绘制一条曲线，到(x,y)为止，并且以(cp1x,cp1y)和(cp2x,cp2y)为控制点。 示例 123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.bezierCurveTo(20,100,200,100,200,20);ctx.stroke(); 三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。 曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 (8)arc() arc() 方法创建弧/曲线（用于创建圆或部分圆）。 javascript 语法 1context.arc(x,y,r,sAngle,eAngle,counterclockwise); 参数值 参数 描述 x 圆的中心的 x 坐标。 y 圆的中心的 y 坐标。 r 圆的半径。 sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。 eAngle 结束角，以弧度计。 counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。 示例 12345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.arc(100,75,50,0,2*Math.PI);ctx.stroke(); 如需通过 arc() 来创建圆，请把起始角设置为 0，结束角设置为 2*Math.PI。 使用 stroke() 或 fill() 方法在画布上绘制实际的弧。 (9)arcTo() arcTo() 方法在画布上创建介于两个切线之间的弧/曲线。 从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径radius 穿过(x1,y1)。 javascript 语法 1context.arcTo(x1, y1, x2, y2, radius) 示例 1234567891011121314151617181920//获取Canvas对象(画布)var canvas = document.getElementById(\"myCanvas\");if(canvas.getContext)&#123; var ctx = canvas.getContext(\"2d\"); ctx.moveTo(50, 50); //端点1 var p1 = &#123; x : 200, y : 50 &#125;; //端点2 var p2 = &#123; x : 200, y : 100 &#125;; //绘制与当前端点、端点1、端点2三个点所形成的夹角的两边相切并且半径为50px的圆的一段弧线 ctx.arcTo(p1.x, p1.y, p2.x, p2.y, 50); ctx.strokeStyle = \"blue\"; ctx.stroke();&#125; (10)isPointInPath() isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。 javascrit 语法 1context.isPointInPath(x,y); 示例 123456var c=document.getElementById(\"myCanvas\");var context = c.getContext(\"2d\");context.rect(10,10,100,100);if(context.isPointInPath(20,50))&#123; context.stroke();&#125; 2.4 绘制文本 2D 绘图上下文提供了2个绘制文本方法和一个相关方法 fillText()和strokeText()都可以接收4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。而measureText()接受一个参数，表示要测量的文本。 方法 描述 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 这两个方法都以下列3 个属性为基础。 属性 描述 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式，建议使用”start”和”end” textBaseline 表示文本的基线，可以调整文本的垂直对齐方式 (1)fillText() fillText() 方法在画布上绘制填色的文本。文本的默认颜色是黑色。 javascript 语法 1context.fillText(text,x,y,maxWidth); 示例 12345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"30px Times new Roman\";ctx.fillStyle = \"red\"ctx.fillText(\"Hello World!\",10,50); (2)strokeText() strokeText() 方法在画布上绘制文本（没有填色）。文本的默认颜色是黑色。 javascript 语法 1context.strokeText(text,x,y,maxWidth); 示例 12345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"40px Times new Roman\";ctx.strokeStyle = \"red\";ctx.strokeText(\"Hello World!\",10,50); (3)measureText() measureText() 方法返回包含一个对象，该对象包含以像素计的指定字体宽度。 javascript 语法 1context.measureText(text).width; 示例 1234567//在画布上输出文本之前，检查字体的宽度var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"20px Arial\";var txt=\"Hello World\"ctx.fillText(\"width:\" + ctx.measureText(txt).width,10,50);ctx.fillText(txt,10,100); (4)textAlign textAlign 属性根据锚点，设置或返回文本内容的当前对齐方式。 javascript 语法 1context.textAlign=\"center|end|left|right|start\"; 示例 123456789101112131415161718192021var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// Create a red line in position 150ctx.strokeStyle=\"blue\";ctx.moveTo(150,20);ctx.lineTo(150,170);ctx.stroke();ctx.font=\"15px Arial\"; // Show the different textAlign valuesctx.textAlign=\"start\"; ctx.fillText(\"textAlign=start\",150,60); ctx.textAlign=\"end\"; ctx.fillText(\"textAlign=end\",150,80); ctx.textAlign=\"left\"; ctx.fillText(\"textAlign=left\",150,100);ctx.textAlign=\"center\"; ctx.fillText(\"textAlign=center\",150,120); ctx.textAlign=\"right\"; ctx.fillText(\"textAlign=right\",150,140); (5)textBaseline textBaseline 属性设置或返回在绘制文本时的当前文本基线。 javascript 语法 1context.textBaseline=\"alphabetic|top|hanging|middle|ideographic|bottom\"; 示例 12345678910111213141516171819202122var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");//Draw a red line at y=100ctx.strokeStyle=\"blue\";ctx.moveTo(5,100);ctx.lineTo(395,100);ctx.stroke();ctx.font=\"20px Arial\"//Place each word at y=100 with different textBaseline valuesctx.textBaseline=\"top\"; ctx.fillText(\"Top\",5,100); ctx.textBaseline=\"bottom\"; ctx.fillText(\"Bottom\",50,100); ctx.textBaseline=\"middle\"; ctx.fillText(\"Middle\",120,100); ctx.textBaseline=\"alphabetic\"; ctx.fillText(\"Alphabetic\",190,100); ctx.textBaseline=\"hanging\"; ctx.fillText(\"Hanging\",290,100); 2.5 变换 2D 绘制上下文支持各种基本的绘制变换。创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。 为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。 可以通过如下方法来修改变换矩阵。 方法 描述 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() (1)scale() scale() 方法缩放当前绘图，更大或更小。 如果您对绘图进行缩放，所有之后的绘图也会被缩放。定位也会被缩放。 javascript语法 1context.scale(scalewidth,scaleheight); 缩放图像，在x 方向乘以scaleX，在y 方向乘以scaleY。scaleX和scaleY 的默认值都是1.0。 参数值 参数 描述 scalewidth 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.) 1234567891011/**依次放大**/var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15); (2)rotate() rotate(angle)，围绕原点旋转图像angle 弧度。 javascript 语法 1context.rotate(angle); 参数值参数| 描述-|-angle |旋转角度，以弧度计。如需将角度转换为弧度，请使用degreesMath.PI/180 公式进行计算。举例：如需旋转 5 度，可规定下面的公式：5Math.PI/180。 示例 1234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rotate(20*Math.PI/180);ctx.fillRect(50,20,100,50); (3)translate() translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y)表示的点。 javascript语法 1context.translate(x,y); 示例 1234567891011121314151617181920212223242526/**绘制一个简易的时钟**/var c=document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.beginPath();ctx.arc(150,75,70,0,2*Math.PI);ctx.stroke();ctx.moveTo(215,75);ctx.arc(150,75,65,0,2*Math.PI);//变换原点ctx.translate(150,75);ctx.textBaseline = \"middle\";ctx.fillText('3',50,0);ctx.textAlign=\"center\"; ctx.fillText('6',0,55);ctx.fillText('9',-50,0);ctx.fillText('12',0,-55);ctx.moveTo(0,0);ctx.lineTo(35,0);ctx.moveTo(0,0);ctx.lineTo(0,-50);ctx.stroke(); (4)transform() 画布上的每个对象都拥有一个当前的变换矩阵。 transform() 方法替换当前的变换矩阵。它以下面描述的矩阵来操作当前的变换矩阵 123a c eb d f0 0 1 transform() 允许您缩放、旋转、移动并倾斜当前的环境。 javascript语法 1context.transform(a,b,c,d,e,f); 参数值 参数 描述 a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 示例 由此可见，transform(x, 0, 0, y, 0, 0)，等同于scale(x,y)； transform(1, 0, 0, 1, x, y)，等同于translate(x,y)； 1234567891011121314151617181920var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeStyle=\"green\";ctx.strokeRect(0,0,100,30)//等同于translate(x,y)ctx.transform(1,0,0,1,30,30);ctx.strokeStyle=\"red\";ctx.strokeRect(0,0,100,30);//等同于scale(2,2)ctx.transform(2,0,0,2,0,0);ctx.strokeStyle=\"blue\";ctx.strokeRect(0,0,100,30);//水平和竖直方向倾斜ctx.transform(1,0.5,0.5,1,0,0);ctx.strokeStyle=\"black\";ctx.strokeRect(0,0,100,30); (5)setTransform() setTransform() 方法把当前的变换矩阵重置为单位矩阵，然后以相同的参数运行 transform()。 javascript语法 1context.setTransform(a,b,c,d,e,f); 示例 1234567891011121314151617181920var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeStyle=\"green\";ctx.strokeRect(0,0,100,30)//等同于translate(x,y)ctx.setTransform(1,0,0,1,30,30);ctx.strokeStyle=\"red\";ctx.strokeRect(0,0,100,30);//等同于scale(2,2)ctx.setTransform(2,0,0,2,0,0);ctx.strokeStyle=\"blue\";ctx.strokeRect(0,0,100,30);//水平和竖直方向倾斜ctx.setTransform(1,0.5,0.5,1,0,0);ctx.strokeStyle=\"black\";ctx.strokeRect(0,0,100,30); 2.6 绘制图像 drawImage() 方法在画布上绘制图像、画布或视频。 drawImage() 方法也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。 JavaScript 语法 12345678/***语法一，在画布上定位图像*/context.drawImage(img,x,y);/**语法二，在画布上定位图像，并规定图像的宽度和高度**/context.drawImage(img,x,y,width,height);/**语法三，剪切图像，并在画布上定位被剪切的部分**/context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数值 参数 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 示例 1&lt;img src=\"http://www.w3school.com.cn/i/eg_tulip.jpg\" alt=\"tulip\" id=\"tulip\" style=\"margin-left:0px;\" /&gt; 123456document.getElementById(\"tulip\").onload=function()&#123; var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); var img=document.getElementById(\"tulip\"); ctx.drawImage(img,90,130,90,80,20,20,90,80);&#125;; 2.7 阴影 2D 上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。 属性 描述 shadowColor 用CSS 颜色格式表示的阴影颜色，默认为黑色。 shadowBlur 模糊的像素数，默认0，即不模糊。 shadowOffsetX 形状或路径x 轴方向的阴影偏移量，默认为0。 shadowOffsetY 形状或路径y 轴方向的阴影偏移量，默认为0。 示例 12345678910111213var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");//设置阴影context.shadowOffsetX = 15;context.shadowOffsetY = 15;context.shadowBlur = 5;context.shadowColor = \"rgba(0, 0, 0, 0.5)\";//绘制红色矩形context.fillStyle = \"#ff0000\";context.fillRect(10, 10, 50, 50);//绘制蓝色矩形context.fillStyle = \"rgba(0,0,255,1)\";context.fillRect(30, 30, 50, 50); 2.8 渐变 渐变由CanvasGradient 实例表示，很容易通过2D 上下文来创建和修改。 方法 描述 createLinearGradient() 创建线性渐变（用在画布内容上） createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 (1)createLinearGradient() createLinearGradient() 方法创建线性的渐变对象。 渐变可用于填充矩形、圆形、线条、文本等等 JavaScript 语法 1context.createLinearGradient(x0,y0,x1,y1); 示例 123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,\"white\");grd.addColorStop(1,\"red\");ctx.fillStyle=grd;ctx.fillRect(20,20,150,100); (2)createRadialGradient() createLinearGradient() 方法创建放射状/圆形渐变对象。 渐变可用于填充矩形、圆形、线条、文本等等。 JavaScript 语法 1context.createRadialGradient(x0,y0,r0,x1,y1,r1); 示例 123456789var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");var gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30);gradient.addColorStop(0, \"white\");gradient.addColorStop(1, \"red\");//绘制渐变矩形context.fillStyle = gradient;context.fillRect(30, 30, 150, 100); 2.9 模式 createPattern() 方法在指定的方向内重复指定的元素。 元素可以是图片、视频，或者其他 元素。 被重复的元素可用于绘制/填充矩形、圆形或线条等等。 JavaScript 语法 1context.createPattern(image,\"repeat|repeat-x|repeat-y|no-repeat\"); 示例 1&lt;img src=\"http://www.w3school.com.cn/i/lamp.gif\" id=\"lamp\" /&gt; 1234567var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");var image = document.getElementById(\"lamp\"),pattern = context.createPattern(image, \"repeat\");//绘制矩形context.fillStyle = pattern;context.fillRect(0, 0, 160, 130); 2.10 像素操作与使用图像数据 2D 上下文 支持像素操作和使用图像数据 方法 描述 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 每个ImageData 对象都有三个属性：width、height 和data 属性 描述 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 data 属性是一个数组，保存着图像中每一个像素的数据。对于ImageData对象中的每个像素，都存在着四方面的信息，即 RGBA 值： 元素 值 R 红色 (0-255) G 绿色 (0-255) B 蓝色 (0-255) A alpha 通道 (0-255; 0 是透明的，255 是完全可见的) (1)createImageData() createImageData() 方法创建新的空白 ImageData 对象。新对象的默认像素值 transparent black。 javascript 语法 12345/**语法一，以指定的尺寸（以像素计）创建新的 ImageData 对象**/var imgData=context.createImageData(width,height);/**语法二，创建与指定的另一个 ImageData 对象尺寸相同的新 ImageData 对象（不会复制图像数据）**/var imgData=context.createImageData(imageData); 示例 123456789101112/**创建 100*100 像素的 ImageData 对象，其中每个像素都是绿色的，然后把它放到画布上**/var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var imgData=ctx.createImageData(100,100);for (var i=0;i&lt;imgData.data.length;i+=4) &#123; imgData.data[i+0]=0; imgData.data[i+1]=255; imgData.data[i+2]=0; imgData.data[i+3]=255; &#125;ctx.putImageData(imgData,10,10); (2)getImageData()、putImageData() getImageData() 方法返回ImageData对象，该对象拷贝了画布指定矩形的像素数据。 putImageData() 方法将图像数据（从指定的 ImageData 对象）放回画布上。 javascript 语法 12var imgData=context.getImageData(x,y,width,height);context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight); 示例 1&lt;img src=\"http://www.w3school.com.cn/i/eg_tulip.jpg\" alt=\"tulip\" id=\"tulip\" style=\"margin-left:0px;\" /&gt; 12345678910111213/**使用 getImageData() 来反转画布上的图像的每个像素的颜色**/var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");var img = document.getElementById(\"tulip\");ctx.drawImage(img,0,0);var imgData = ctx.getImageData(0,0,c.width,c.height);for(var i= 0; i&lt;imgData.data.length; i+=4)&#123; imgData.data[i] = 255-imgData.data[i]; imgData.data[i+1] = 255- imgData.data[i+1]; imgData.data[i+2] = 255-imgData.data[i+2]; imgData.data[i+3] = 255;&#125;ctx.putImageData(imgData,0,0); 2.11合成 有两个会应用到2D 上下文中所有绘制操作的属性：globalAlpha和globalComposition-Operation 属性 描述 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 (1)globalAlpha() globalAlpha 属性设置或返回绘图的当前透明值（alpha 或 transparency）。 globalAlpha 是一个介于0 和1 之间的值（包括0 和1），用于指定所有绘制的透明度。默认值为0。 javascript 语法 1context.globalAlpha=number; 示例 12345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(20,20,75,50);// 调节透明度ctx.globalAlpha=0.2;ctx.fillStyle=\"blue\";ctx.fillRect(50,50,75,50);ctx.fillStyle=\"green\";ctx.fillRect(80,80,75,50); (2)globalCompositeOperation() globalCompositeOperation属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。 源图像 = 您打算放置到画布上的绘图。 目标图像 = 您已经放置在画布上的绘图。 javascript 语法 1context.globalCompositeOperation=\"source-in\"; 属性值 值 描述 source-over 默认。在目标图像上显示源图像。 source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over 在源图像上方显示目标图像。 destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter 显示源图像 + 目标图像。 copy 显示源图像。忽略目标图像。 xor 使用异或操作对源图像与目标图像进行组合。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; canvas&#123; border:1px solid #d3d3d3; margin-right:10px; margin-bottom:20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var gco=new Array(); gco.push(\"source-atop\"); gco.push(\"source-in\"); gco.push(\"source-out\"); gco.push(\"source-over\"); gco.push(\"destination-atop\"); gco.push(\"destination-in\"); gco.push(\"destination-out\"); gco.push(\"destination-over\"); gco.push(\"lighter\"); gco.push(\"copy\"); gco.push(\"xor\"); for (n=0;n&lt;gco.length;n++) &#123; document.write(\"&lt;div id='p_\" + n + \"' style='float:left;'&gt;\" + gco[n] + \":&lt;br&gt;\"); var c=document.createElement(\"canvas\"); c.width=120; c.height=100; document.getElementById(\"p_\" + n).appendChild(c); var ctx=c.getContext(\"2d\"); ctx.fillStyle=\"blue\"; ctx.fillRect(10,10,50,50); ctx.globalCompositeOperation=gco[n]; ctx.beginPath(); ctx.fillStyle=\"red\"; ctx.arc(50,50,30,0,2*Math.PI); ctx.fill(); document.write(\"&lt;/div&gt;\"); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.12 线条样式 2D 上下文中绘制操作中还具有相应的线条样式属性。 属性 描述 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 (1)lineWidth lineWidth 属性设置或返回当前线条的宽度，以像素计。 javascript语法 1context.lineWidth=number; 示例 12345//用宽度为 10 像素的线条来绘制矩形var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.lineWidth=10;ctx.strokeRect(20,20,80,100); (2)lineCap lineCap 属性设置或返回线条末端线帽的样式。 javascript 语法 1context.lineCap=\"butt|round|square\"; 属性值 值 描述 butt 默认。向线条的每个末端添加平直的边缘。 round 向线条的每个末端添加圆形线帽。 square 向线条的每个末端添加正方形线帽。 示例 12345678910111213141516171819202122//三种不同的线帽var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineWidth=10;ctx.lineCap=\"butt\";ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.stroke();ctx.beginPath();ctx.lineCap=\"round\";ctx.moveTo(20,40);ctx.lineTo(200,40);ctx.stroke();ctx.beginPath();ctx.lineCap=\"square\";ctx.moveTo(20,60);ctx.lineTo(200,60);ctx.stroke(); (2)lineJoin lineJoin 属性设置或返回所创建边角的类型，当两条线交汇时。 javascript语法 1context.lineJoin=\"bevel|round|miter\"; 属性值 值 描述 bevel 创建斜角。 round 创建圆角。 miter 默认。创建尖角 示例 1234567891011121314151617181920212223242526/**当两条线条交汇时，分别创建斜角、圆形、尖角边角**/var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineWidth=20;ctx.lineJoin=\"bevel\";ctx.moveTo(20,20);ctx.lineTo(100,50);ctx.lineTo(20,100);ctx.stroke();ctx.beginPath();ctx.lineWidth=20;ctx.lineJoin=\"round\";ctx.moveTo(100,20);ctx.lineTo(180,50);ctx.lineTo(100,100);ctx.stroke();ctx.beginPath();ctx.lineWidth=20;ctx.lineJoin=\"miter\";ctx.moveTo(180,20);ctx.lineTo(260,50);ctx.lineTo(180,100);ctx.stroke(); (4)miterLimit miterLimit 属性设置或返回最大斜接长度。 斜接长度指的是在两条线交汇处内角和外角之间的距离。 只有当 lineJoin 属性为 “miter” 时，miterLimit 才有效。 边角的角度越小，斜接长度就会越大。 为了避免斜接长度过长，我们可以使用 miterLimit 属性。 如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 “bevel” 类型来显示 javascript语法 1context.miterLimit=number; 示例 12345678910111213141516var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.lineWidth=10;ctx.lineJoin=\"miter\";ctx.beginPath();ctx.miterLimit=5;ctx.moveTo(20,20);ctx.lineTo(50,27);ctx.lineTo(20,34);ctx.stroke();ctx.beginPath();ctx.miterLimit=3;ctx.moveTo(80,20);ctx.lineTo(110,27);ctx.lineTo(80,34);ctx.stroke(); 2.13 其它 有两个方法可以跟踪上下文的状态变化。 如果你知道将来还要返回某组属性与变换的组合，可以调用save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。 然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。 连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可以一级一级返回。 123456789101112131415161718var c=document.getElementById(\"myCanvas\");var context=c.getContext(\"2d\");context.strokeStyle = \"red\";context.translate(10, 10);context.save();context.strokeStyle = \"blue\";context.translate(40, 40);context.save();context.strokeStyle = \"green\";context.strokeRect(0, 0, 20, 20); //绘制绿色矩形context.restore();context.strokeRect(40, 40, 20, 20); //绘制蓝色矩形context.restore();context.strokeRect(0, 0, 20, 20); //绘制红色矩形","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-富文本编辑","slug":"富文本编辑","date":"2017-12-19T17:45:28.000Z","updated":"2017-12-19T08:56:28.000Z","comments":true,"path":"2017/12/20/富文本编辑/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/20/富文本编辑/","excerpt":"","text":"富文本编辑 富文本编辑，又称为WYSIWYG（What You See Is What You Get，所见即所得） 1、使用contenteditable属性 一种编辑富文本内容的方式是使用名为contenteditable的特殊属性。可以把contenteditable 属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。 它不需要iframe、空白页和JavaScript，只要为元素设置contenteditable 属性即可。 1&lt;div class=\"editable\" id=\"richedit\" contenteditable&gt;&lt;/div&gt; contenteditable 属性有三个可能的值：”true”表示打开、”false”表示关闭，”inherit”表示从父元素那里继承。 12var div = document.getElementById(\"richedit\");div.contentEditable = \"true\"; 2、操作富文本 与富文本编辑器交互的主要方式，就是使用document.execCommand()。这个方法可以对文档执行预定义的命令，而且可以应用大多数格式。 可以为document.execCommand()方法传递3个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值（始终设置为false）和执行命令必须的一个值（如果不需要值，则传递null）。 可以在任何时候使用这些命令来修改富文本区域的外观。 123456789101112//转换粗体文本frames[\"richedit\"].document.execCommand(\"bold\", false, null);//转换斜体文本frames[\"richedit\"].document.execCommand(\"italic\", false, null);//创建指向www.wrox.com 的链接frames[\"richedit\"].document.execCommand(\"createlink\", false,\"http://www.wrox.com\");//格式化为1 级标题frames[\"richedit\"].document.execCommand(\"formatblock\", false, \"&lt;h1&gt;\"); 同样的方法也适用于页面中contenteditable属性为”true”的区块，只要把对框架的引用替换成当前窗口的document 对象即可。 123456789//转换粗体文本document.execCommand(\"bold\", false, null);//转换斜体文本document.execCommand(\"italic\", false, null);//创建指向www.wrox.com 的链接document.execCommand(\"createlink\", false,\"http://www.wrox.com\");//格式化为1 级标题document.execCommand(\"formatblock\", false, \"&lt;h1&gt;\"); 除了命令之外，还有一些与命令相关的方法。 (1)queryCommandEnabled() queryCommandEnabled()，可以用它来检测是否可以针对当前选择的文本，或者当前插入字符所在位置执行某个命令。 这个方法接收一个参数，即要检测的命令。如果当前编辑区域允许执行传入的命令，这个方法返回true，否则返回false。 1var result = frames[\"richedit\"].document.queryCommandEnabled(\"bold\"); (2)queryCommandState() queryCommandState()方法用于确定是否已将指定命令应用到了选择的文本。 1var isBold = frames[\"richedit\"].document.queryCommandState(\"bold\"); (3)queryCommandValue() queryCommandValue()，用于取得执行命令时传入的值 1var fontSize = frames[\"richedit\"].document.queryCommandValue(\"fontsize\"); 3、富文本选区 在富文本编辑器中，使用框架（iframe）的getSelection()方法，可以确定实际选择的文本。 这个方法是window 对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection对象Selection 对象属性 12345678910/**为富文本编辑器中被选择的文本添加黄色的背景**/var selection = frames[\"richedit\"].getSelection();//取得选择的文本var selectedText = selection.toString();//取得代表选区的范围var range = selection.getRangeAt(0);//突出显示选择的文本var span = frames[\"richedit\"].document.createElement(\"span\");span.style.backgroundColor = \"yellow\";range.surroundContents(span); 4、表单与富文本 富文本编辑器中的HTML 不会被自动提交给服务器，而需要我们手工来提取并提交HTML。 为此，通常可以添加一个隐藏的表单字段，让它的值等于从iframe 中提取出的HTML。 具体来说，就是在提交表单之前，从iframe中提取出HTML，并将其插入到隐藏的字段中。 123456EventUtil.addHandler(form, \"submit\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements[\"comments\"].value = frames[\"richedit\"].document.body.innerHTML;&#125;); 对于contenteditable元素，也可以执行类似操作。 123456EventUtil.addHandler(form, \"submit\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements[\"comments\"].value = document.getElementById(\"richedit\").innerHTML;&#125;);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-表单序列化","slug":"表单序列化","date":"2017-12-19T17:45:28.000Z","updated":"2017-12-19T08:07:52.000Z","comments":true,"path":"2017/12/20/表单序列化/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/20/表单序列化/","excerpt":"","text":"表单序列化 在JavaScript 中，可以利用表单字段的type属性，连同name和value属性一起实现对表单的序列化。 在表单提交期间，浏览器是怎样将数据发送给服务器的？* 对表单字段的名称和值进行URL 编码，使用和号（&amp;）分隔。 不发送禁用的表单字段。 只发送勾选的复选框和单选按钮。 不发送type 为”reset”和”button”的按钮。 多选选择框中的每个选中的值单独一个条目。 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括type为”image”的&lt;input&gt;元素。 &lt;select&gt;元素的值，就是选中的&lt;option&gt;元素的value特性的值。如果&lt;option&gt;元素没有value 特性，则是&lt;option&gt;元素的文本值。 在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**以查询字符串的格式输出序列化之后的字符串**/function serialize(form)&#123; var parts = [],field = null,i,len,j,optLen,option,optValue; for (i=0, len=form.elements.length; i &lt; len; i++)&#123; field = form.elements[i]; switch(field.type)&#123; case \"select-one\": case \"select-multiple\": if (field.name.length)&#123; for (j=0, optLen = field.options.length; j &lt; optLen; j++)&#123; option = field.options[j]; if (option.selected)&#123; optValue = \"\"; if (option.hasAttribute)&#123; optValue = (option.hasAttribute(\"value\") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[\"value\"].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + \"=\" + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case \"file\": //文件输入 case \"submit\": //提交按钮 case \"reset\": //重置按钮 case \"button\": //自定义按钮 break; case \"radio\": //单选按钮 case \"checkbox\": //复选框 if (!field.checked)&#123; break; &#125; /* 执行默认操作 */ default: //不包含没有名字的表单字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + \"=\" + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(\"&amp;\");&#125;","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-文本框脚本和选择框脚本","slug":"文本框脚本和选择框脚本","date":"2017-12-19T17:44:28.000Z","updated":"2017-12-19T07:35:38.000Z","comments":true,"path":"2017/12/20/文本框脚本和选择框脚本/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/20/文本框脚本和选择框脚本/","excerpt":"","text":"文本框脚本 在HTML 中，有两种方式来表现文本框：一种是使用&lt;input&gt;元素的单行文本框，另一种是使用&lt;textarea&gt;的多行文本框。 12&lt;input type=\"text\" size=\"25\" maxlength=\"50\" value=\"initial value\"&gt;&lt;textarea rows=\"25\" cols=\"5\"&gt;initial value&lt;/textarea&gt; 将用户输入的内容保存在value 属性中。可以通过这个属性读取和设置文本框的值。 123var textbox = document.forms[0].elements[\"textbox1\"];alert(textbox.value);textbox.value = \"Some new value\"; 1234567891011121314151617181920212223242526272829303132333435363738394041//事件处理程序，方便后面使用var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, getCharCode: function(event)&#123; if (typeof event.charCode == \"number\")&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, preventDefault: function(event)&#123; if (event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125; removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125;; 1、选择文本 select()方法，这个方法用于选择文本框中的所有文本。这个方法不接受参数，可以在任何时候被调用。 12var textbox = document.forms[0].elements[\"textbox1\"];textbox.select(); 123456//在文本框获得焦点时选择其所有文本EventUtil.addHandler(textbox, \"focus\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.select();&#125;); (1)选择select事件 在选择了文本框中的文本时，就会触发select事件。 1234var textbox = document.forms[0].elements[\"textbox1\"];EventUtil.addHandler(textbox, \"select\", function(event)&#123; var alert(\"Text selected\" + textbox.value);&#125;); (2)取得选择的文本 HTML5规范中添加了两个属性：selectionStart和selectionEnd。这两个属性中保存的是基于0 的数值，表示所选择文本的范围（即文本选区开头和结尾的偏移量）。 123456789101112131415//取得用户在文本框中选择的文本function getSelectedText(textbox)&#123; return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);&#125;//兼容IE8function getSelectedText(textbox)&#123; if (typeof textbox.selectionStart == \"number\")&#123; return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd); &#125; else if (document.selection)&#123; return document.selection.createRange().text; &#125;&#125; (3)选择部分文本 所有文本框都有一个setSelectionRange()方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引。 12345678910textbox.value = \"Hello world!\"//选择所有文本textbox.setSelectionRange(0, textbox.value.length); //\"Hello world!\"//选择前3 个字符textbox.setSelectionRange(0, 3); //\"Hel\"//选择第4 到第6 个字符textbox.setSelectionRange(4, 7); //\"o w\" 123456789101112131415161718192021222324//实现跨浏览器编程，兼容IEfunction selectText(textbox, startIndex, stopIndex)&#123; if (textbox.setSelectionRange)&#123; textbox.setSelectionRange(startIndex, stopIndex); &#125; else if (textbox.createTextRange)&#123; var range = textbox.createTextRange(); range.collapse(true); range.moveStart(\"character\", startIndex); range.moveEnd(\"character\", stopIndex - startIndex); range.select(); &#125; textbox.focus();&#125;textbox.value = \"Hello world!\"//选择所有文本selectText(textbox, 0, textbox.value.length); //\"Hello world!\"//选择前3 个字符selectText(textbox, 0, 3); //\"Hel\"//选择第4 到第6 个字符selectText(textbox, 4, 7); //\"o w\" 2、过滤输入 综合运用事件和DOM 手段，就可以将普通的文本框转换成能够理解用户输入数据的功能型控件。 (1)屏蔽字符 有时候，我们需要用户输入的文本中包含或不包含某些字符。 1234567891011//只允许用户输入数值,并确保用户没有按下Ctrl键EventUtil.addHandler(textbox, \"keypress\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\\d/.test(String.fromCharCode(charCode) &amp;&amp; charCode &gt; 9 &amp;&amp;!event.ctrlKey))&#123; EventUtil.preventDefault(event); &#125;&#125;); (2)操作剪切板 HTML5 规范中，共6 个剪贴板事件。 事件名 含义 beforecopy 在发生复制操作前触发 copy 在发生复制操作时触发 beforecut 在发生剪切操作时触发 cut 在发生剪切操作时触发 beforepaste 在发生粘贴操作前触发 paste 在发生粘贴时触发 要访问剪贴板中的数据，可以使用clipboardData 对象：在IE 中，这个对象是window 对象的属性；而在Firefox 4+、Safari 和Chrome 中，这个对象是相应event 对象的属性。 为了确保跨浏览器兼容性，最好只在发生剪贴板事件期间使用这个对象。 这个clipboardData 对象有三个方法：getData()、setData()和clearData()。其中，getData()用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。 在IE 中，有两种数据格式：”text”和”URL”。在Firefox、Safari和Chrome中，这个参数是一种MIME 类型；不过，可以用”text”代表”text/plain”。 12345678910111213141516var EventUtil = &#123; //省略的代码 getClipboardText: function(event)&#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData(\"text\"); &#125;, //省略的代码 setClipboardText: function(event, value)&#123; if (event.clipboardData)&#123; return event.clipboardData.setData(\"text/plain\", value); &#125; else if (window.clipboardData)&#123; return window.clipboardData.setData(\"text\", value); &#125; &#125;, //省略的代码&#125;; 在需要确保粘贴到文本框中的文本中包含某些字符，或者符合某种格式要求时，能够访问剪贴板是非常有用的。 1234567EventUtil.addHandler(textbox, \"paste\", function(event)&#123; event = EventUtil.getEvent(event); var text = EventUtil.getClipboardText(event); if (!/^\\d*$/.test(text))&#123; EventUtil.preventDefault(event); &#125;&#125;); 3、自动切换焦点 使用JavaScript 可以从多个方面增强表单字段的易用性。其中，最常见的一种方式就是在用户填写完当前字段时，自动将焦点切换到下一个字段。 123&lt;input type=\"text\" name=\"tel1\" id=\"txtTel1\" maxlength=\"3\"&gt;&lt;input type=\"text\" name=\"tel2\" id=\"txtTel2\" maxlength=\"3\"&gt;&lt;input type=\"text\" name=\"tel3\" id=\"txtTel3\" maxlength=\"4\"&gt; 为增强易用性，同时加快数据输入，可以在前一个文本框中的字符达到最大数量后，自动将焦点切换到下一个文本框。 1234567891011121314151617181920212223(function()&#123; function tabForward(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength)&#123; var form = target.form; for (var i=0, len=form.elements.length; i &lt; len; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125; var textbox1 = document.getElementById(\"txtTel1\"); var textbox2 = document.getElementById(\"txtTel2\"); var textbox3 = document.getElementById(\"txtTel3\"); EventUtil.addHandler(textbox1, \"keyup\", tabForward); EventUtil.addHandler(textbox2, \"keyup\", tabForward); EventUtil.addHandler(textbox3, \"keyup\", tabForward);&#125;)(); 4、HTML5 约束验证API 为了在将表单提交到服务器之前验证数据，HTML5 新增了一些功能。，即便JavaScript被禁用或者由于种种原因未能加载，也可以确保基本的验证。 (1)必填字段 任何标注有required 的字段，在提交表单时都不能空着。这个属性适用于&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;字段 1&lt;input type=\"text\" name=\"username\" required&gt; 在JavaScript 中，通过对应的required 属性，可以检查某个表单字段是否为必填字段。 12345//测试浏览器是否支持required 属性。var isRequiredSupported = \"required\" in document.createElement(\"input\");//检查字段是否为必填字段var isUsernameRequired = document.forms[0].elements[\"username\"].required; (2)其它输入类型 HTML5 为&lt;input&gt;元素的type属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，而且还能提供一些默认的验证功能 12&lt;input type=\"email\" name =\"email\"&gt;&lt;input type=\"url\" name=\"homepage\"&gt; (3)数值范围 HTML5定义的一些输入元素要求填写某种基于数字的值：”number”、”range”、”datetime”“datetime-local”、”date”、”month”、”week”，还有”time”。 对所有这些数值类型的输入元素，可以指定min属性（最小的可能值）、max属性（最大的可能值）和step 属性。 1&lt;input type=\"number\" min=\"0\" max=\"100\" step=\"5\" name=\"count\"&gt; (4)输入模式 HTML5 为文本字段新增了pattern属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。 1&lt;input type=\"text\" pattern=\"\\d+\" name=\"count\"&gt; 12345//访问模式var pattern = document.forms[0].elements[\"count\"].pattern;//检测浏览器是否支持pattern 属性。var isPatternSupported = \"pattern\" in document.createElement(\"input\"); (5)检测有效性 使用checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如果字段的值有效，这个方法返回true，否则返回false。 12345if (document.forms[0].elements[0].checkValidity())&#123; //字段有效，继续&#125; else &#123; //字段无效&#125; 要检测整个表单是否有效，可以在表单自身调用checkValidity()方法。如果所有表单字段都有效，这个方法返回true；即使有一个字段无效，这个方法也会返回false。 12345if(document.forms[0].checkValidity())&#123; //表单有效，继续&#125; else &#123; //表单无效&#125; validity 属性则会告诉你为什么字段有效或无效。这个对象中包含一系列属性，每个属性会返回一个布尔值。 属性名 含义 customRrror 如果设置了setCustomValidity()，则返回true，否则返回false patternMismatch 如果值与指定的pattern 属性不匹配，返回true rangeOverflow 如果值比max 值大，返回true rangeUnderflow 如果值比min 值小，返回true stepMisMatch 如果min 和max 之间的步长值不合理，返回true tooLong 如果值的长度超过了maxlength 属性指定的长度，返回true typeMismatch 如果值不是”mail”或”url”要求的格式，返回true valid 如果这里的其他属性都是false，返回true valueMissing 如果标注为required 的字段中没有值，返回true 123456789if (input.validity &amp;&amp; !input.validity.valid)&#123; if (input.validity.valueMissing)&#123; alert(\"Please specify a value.\") &#125; else if (input.validity.typeMismatch)&#123; alert(\"Please enter an email address.\"); &#125; else &#123; alert(\"Value is invalid.\"); &#125;&#125; (6)禁用验证 通过设置novalidate 属性，可以告诉表单不进行验证。 123&lt;form method=\"post\" action=\"signup.php\" novalidate&gt; &lt;!--这里插入表单元素--&gt;&lt;/form&gt; 在JavaScript 中使用noValidate属性可以取得或设置这个值，如果这个属性存在，值为true，如果不存在，值为false。 1document.forms[0].noValidate = true; //禁用验证 如果一个表单中有多个提交按钮，为了指定点击某个提交按钮不必验证表单，可以在相应的按钮上添加formnovalidate 属性。 123456&lt;form method=\"post\" action=\"foo.php\"&gt; &lt;!--这里插入表单元素--&gt; &lt;input type=\"submit\" value=\"Regular Submit\"&gt; &lt;input type=\"submit\" formnovalidate name=\"btnNoValidate\" value=\"Non-validating Submit\"&gt;&lt;/form&gt; 12//禁用验证document.forms[0].elements[\"btnNoValidate\"].formNoValidate = true; 选择框脚本 选择框是通过&lt;select&gt;和&lt;option&gt;元素创建的，除了所有表单字段共有的属性和方法外，HTMLSelectElement 类型还提供了下列属性和方法。 属性/方法 含义 add(newOption, relOption) 向控件中插入新元素，其位置在相关项（relOption）之前 multiple 布尔值，表示是否允许多项选择 options 控件中所有元素的HTMLCollection remove(index) 移除给定位置的选项 selectedIndex 基于0 的选中项的索引，如果没有选中项，则值为-1 size 选择框中可见的行数 value 未选中，为空 &nbsp; 选中一项，html定义value属性，则为value的值 &nbsp; 选择一项，html未定义value属性，则为该项的文本 &nbsp; 有多个选中项，将依据前两条规则取得第一个选中项的值 在DOM 中，每个&lt;option&gt;元素都有一个HTMLOptionElement对象表示。为便于访问数据，HTMLOptionElement 对象添加了下列属性。 属性名 含义 index 当前选项在options 集合中的索引。 label 当前选项的标签 selected 布尔值，表示当前选项是否被选中 text 选项的文本 value 选项的值 123456789var selectbox = document.forms[0].elements[\"location\"];//不推荐，效率低var text = selectbox.options[0].firstChild.nodeValue; //选项的文本var value = selectbox.options[0].getAttribute(\"value\"); //选项的值//推荐var text = selectbox.options[0].text; //选项的文本var value = selectbox.options[0].value; //选项的值 1、选择选项 对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的selectedIndex 属性。 1var selectedOption = selectbox.options[selectbox.selectedIndex]; 另一种选择选项的方式，就是取得对某一项的引用，然后将其selected属性设置为true。 1selectbox.options[0].selected = true; selected 属性的作用主要是确定用户选择了选择框中的哪一项。要取得所有选中的项，可以循环遍历选项集合，然后测试每个选项的selected 属性。 1234567891011function getSelectedOptions(selectbox)&#123; var result = new Array(); var option = null; for (var i=0, len=selectbox.options.length; i &lt; len; i++)&#123; option = selectbox.options[i]; if (option.selected)&#123; result.push(option); &#125; &#125; return result;&#125; 2、添加选项 可以使用JavaScript 动态创建选项，并将它们添加到选择框中。 12345678910111213//第一种，使用DOM 方法var newOption = document.createElement(\"option\");newOption.appendChild(document.createTextNode(\"Option text\"));newOption.setAttribute(\"value\", \"Option value\");selectbox.appendChild(newOption);//第二种，使用Option 构造函数来创建新选项var newOption = new Option(\"Option text\", \"Option value\");selectbox.appendChild(newOption); //在IE8 及之前版本中有问题//第三种，使用选择框的add()方法，在列表的最后添加一个选项var newOption = new Option(\"Option text\", \"Option value\");selectbox.add(newOption, undefined); //最佳方案 3、移除选项 与添加选项类似，移除选项的方式也有很多种。 12345678//第一种，使用DOM 的removeChild()方法selectbox.removeChild(selectbox.options[0]); //移除第一个选项//第二种，使用选择框的remove()方法selectbox.remove(0); //移除第一个选项//将相应选项设置为nullselectbox.options[0] = null; //移除第一个选项 要清除选择框中所有的项，需要迭代所有选项并逐个移除它们。 12345function clearSelectbox(selectbox)&#123; for(var i=0, len=selectbox.options.length; i &lt; len; i++)&#123; selectbox.remove(i); &#125;&#125; 4、移动和重排选项 使用DOM 的appendChild()方法，可以将第一个选择框中的选项直接移动到第二个选择框中。 1234//selLocations1中减少一项，成为selLocations2的最后一项var selectbox1 = document.getElementById(\"selLocations1\");var selectbox2 = document.getElementById(\"selLocations2\");selectbox2.appendChild(selectbox1.options[0]); 要将选择框中的某一项移动到特定位置，最合适的DOM 方法就是insertBefore() 123//在选择框中向前移动一个选项的位置var optionToMove = selectbox.options[1];selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index-1]);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-表单的基础知识","slug":"表单脚本","date":"2017-12-18T17:44:28.000Z","updated":"2017-12-18T06:15:20.000Z","comments":true,"path":"2017/12/19/表单脚本/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/19/表单脚本/","excerpt":"","text":"表单的基础知识 在HTML 中，表单是由元素来表示的，而在JavaScript中，表单对应的则是HTMLForm-Element 类型。 HTMLFormElement 继承了HTMLElement，因而与其他HTML元素具有相同的默认属性。不过，HTMLFormElement 也有它自己下列独有的属性和方法。属性/方法|含义-|-acceptCharset|服务器能处理的字符集action|接受请求的URLelements|表单所有控件的集合enctype|请求的编码类型length|表单中控件的数量method|要发送的HTTP请求类型name|表单的名称reset()|将所有表单域重置为默认值submit()|提交表单target|用于发送请求或接收响应的窗口名称 1234567//取得&lt;form&gt;元素引用var form = document.getElementById(\"form1\");/**通过document.forms 可以取得页面中所有的表单,在这个集合中，可以通过数值索引或name 值来取得特定的表单**/var firstForm = document.forms[0]; //取得页面中的第一个表单var myForm = document.forms[\"form2\"]; //取得页面中名称为\"form2\"的表单 1、提交表单 用户单击提交按钮或图像按钮时，就会提交表单。使用或都可以定义提交按钮，只要将其type 特性的值设置为”submit”即可，而图像按钮则是通过将的type 特性值设置为”image”来定义的。 123456&lt;!-- 通用提交按钮 --&gt;&lt;input type=\"submit\" value=\"Submit Form\"&gt;&lt;!-- 自定义提交按钮 --&gt;&lt;button type=\"submit\"&gt;Submit Form&lt;/button&gt;&lt;!-- 图像按钮 --&gt;&lt;input type=\"image\" src=\"graphic.gif\"&gt; 以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发submit事件。这样，我们就有机会验证表单数据，并据以决定是否允许表单提交。阻止这个事件的默认行为就可以取消表单提交。 123456789101112131415161718192021222324252627//事件处理程序，方便后面使用var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125;; 1234567var form = document.getElementById(\"myForm\");EventUtil.addHandler(form, \"submit\", function(event)&#123;//取得事件对象event = EventUtil.getEvent(event);//阻止默认事件EventUtil.preventDefault(event);&#125;); 在JavaScript 中，以编程方式调用submit()方法也可以提交表单。而且，这种方式无需表单包含提交按钮，任何时候都可以正常提交表单。 123var form = document.getElementById(\"myForm\");//提交表单form.submit(); 提交表单时可能出现的最大问题，就是重复提交表单。解决这一问题的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用onsubmit事件处理程序取消后续的表单提交操作。 123456789/**提交表单后就禁用提交按钮**/EventUtil.addHandler(form, \"submit\", function(event)&#123;event = EventUtil.getEvent(event);var target = EventUtil.getTarget(event);//取得提交按钮var btn = target.elements[\"submit-btn\"];//禁用它btn.disabled = true;&#125;); 123456789101112131415161718192021222324&lt;!--利用onsubmit事件处理程序取消后续的表单提交操作--&gt;&lt;form name=\"form1\" method=\"post\" action=\"#\" onsubmit=\"return checksubmit()\"&gt; &lt;label&gt; &lt;input name=\"myname\" type=\"text\" id=\"id\"&gt; &lt;/label&gt; &lt;p&gt; &lt;label&gt; &lt;input type=\"submit\" name=\"Submit\" value=\"提交\"&gt; &lt;/label&gt; &lt;/p&gt;&lt;/form&gt;&lt;script language=\"javascript\"&gt;function checksubmit()&#123; if (document.form1.myname.value==\"\") &#123; alert(\"请输入开始数值！\"); document.form1.myname.focus(); return false; &#125; return true; &#125;&lt;/script&gt; 2、重置表单 在用户单击重置按钮时，表单会被重置。使用type特性值为”reset”的或都可以创建重置按钮。 1234&lt;!-- 通用重置按钮 --&gt;&lt;input type=\"reset\" value=\"Reset Form\"&gt;&lt;!-- 自定义重置按钮 --&gt;&lt;button type=\"reset\"&gt;Reset Form&lt;/button&gt; 用户单击重置按钮重置表单时，会触发reset事件。利用这个机会，我们可以在必要时取消重置操作。 1234567var form = document.getElementById(\"myForm\");EventUtil.addHandler(form, \"reset\", function(event)&#123; //取得事件对象 event = EventUtil.getEvent(event); //阻止表单重置 EventUtil.preventDefault(event);&#125;); 可以通过JavaScript 来重置表单。 123var form = document.getElementById(\"myForm\");//重置表单form.reset(); 3、表单字段 每个表单都有一个elements属性，该属性是表单中所有表单元素的集合。这个elements集合是一个有序列表，其中包含着表单中的所有字段。 12345678910var form = document.getElementById(\"form1\");//取得表单中的第一个字段var field1 = form.elements[0];//取得名为\"textbox1\"的字段var field2 = form.elements[\"textbox1\"];//取得表单中包含的字段的数量var fieldCount = form.elements.length; 1234567&lt;form method=\"post\" id=\"myForm\"&gt; &lt;ul&gt; &lt;li&gt;&lt;input type=\"radio\" name=\"color\" value=\"red\"&gt;Red&lt;/li&gt; &lt;li&gt;&lt;input type=\"radio\" name=\"color\" value=\"green\"&gt;Green&lt;/li&gt; &lt;li&gt;&lt;input type=\"radio\" name=\"color\" value=\"blue\"&gt;Blue&lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; 123456var form = document.getElementById(\"myForm\");var colorFields = form.elements[\"color\"];alert(colorFields.length); //3var firstColorField = colorFields[0];var firstFormField = form.elements[0];alert(firstColorField === firstFormField); //true (1)共有的表单字段属性 除了元素之外，所有表单字段都拥有相同的一组属性。 属性名 含义 disabled 布尔值，表示当前字段是否被禁用 form 指向当前字段所属表单的指针；只读 name 当前字段的名称 readOnly 布尔值，表示当前字段是否只读 tabIndex 表示当前字段的切换序号 type 当前字段的类型 value 当前字段将被提交给服务器的值 除了form 属性之外，可以通过JavaScript 动态修改其他任何属性。 1234567891011121314var form = document.getElementById(\"myForm\");var field = form.elements[0];//修改value 属性field.value = \"Another value\";//检查form 属性的值alert(field.form === form); //true//把焦点设置到当前字段field.focus();//禁用当前字段field.disabled = true; (2)共有的表单字段方法 每个表单字段都有两个方法：focus()和 blur()。 focus()方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件。 123EventUtil.addHandler(window, \"load\", function(event)&#123; document.forms[0].elements[0].focus();&#125;); HTML5 为表单字段新增了一个autofocus属性。在支持这个属性的浏览器中，只要设置这个属性，不用JavaScript 就能自动把焦点移动到相应字段。 1&lt;input type=\"text\" autofocus&gt; 1234567EventUtil.addHandler(window,\"load\",function(event)&#123; var element = document.forms[0].elements[0]; if(element.autofocus !== true)&#123; element.focus(); console.log(\"JS focus\"); &#125;&#125;) blur()方法，它的作用是从元素中移走焦点。1document.forms[0].elements[0].blur(); (3)共有的表单字段事件 除了支持鼠标、键盘、更改和HTML 事件之外，所有表单字段都支持下列3 个事件。 事件名 含义 blur 当前字段失去焦点时触发 change 对于input和textarea元素，在它们失去焦点并且value值改变时触发；对于select元素，在其选项改变时触发。 focus 当前字段获得焦点时触发 通常，可以使用focus和blur事件来以某种方式改变用户界面，要么是向用户给出视觉提示，要么是向界面中添加额外的功能。而change事件则经常用于验证用户在字段中输入的数据。 1234567891011121314151617181920212223242526272829303132var textbox = document.forms[0].elements[0];/**将文本框的背景颜色修改为黄色，以清楚地表明当前字段已经激活。**/EventUtil.addHandler(textbox, \"focus\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.style.backgroundColor != \"red\")&#123; target.style.backgroundColor = \"yellow\"; &#125;&#125;);/**在发现非数值字符时，将文本框背景颜色修改为红色。**/EventUtil.addHandler(textbox, \"blur\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (/[^\\d]/.test(target.value))&#123; target.style.backgroundColor = \"red\"; &#125; else &#123; target.style.backgroundColor = \"\"; &#125;&#125;);/**在发现非数值字符时，将文本框背景颜色修改为红色。**/EventUtil.addHandler(textbox, \"change\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (/[^\\d]/.test(target.value))&#123; target.style.backgroundColor = \"red\"; &#125; else &#123; target.style.backgroundColor = \"\"; &#125;&#125;);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript事件-内存性能&模拟事件","slug":"javascript事件-内存性能&模拟事件","date":"2017-12-15T17:44:28.000Z","updated":"2017-12-15T09:13:44.000Z","comments":true,"path":"2017/12/16/javascript事件-内存性能&模拟事件/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/16/javascript事件-内存性能&模拟事件/","excerpt":"","text":"内存和性能 在JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。 导致这一问题的原因是多方面的。 每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。 必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。 123456789101112131415161718192021222324252627//事件处理程序，方便后面使用var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125;; 1、事件委托 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 12345&lt;ul id=\"myLinks\"&gt; &lt;li id=\"goSomewhere\"&gt;Go somewhere&lt;/li&gt; &lt;li id=\"doSomething\"&gt;Do something&lt;/li&gt; &lt;li id=\"sayHi\"&gt;Say hi&lt;/li&gt;&lt;/ul&gt; 12345678910111213//传统的做法var item1 = document.getElementById(\"goSomewhere\");var item2 = document.getElementById(\"doSomething\");var item3 = document.getElementById(\"sayHi\");EventUtil.addHandler(item1, \"click\", function(event)&#123; location.href = \"http://www.wrox.com\";&#125;);EventUtil.addHandler(item2, \"click\", function(event)&#123; document.title = \"I changed the document's title\";&#125;);EventUtil.addHandler(item3, \"click\", function(event)&#123; alert(\"hi\");&#125;); 1234567891011121314151617//使用事件委托var list = document.getElementById(\"myLinks\");EventUtil.addHandler(list, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case \"doSomething\": document.title = \"I changed the document's title\"; break; case \"goSomewhere\": location.href = \"http://www.wrox.com\"; break; case \"sayHi\": alert(\"hi\"); break; &#125;&#125;); 这样使用事件委托与采取传统的做法相比具有如下优点。 document 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMContentLoaded或load事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM 引用更少，所花的时间也更少。 整个页面占用的内存空间更少，能够提升整体性能。 最适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress。 2、移除事件处理程序 每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript 代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。 在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。 在两种情况下，可能会造成导致“空事件处理程序”。 从文档中移除带有事件处理程序的元素时。更多地是发生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。 12345678910&lt;div id=\"myDiv\"&gt; &lt;input type=\"button\" value=\"Click Me\" id=\"myBtn\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var btn = document.getElementById(\"myBtn\"); btn.onclick = function()&#123; //先执行某些操作 document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; //麻烦了！&#125;;&lt;/script&gt; 123456789101112&lt;!--- 如果你知道某个元素即将被移除，那么最好手工移除事件处理程序。--&gt;&lt;div id=\"myDiv\"&gt; &lt;input type=\"button\" value=\"Click Me\" id=\"myBtn\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var btn = document.getElementById(\"myBtn\"); btn.onclick = function()&#123; //先执行某些操作 btn.onclick = null; //移除事件处理程序 document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; &#125;;&lt;/script&gt; 另一种情况，就是卸载页面的时候。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。可以在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序， 注意，使用onunload 事件处理程序意味着页面不会被缓存在bfcache 中。 模拟事件 可以使用JavaScript 在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。 1、DOM中的事件模拟 可以在document 对象上使用createEvent()方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。 事件名称 解释 UIEvents 一般化的UI 事件。鼠标事件和键盘事件都继承自UI 事件 MouseEvents 一般化的鼠标事件 MutationEvents 一般化的DOM 变动事件 HTMLEvents 一般化的HTML 事件 在创建了event 对象之后，还需要使用与事件有关的信息对其进行初始化。 每种类型的event 对象都有一个特殊的方法，为它传入适当的数据就可以初始化该event 对象。不同类型的这个方法的名字也不相同，具体要取决于createEvent()中使用的参数。 模拟事件的最后一步就是触发事件，使用dispatchEvent()方法，需要传入一个参数，即表示要触发事件的event 对象。 (1)模拟鼠标事件 创建新的鼠标事件对象并为其指定必要的信息，就可以模拟鼠标事件。 创建鼠标事件对象的方法是为createEvent()传入字符串”MouseEvents”。返回的对象有一个名为initMouseEvent()方法，用于指定与该鼠标事件有关的信息。 这个方法接收15 个参数，分别与鼠标事件中每个典型的属性一一对应。 参数 含义 type（字符串） 表示要触发的事件类型，例如”click”。 bubbles（布尔值） 表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为true。 cancelable（布尔值） 表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设置为true。 view（AbstractView） 与事件关联的视图。这个参数几乎总是要设置为document.defaultView。 detail（整数） 与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为0。 screenX（整数） 事件相对于屏幕的X 坐标。 screenY（整数） 事件相对于屏幕的Y 坐标。 clientX（整数） 事件相对于视口的X 坐标。 clientY（整数） 事件想对于视口的Y 坐标。 ctrlKey（布尔值） 表示是否按下了Ctrl 键。默认值为false。 altKey（布尔值） 表示是否按下了Alt 键。默认值为false。 shiftKey（布尔值） 表示是否按下了Shift 键。默认值为false。 metaKey（布尔值） 表示是否按下了Meta 键。默认值为false。 button（整数） 表示按下了哪一个鼠标键。默认值为0。 relatedTarget（对象） 表示与事件相关的对象。这个参数只在模拟mouseover或mouseout时使用。 12345678var btn = document.getElementById(\"myBtn\");//创建事件对象var event = document.createEvent(\"MouseEvents\");//初始化事件对象event.initMouseEvent(\"click\", true, true, document.defaultView, 0, 0, 0, 0, 0,false, false, false, false, 0, null);//触发事件btn.dispatchEvent(event); (2)模拟键盘事件 调用createEvent()并传入”KeyboardEvent”就可以创建一个键盘事件。返回的事件对象会包含一个initKeyEvent()方法，这个方法接收下列参数。 参数 含义 type（字符串） 表示要触发的事件类型，如”keydown”。 bubbles（布尔值） 表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。 cancelable（布尔值） 表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。 view 与事件关联的视图。这个参数几乎总是要设置为document.defaultView。 key（布尔值） 表示按下的键的键码。 location（整数） 表示按下了哪里的键。0 表示默认的主键盘，1 表示左，2 表示右，3 表示数字键盘，4 表示移动设备（即虚拟键盘），5 表示手柄。 modifiers（字符串） 空格分隔的修改键列表，如”Shift”。 repeat（整数） 在一行中按了这个键多少次。 123456789101112/**模拟按住Shift 的同时又按下A 键。**/var textbox = document.getElementById(\"myTextbox\"),event;//以DOM3 级方式创建事件对象if (document.implementation.hasFeature(\"KeyboardEvents\", \"3.0\"))&#123; event = document.createEvent(\"KeyboardEvent\"); //初始化事件对象 event.initKeyboardEvent(\"keydown\", true, true, document.defaultView, \"a\",0, \"Shift\", 0);&#125;//触发事件textbox.dispatchEvent(event); (3)模拟其它事件 要模拟变动事件， 可以使用createEvent(“MutationEvents”)创建一个包含initMutationEvent() 方法的变动事件对象。 这个方法接受的参数包括：type、bubbles、cancelable、relatedNode、preValue、newValue、attrName 和attrChange。 123var event = document.createEvent(\"MutationEvents\");event.initMutationEvent(\"DOMNodeInserted\", true, false, someNode, \"\",\"\",\"\",0);targ et.dispatchEvent(event); 模拟HTML 事件，同样需要先创建一个event对象——通过createEvent(“HTMLEvents”)，然后再使用这个对象的initEvent()方法来初始化它。 123var event = document.createEvent(\"HTMLEvents\");event.initEvent(\"focus\", true, false);targ et.dispatchEvent(event); (4)自定义DOM事件 创建新的自定义事件，可以调用createEvent(“CustomEvent”)。返回的对象有一个名为initCustomEvent()的方法，接收如下4 个参数。 参数 含义 type（字符串） 触发的事件类型，例如”keydown”。 bubbles（布尔值） 表示事件是否应该冒泡。 cancelable（布尔值） 表示事件是否可以取消。 detail（对象） 任意值，保存在event 对象的detail 属性中。 12345678910111213var div = document.getElementById(\"myDiv\"),event;EventUtil.addHandler(div, \"myevent\", function(event)&#123; alert(\"DIV: \" + event.detail);&#125;);EventUtil.addHandler(document, \"myevent\", function(event)&#123; alert(\"DOCUMENT: \" + event.detail);&#125;);if (document.implementation.hasFeature(\"CustomEvents\", \"3.0\"))&#123; event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(\"myevent\", true, false, \"Hello world!\"); div.dispatchEvent(event);&#125; 支持自定义DOM事件的浏览器有IE9+和Firefox 6+。 2、IE中的事件模拟 调用document.createEventObject()方法可以在IE中创建event对象，这个方法不接受参数，结果会返回一个通用的event 对象。 然后，你必须手工为这个对象添加所有必要的信息。 最后一步就是在目标上调用fireEvent()方法，这个方法接受两个参数：事件处理程序的名称和event 对象。 1234567891011121314151617var btn = document.getElementById(\"myBtn\");//创建事件对象var event = document.createEventObject();//初始化事件对象event.screenX = 100;event.screenY = 0;event.clientX = 0;event.clientY = 0;event.ctrlKey = false;event.altKey = false;event.shiftKey = false;event.button = 0;//触发事件btn.fireEvent(\"onclick\", event); 1234567891011121314/**采用相同的模式也可以模拟触发keypress 事件**/var textbox = document.getElementById(\"myTextbox\");//创建事件对象var event = document.createEventObject();//初始化事件对象event.altKey = false;event.ctrlKey = false;event.shiftKey = false;event.keyCode = 65;//触发事件textbox.fireEvent(\"onkeypress\", event);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-事件类型","slug":"javascript 事件类型","date":"2017-12-14T17:33:28.000Z","updated":"2017-12-14T09:27:26.000Z","comments":true,"path":"2017/12/15/javascript 事件类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/15/javascript 事件类型/","excerpt":"","text":"事件类型 Web 浏览器中可能发生的事件有很多类型 UI事件:当用户与界面上的元素交互时触发。 焦点事件:当元素获得或失去焦点时触发。 滚轮事件：当使用鼠标滚轮时触发。 文本事件：当在文档中输入文本时触发。 键盘事件：但用户通过键盘在页面上执行操作时触发。 合成事件：当为输入法编辑器输入字符时触发。 变动事件：当底层DOM结构发生变化时触发。123456789101112131415161718192021222324//事件处理程序var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125;; 1、UI事件 UI 事件指的是那些不一定与用户操作有关的事件。 (1)load事件 load在当页面完全加载后在window上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在元素上面触发，或者当嵌入的内容加载完毕时在元素上面触发。 1234//第一种定义onload 事件处理程序的方式EventUtil.addHandler(window, \"load\", function(event)&#123; alert(\"Loaded!\");&#125;); 123456789&lt;!--第二种指定onload 事件处理程序的方式--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Load Event Example&lt;/title&gt; &lt;/head&gt; &lt;body onload=\"alert('Loaded!')\"&gt; &lt;/body&gt;&lt;/html&gt; (2)unload事件 unload，当页面完全卸载后在window上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在元素上面触发。 只要用户从一个页面切换到另一个页面，就会发生unload事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。 123EventUtil.addHandler(window, \"unload\", function(event)&#123; alert(\"Unloaded\");&#125;); 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Unload Event Example&lt;/title&gt; &lt;/head&gt; &lt;body onunload=\"alert('Unloaded!')\"&gt; &lt;/body&gt;&lt;/html&gt; (3)resize事件 resize|当窗口或框架的大小变化时在window 或框架上面触发。 浏览器窗口最小化或最大化时也会触发resize 事件。 123EventUtil.addHandler(window, \"resize\", function(event)&#123; alert(\"Resized\");&#125;); (4)scroll事件 scroll，当用户滚动带滚动条的元素中的内容时，在该元素上面触发。元素中包含所加载页面的滚动条。 1234567EventUtil.addHandler(window, \"scroll\", function(event)&#123; if (document.compatMode == \"CSS1Compat\")&#123; alert(document.documentElement.scrollTop); &#125; else &#123; alert(document.body.scrollTop); &#125;&#125;); (5)abort abort，在用户停止下载过程时，如果嵌入的内容没有加载完，则在元素上面触发。 (6)error error，当发生JavaScript错误时在window上面触发，当无法加载图像时在元素上面触发，当无法加载嵌入内容时在元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发 (7)select select，当用户选择文本框（或）中的一或多个字符时触发。 2、焦点事件 焦点事件会在页面元素获得或失去焦点时触发，有以下6 个焦点事件。 blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focusin：在元素获得焦点时触发。这个事件与HTML 事件focus 等价，但它冒泡。 focusout：在元素失去焦点时触发。这个事件是HTML 事件blur 的通用版本。 当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：(1) focusout 在失去焦点的元素上触发；(2) focusin 在获得焦点的元素上触发；(3) blur 在失去焦点的元素上触发；(4) DOMFocusOut 在失去焦点的元素上触发；(5) focus 在获得焦点的元素上触发；(6) DOMFocusIn 在获得焦点的元素上触发。其中，blur、DOMFocusOut和focusout的事件目标是失去焦点的元素；而focus、DOMFocusIn和focusin 的事件目标是获得焦点的元素。 要确定浏览器是否支持这些事件，可以使用如下代码： 1var isSupported = document.implementation.hasFeature(\"FocusEvent\", \"3.0\"); 3、鼠标与滚轮事件 click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。 dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。 mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。 mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。 mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 要检测浏览器是否支持上面的所有事件，可以使用以下代码： 1var isSupported = document.implementation.hasFeature(\"MouseEvent\", \"3.0\") 鼠标事件中还有一类滚轮事件。而说是一类事件，其实就是一个mousewheel 事件。这个事件跟踪鼠标滚轮。 (1)客户区坐标位置 12345var div = document.getElementById(\"myDiv\");EventUtil.addHandler(div, \"click\", function(event)&#123; event = EventUtil.getEvent(event); alert(\"Client coordinates: \" + event.clientX + \",\" + event.clientY);&#125;); (2)页面坐标位置 12345var div = document.getElementById(\"myDiv\");EventUtil.addHandler(div, \"click\", function(event)&#123; event = EventUtil.getEvent(event); alert(\"Page coordinates: \" + event.pageX + \",\" + event.pageY);&#125;); IE8 及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。 123456789101112131415var div = document.getElementById(\"myDiv\");EventUtil.addHandler(div, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var pageX = event.pageX, pageY = event.pageY; if (pageX === undefined)&#123; pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft); &#125; if (pageY === undefined)&#123; pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop); &#125; alert(\"Page coordinates: \" + pageX + \",\" + pageY);&#125;); (3)屏幕坐标位置 通过screenX 和screenY属性可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。 12345var div = document.getElementById(\"myDiv\");EventUtil.addHandler(div, \"click\", function(event)&#123; event = EventUtil.getEvent(event); alert(\"Screen coordinates: \" + event.screenX + \",\" + event.screenY);&#125;); (4)修改键 在按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。 123456789101112131415161718var div = document.getElementById(\"myDiv\");EventUtil.addHandler(div, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var keys = new Array(); if (event.shiftKey)&#123; keys.push(\"shift\"); &#125; if (event.ctrlKey)&#123; keys.push(\"ctrl\"); &#125; if (event.altKey)&#123; keys.push(\"alt\"); &#125; if (event.metaKey)&#123; keys.push(\"meta\"); &#125; alert(\"Keys: \" + keys.join(\",\"));&#125;); (5)相关元素 在发生mouseover 和mouserout 事件时，还会涉及更多的元素。 对mouseover 事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。 对mouseout 事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。 DOM通过event 对象的relatedTarget 属性提供了相关元素的信息。 IE8及之前版本不支持relatedTarget属性，但提供了保存着同样信息的不同属性。在mouseover 事件触发时，IE 的fromElement属性中保存了相关元素；在mouseout事件触发时，IE 的toElement 属性中保存着相关元素。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Related Elements Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"myDiv\" style=\"background-color:red;\"&gt;test&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223var EventUtil = &#123;//省略了其他代码 getRelatedTarget: function(event)&#123; if (event.relatedTarget)&#123; return event.relatedTarget; &#125; else if (event.toElement)&#123; return event.toElement; &#125; else if (event.fromElement)&#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;,//省略了其他代码&#125;;var div = document.getElementById(\"myDiv\");EventUtil.addHandler(div, \"mouseout\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var relatedTarget = EventUtil.getRelatedTarget(event); alert(\"Moused out of \" + target.tagName + \" to \" + relatedTarget.tagName);&#125;); (6)鼠标按钮 DOM的button 属性可能有如下3 个值： 0 表示主鼠标按钮。 1 表示中间的鼠标按钮（鼠标滚轮按钮）。 2 表示次鼠标按钮。 在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。 IE8 及之前版本也提供了button 属性，但这个属性的值与DOM的button属性有很大差异。 0：表示没有按下按钮。 1：表示按下了主鼠标按钮。 2：表示按下了次鼠标按钮。 3：表示同时按下了主、次鼠标按钮。 4：表示按下了中间的鼠标按钮。 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。 7：表示同时按下了三个鼠标按钮。 12345678910111213141516171819202122232425262728var EventUtil = &#123; //省略了其他代码 getButton: function(event)&#123; if (document.implementation.hasFeature(\"MouseEvents\", \"2.0\"))&#123; return event.button; &#125; else &#123; switch(event.button)&#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125; &#125;, //省略了其他代码&#125;;var div = document.getElementById(\"myDiv\"); EventUtil.addHandler(div, \"mousedown\", function(event)&#123; event = EventUtil.getEvent(event); alert(EventUtil.getButton(event));&#125;); (7)鼠标滚轮事件 与mousewheel 事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta 属性。 当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta 是-120 的倍数。 1234EventUtil.addHandler(document, \"mousewheel\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.wheelDelta);&#125;); (8)触摸设备 不支持dblclick事件，双击浏览器窗口放大画面。 轻击可单击元素会触发mousemove 事件。 mousemove 事件也会触发mouseover 和mouseout 事件。 两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel 和scroll 事件。 4、键盘与文本事件 keydown: 当用户按下键盘上的任意键时触发，若按住不放，会重复触发。 keypress:当用户按下键盘上的字符键时触发，若按住不放，会重复触发。按下ESC键也会触发这个事件。 keyup：当用户释放键盘上的键时触发。 (1)键码 12345var textbox = document.getElementById(\"myText\");EventUtil.addHandler(textbox, \"keyup\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.keyCode);&#125;); (2)字符编码 IE9、Firefox、Chrome 和Safari 的event 对象都支持一个charCode 属性，这个属性只有在发生keypress事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII 编码。此时的keyCode通常等于0 或者也可能等于所按键的键码。 1234567891011121314151617//跨浏览器取得字符编码var EventUtil = &#123; //省略的代码 getCharCode: function(event)&#123; if (typeof event.charCode == \"number\")&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, //省略的代码&#125;;var textbox = document.getElementById(\"myText\");EventUtil.addHandler(textbox, \"keypress\", function(event)&#123; event = EventUtil.getEvent(event); alert(EventUtil.getCharCode(event));&#125;); (3)DOM3级变化 DOM3级事件中的键盘事件，不再包含charCode 属性，而是包含两个新属性：key和char。 在按下某个字符键时，key的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key 的值是相应键的名（如“Shift”或“Down”）。 char 属性在按下字符键时的行为与key 相同，但在按下非字符键时值为null。 IE9 支持key 属性，但不支持char 属性。Safari 5 和Chrome 支持名为keyIdentifier 的属性，在按下非字符键（例如Shift）的情况下与key的值相同。 对于字符键，keyIdentifier 返回一个格式类似“U+0000”的字符串，表示Unicode 值。 12345678var textbox = document.getElementById(\"myText\");EventUtil.addHandler(textbox, \"keypress\", function(event)&#123; event = EventUtil.getEvent(event); var identifier = event.key || event.keyIdentifier; if (identifier)&#123; alert(identifi er); &#125;&#125;); 由于存在跨浏览器问题，因此不推荐使用key、keyIdentifier 或char。 (4)textInput事件 当用户在可编辑区域中输入字符时，就会触发textInput事件。 这个用于替代keypress 的textInput 事件的行为稍有不同。 任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput事件。 textInput 事件只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发。 由于textInput 事件主要考虑的是字符，因此它的event对象中还包含一个data属性，这个属性的值就是用户输入的字符（而非字符编码）。 12345var textbox = document.getElementById(\"myText\");EventUtil.addHandler(textbox, \"textInput\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;); 5、复合事件 复合事件，用于处理IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。 复合事件就是针对检测和处理这种输入而设计的。有以下三种复合事件。 compositionstart：在IME 的文本复合系统打开时触发，表示要开始输入了。 compositionupdate：在向输入字段中插入新字符时触发。 compositionend：在IME 的文本复合系统关闭时触发，表示返回正常键盘输入状态。 在触发复合事件时，目标是接收文本的输入字段。但它比文本事件的事件对象多一个属性data，其中包含以下几个值中的一个。 如果在compositionstart事件发生时访问，包含正在编辑的文本； 如果在compositionupdate 事件发生时访问，包含正插入的新字符； 如果在compositionend 事件发生时访问，包含此次输入会话中插入的所有字符。 12345678910111213var textbox = document.getElementById(\"myText\");EventUtil.addHandler(textbox, \"compositionstart\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;);EventUtil.addHandler(textbox, \"compositionupdate\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;);EventUtil.addHandler(textbox, \"compositionend\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;); 要确定浏览器是否支持复合事件，可以使用以下代码 1var isSupported = document.implementation.hasFeature(\"CompositionEvent\", \"3.0\"); 6、变动事件 DOMSubtreeModified：在DOM 结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。 DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。 DOMNodeRemoved：在节点从其父节点中被移除时触发。 DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted 之后触发。 DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved 之后触发。 DOMAttrModified：在特性被修改之后触发。 DOMCharacterDataModified：在文本节点的值发生变化时触发。 12345678910111213&lt;! DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Node Removal Events Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"myList\"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; (1)删除节点 12345678910111213141516171819//假设要移除&lt;ul&gt;元素，验证以上事件发生的顺序。EventUtil.addHandler(window, \"load\", function(event)&#123; var list = document.getElementById(\"myList\"); EventUtil.addHandler(document, \"DOMSubtreeModified\", function(event)&#123; alert(event.type); alert(event.target); &#125;); EventUtil.addHandler(document, \"DOMNodeRemoved\", function(event)&#123; alert(event.type); alert(event.target); alert(event.relatedNode); &#125;); EventUtil.addHandler(list.firstChild, \"DOMNodeRemovedFromDocument\", function(event)&#123; alert(event.type); alert(event.target); &#125;); list.parentNode.removeChild(list);&#125;); (2)插入节点 1234567891011121314151617181920//假设要为&lt;ul&gt;添加一个&lt;li&gt;元素，验证以上事件发生的顺序。EventUtil.addHandler(window, \"load\", function(event)&#123; var list = document.getElementById(\"myList\"); var item = document.createElement(\"li\"); item.appendChild(document.createTextNode(\"Item 4\")); EventUtil.addHandler(document, \"DOMSubtreeModified\", function(event)&#123; alert(event.type); alert(event.target); &#125;); EventUtil.addHandler(document, \"DOMNodeInserted\", function(event)&#123; alert(event.type); alert(event.target); alert(event.relatedNode); &#125;); EventUtil.addHandler(item, \"DOMNodeInsertedIntoDocument\", function(event)&#123; alert(event.type); alert(event.target); &#125;); list.appendChild(item);&#125;); 7、HTML5事件 (1)contextmenu事件 由于contextmenu 事件是冒泡的，因此可以为document指定一个事件处理程序，用以处理页面中发生的所有此类事件。 这个事件的目标是发生用户操作的元素。在所有浏览器中都可以取消这个事件。 通常使用contextmenu事件来显示自定义的上下文菜单，而使用onclick事件处理程序来隐藏该菜单。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ContextMenu Event Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"myDiv\"&gt;Right click or Ctrl+click me to get a custom context menu.Click anywhere else to get the default context menu.&lt;/div&gt; &lt;ul id=\"myMenu\" style=\"position:absolute;visibility:hidden; background-color:silver\"&gt; &lt;li&gt;&lt;a href=\"http://www.nczonline.net\"&gt;Nicholas’ site&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.wrox.com\"&gt;Wrox site&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.yahoo.com\"&gt;Yahoo!&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314EventUtil.addHandler(window, \"load\", function(event)&#123; var div = document.getElementById(\"myDiv\"); EventUtil.addHandler(div, \"contextmenu\", function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event); var menu = document.getElementById(\"myMenu\"); menu.style.left = event.clientX + \"px\"; menu.style.top = event.clientY + \"px\"; menu.style.visibility = \"visible\"; &#125;); EventUtil.addHandler(document, \"click\", function(event)&#123; document.getElementById(\"myMenu\").style.visibility = \"hidden\"; &#125;);&#125;); (2)beforeunload事件 这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。 这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用户是否真的要关闭页面，还是希望继续留下来。 123456EventUtil.addHandler(window, &quot;beforeunload&quot;, function(event)&#123; event = EventUtil.getEvent(event); var message = &quot;I&apos;m really going to miss you if you go.&quot;; event.returnValue = message; return message;&#125;); (3)DOMCdontentLoaded事件 DOMContentLoaded 事件在形成完整的DOM 树之后就会触发，不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。 要处理DOMContentLoaded事件，可以为document或window添加相应的事件处理程序（尽管这个事件会冒泡到window，但它的目标实际上是document） 123EventUtil.addHandler(document, \"DOMContentLoaded\", function(event)&#123; alert(\"Content loaded\");&#125;); (4)hashchange事件 HTML5 新增了hashchange事件，以便在URL的参数列表（及URL中“#”号后面的所有字符串）发生变化时通知开发人员。 必须要把hashchange 事件处理程序添加给window对象，然后URL参数列表只要变化就会调用它。 此时的event 对象应该额外包含两个属性：oldURL和newURL。这两个属性分别保存着参数列表变化前后的完整URL。 123EventUtil.addHandler(window, \"hashchange\", function(event)&#123; alert(\"Old URL: \" + event.oldURL + \"\\nNew URL: \" + event.newURL);&#125;); 只有Firefox 6+、Chrome和Opera支持oldURL和newURL属性。为此，最好是使用location对象来确定当前的参数列表。 123EventUtil.addHandler(window, \"hashchange\", function(event)&#123; alert(\"Current hash: \" + location.hash);&#125;); 使用以下代码可以检测浏览器是否支持hashchange 事件。 12var isSupported = (\"onhashchange\" in window) &amp;&amp; (document.documentMode ===undefined || document.documentMode &gt; 7); 8、设备事件 (1)orientationchange事件 苹果公司为移动Safari中添加了orientationchange事件，以便开发人员能够确定用户何时将设备由横向查看模式切换为纵向查看模式。 移动Safari 的window.orientation属性中可能包含3个值：0表示肖像模式，90表示向左旋转的横向模式（“主屏幕”按钮在右侧），-90表示向右旋转的横向模式（“主屏幕”按钮在左侧）。 1234567EventUtil.addHandler(window, \"load\", function(event)&#123; var div = document.getElementById(\"myDiv\"); div.innerHTML = \"Current orientation is \" + window.orientation; EventUtil.addHandler(window, \"orientationchange\", function(event)&#123; div.innerHTML = \"Current orientation is \" + window.orientation; &#125;);&#125;); 所有iOS 设备都支持orientationchange 事件和window.orientation 属性。 (2)MozOrientation 事件 Firefox 3.6 为检测设备的方向引入了一个名为MozOrientation的新事件。当设备的加速计检测到设备方向改变时，就会触发这个事件。 123EventUtil.addHandler(window, \"MozOrientation\", function(event)&#123; //响应事件&#125;); 此时的event 对象包含三个属性：x、y和z。这几个属性的值都介于1到-1之间，表示不同坐标轴上的方向。 如果设备向右倾斜，x值会减小；反之，向左倾斜，x值会增大。z轴检测垂直加速度度，1 表示静止不动，在设备移动时值会减小。 只有带加速计的设备才支持MozOrientation 事件. Warning: This experimental API was removed in Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3), when support for the standard DeviceOrientationEvent was implemented. You should use that API instead. (3)deviceorientation 事件 触发deviceorientation事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信息。事件对象包含以下5 个属性。 alpha：在围绕z 轴旋转时（即左右旋转时），y 轴的度数差；是一个介于0 到360 之间的浮点数。 beta：在围绕x 轴旋转时（即前后旋转时），z 轴的度数差；是一个介于-180 到180 之间的浮点数。 gamma：在围绕y 轴旋转时（即扭转设备时），z 轴的度数差；是一个介于-90 到90 之间的浮点数。 absolute：布尔值，表示设备是否返回一个绝对值。 compassCalibrated：布尔值，表示设备的指南针是否校准过。 12345EventUtil.addHandler(window, \"deviceorientation\", function(event)&#123; var output = document.getElementById(\"output\"); output.innerHTML = \"Alpha=\" + event.alpha + \", Beta=\" + event.beta + \", Gamma=\" + event.gamma + \"&lt;br&gt;\";&#125;); 通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋转元素。 1234EventUtil.addHandler(window, \"deviceorientation\", function(event)&#123;var arrow = document.getElementById(\"arrow\"); arrow.style.webkitTransform = \"rotate(\" + Math.round(event.alpha) + \"deg)\";&#125;); (4)devicemotion 事件 DeviceOrientation Event 规范还定义了一个devicemotion 事件，通过devicemotion 能够检测到设备是不是正在往下掉，或者是不是被走着的人拿在手里。 触发devicemotion 事件时，事件对象包含以下属性。 acceleration：一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。 accelerationIncludingGravity：一个包含x、y和z属性的对象，在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。 interval：以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。这个值在每个事件中应该是一个常量。 rotationRate：一个包含表示方向的alpha、beta 和gamma 属性的对象。 12345678EventUtil.addHandler(window, \"devicemotion\", function(event)&#123; var output = document.getElementById(\"output\"); if (event.rotationRate !== null)&#123; output.innerHTML += \"Alpha=\" + event.rotationRate.alpha + \", Beta=\" + event.rotationRate.beta + \", Gamma=\" + event.rotationRate.gamma; &#125;&#125;); 9、触摸与手势事件 (1)触摸事件 触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。 名称 详细 touchstart 当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。 touchmove 当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。 touchend 当手指从屏幕上移开时触发。 touchcancel 当系统停止跟踪触摸时触发。 每个触摸事件的event对象都提供了在鼠标事件中常见的属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey 和metaKey。 除了常见的DOM属性外，触摸事件还包含下列三个用于跟踪触摸的属性。名称|详细-|-touches|表示当前跟踪的触摸操作的Touch 对象的数组。targetTouchs|特定于事件目标的Touch 对象的数组。changeTouches|表示自上次触摸以来发生了什么改变的Touch 对象的数组。 每个Touch 对象包含下列属性。名称|详细-|-clientX|触摸目标在视口中的x 坐标。clientY|触摸目标在视口中的y 坐标。identifier|标识触摸的唯一ID。pageX|触摸目标在页面中的x 坐标。pageY|触摸目标在页面中的y 坐标。screenX|触摸目标在屏幕中的x 坐标。screenY|触摸目标在屏幕中的y 坐标。target|触摸的DOM 节点目标。 使用这些属性可以跟踪用户对屏幕的触摸操作。 1234567891011121314151617181920212223242526function handleTouchEvent(event)&#123;//只跟踪一次触摸 if (event.touches.length == 1)&#123; var output = document.getElementById(\"output\"); switch(event.type)&#123; case \"touchstart\": output.innerHTML = \"Touch started (\" + event.touches[0].clientX + \",\" + event.touches[0].clientY + \")\"; break; case \"touchend\": output.innerHTML += \"&lt;br&gt;Touch ended (\" + event.changedTouches[0].clientX + \",\" + event.changedTouches[0].clientY + \")\"; break; case \"touchmove\": event.preventDefault(); //阻止滚动 output.innerHTML += \"&lt;br&gt;Touch moved (\" + event.changedTouches[0].clientX + \",\" + event.changedTouches[0].clientY + \")\"; break; &#125; &#125;&#125;EventUtil.addHandler(document, \"touchstart\", handleTouchEvent);EventUtil.addHandler(document, \"touchend\", handleTouchEvent);EventUtil.addHandler(document, \"touchmove\", handleTouchEvent); (2)手势事件 当两个手指触摸屏幕时就会产生手势，手势通常会改变显示项的大小，或者旋转显示项。有三个手势事件。 名称 详细 gesturestart 当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。 gesturechange 当触摸屏幕的任何一个手指的位置发生变化时触发。 gestureend 当任何一个手指从屏幕上面移开时触发。 每个手势事件的event对象都包含着标准的鼠标事件属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。 还包含两个额外的属性：rotation 和scale。 名称 详细 rotation 表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0 开始）。 scale 表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从1 开始，并随距离拉大而增长，随距离缩短而减小。 1234567891011121314151617181920function handleGestureEvent(event)&#123; var output = document.getElementById(\"output\"); switch(event.type)&#123; case \"gesturestart\": output.innerHTML = \"Gesture started (rotation=\" + event.rotation + \",scale=\" + event.scale + \")\"; break; case \"gestureend\": output.innerHTML += \"&lt;br&gt;Gesture ended (rotation=\" + event.rotation + \",scale=\" + event.scale + \")\"; break; case \"gesturechange\": output.innerHTML += \"&lt;br&gt;Gesture changed (rotation=\" + event.rotation + \",scale=\" + event.scale + \")\"; break; &#125;&#125;document.addEventListener(\"gesturestart\", handleGestureEvent, false);document.addEventListener(\"gestureend\", handleGestureEvent, false);document.addEventListener(\"gesturechange\", handleGestureEvent, false);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-事件对象","slug":"javascript 事件对象","date":"2017-12-13T17:33:28.000Z","updated":"2017-12-13T08:46:58.000Z","comments":true,"path":"2017/12/14/javascript 事件对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/14/javascript 事件对象/","excerpt":"","text":"事件对象 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。 包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。 1、DOM中的事件对象 兼容DOM 的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或DOM2 级），都会传入event 对象。 1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(event.type); //\"click\"&#125;;btn.addEventListener(\"click\", function(event)&#123; alert(event.type); //\"click\"&#125;, false); 在通过HTML 特性指定事件处理程序时，变量event 中保存着event 对象。 1&lt;input type=\"button\" value=\"Click Me\" onclick=\"alert(event.type)\"/&gt; event 对象包含与创建它的特定事件有关的属性和方法，详见：HTML DOM Event 对象 在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。 12345678910111213var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(event.currentTarget === this); //true alert(event.target === this); //true&#125;;/**如果事件处理程序存在于按钮的父节点中（例如document.body），那么这些值是不相同的。**/document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById(\"myBtn\")); //true&#125;; 在需要通过一个函数处理多个事件时，可以使用type 属性。 1234567891011121314151617var btn = document.getElementById(\"myBtn\");var handler = function(event)&#123; switch(event.type)&#123; case \"click\": alert(\"Clicked\"); break; case \"mouseover\": event.target.style.backgroundColor = \"red\"; break; case \"mouseout\": event.target.style.backgroundColor = \"\"; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn. onmouseout = handler; 要阻止特定事件的默认行为，可以使用preventDefault()方法。 12345/**阻止链接导航的默认行为**/var link = document.getElementById(\"myLink\");link.onclick = function(event)&#123; event.preventDefault();&#125;; 只有cancelable 属性设置为true的事件，才可以使用preventDefault()来取消其默认行为。 stopPropagation()方法用于立即停止事件在DOM 层次中的传播，即取消进一步的事件捕获或冒泡。 12345678var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(\"Clicked\"); event.stopPropagation();&#125;;document.body.onclick = function(event)&#123; alert(\"Body clicked\");&#125;; 事件对象的eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。 如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则event-Phase 等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase 等于3。 12345678910var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(event.eventPhase); //2&#125;;document.body.addEventListener(\"click\", function(event)&#123; alert(event.eventPhase); //1&#125;, true);document.body.onclick = function(event)&#123; alert(event.eventPhase); //3&#125;; 只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。 2、IE中的事件对象 要访问IE 中的event 对象有几种不同的方式，取决于指定事件处理程序的方法。 在使用DOM0 级方法添加事件处理程序时，event 对象作为window 对象的一个属性存在。 12345var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; var event = window.event; alert(event.type); //\"click\"&#125;; 如果事件处理程序是使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中。 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function(event)&#123; alert(event.type); //\"click\"&#125;); 如果是通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event的变量来访问event对象。 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; event的returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue 设置为false，就可以阻止默认行为。 1234var link = document.getElementById(\"myLink\");link.onclick = function()&#123; window.event.returnValue = false;&#125;; cancelBubble 属性与DOM中的stopPropagation()方法作用相同，用来停止事件冒泡。12345678var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; alert(\"Clicked\"); window.event.cancelBubble = true;&#125;;document.body.onclick = function()&#123; alert(\"Body clicked\");&#125;; 3、跨浏览器的事件对象 虽然DOM 和IE 中的event对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var EventUtil = &#123; addHandler: function(element, type, handler)&#123; //省略的代码 &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault: function(event)&#123; if (event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function(element, type, handler)&#123; //省略的代码 &#125;, stopPropagation: function(event)&#123; if (event.stopPropagation)&#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;;/**假设有一个事件对象传入到事件处理程序中，而且要把该变量传给这个方**/btn.onclick = function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);&#125;;//getTarget()它返回事件的目标btn.onclick = function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);&#125;;//preventDefault()，用于取消事件的默认行为。var link = document.getElementById(\"myLink\");link.onclick = function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event);&#125;;//stopPropagation(),停止事件冒泡var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(\"Clicked\"); event = EventUtil.getEvent(event); EventUtil.stopPropagation(event);&#125;;document.body.onclick = function(event)&#123; alert(\"Body clicked\");&#125;;","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-事件处理程序","slug":"javascript 事件处理程序","date":"2017-12-12T17:44:28.000Z","updated":"2017-12-12T09:44:28.000Z","comments":true,"path":"2017/12/13/javascript 事件处理程序/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/13/javascript 事件处理程序/","excerpt":"","text":"事件处理程序 事件就是用户或浏览器自身执行的某种动作，而响应某个事件的函数就叫做事件处理程序。 1、HTML 事件处理程序 某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML 特性来指定。 12345678910&lt;script type=\"text/javascript\"&gt; function showMessage()&#123; alert(\"Hello world!\"); &#125;&lt;/script&gt;&lt;input type=\"button\" value=\"Click Me\" onclick=\"showMessage()\" /&gt;&lt;!-- 输出 \"click\" --&gt;&lt;input type=\"button\" value=\"Click Me\" onclick=\"alert(event.type)\"&gt;&lt;!-- 输出 \"Click Me\" --&gt;&lt;input type=\"button\" value=\"Click Me\" onclick=\"alert(this.value)\"&gt; 通过HTML 指定事件处理程序的最后一个缺点是HTML 与JavaScript 代码紧密耦合。 2、DOM0 级事件处理程序 通过JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。 每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写。 1234var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; alert(\"Clicked\");&#125;; 使用DOM0 级方法指定的事件处理程序被认为是元素的方法，程序中的this引用当前元素。 1234var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; alert(this.id); //\"myBtn\"&#125;; 删除通过DOM0级方法指定的事件处理程序，可以将事件处理程序属性的值设置为null 1btn.onclick = null; //删除事件处理程序 3、DOM2 级事件处理程序 “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener() 和 removeEventListener()。 所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 1234var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function()&#123; alert(this.id);&#125;, false); 使用DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。 12345678var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function()&#123; alert(this.id);&#125;, false);btn.addEventListener(\"click\", function()&#123; alert(\"Hello world!\");&#125;, false);//这两个事件处理程序会按照添加它们的顺序触发 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除； 移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。 12345678var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function()&#123; alert(this.id);&#125;, false);//这里省略了其他代码btn.removeEventListener(\"click\", function()&#123; //没有用！ alert(this.id);&#125;, false); 虽然调用remove-EventListener()时看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个是完全不同的函数。 1234567var btn = document.getElementById(\"myBtn\");var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener(\"click\", handler, false);//这里省略了其他代码btn.removeEventListener(\"click\", handler, false); //有效！ 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。 IE9、Firefox、Safari、Chrome 和Opera 支持DOM2 级事件处理程序。 4、IE事件处理程序 IE 实现了与DOM 中类似的两个方法：attachEvent()和detachEvent()。 这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function()&#123; alert(\"Clicked\");&#125;); 在IE 中使用attachEvent()与使用DOM0 级方法的主要区别在于事件处理程序的作用域。 在使用DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行。 在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this 等于window。 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function()&#123; alert(this === window); //true&#125;); 与addEventListener()类似，attachEvent()方法也可以用来为一个元素添加多个事件处理程序。 12345678var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function()&#123; alert(\"Clicked\");&#125;);btn.attachEvent(\"onclick\", function()&#123; alert(\"Hello world!\");&#125;);//这两个事件处理程序以相反的顺序被触发 使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。只要能够将对相同函数的引用传给detachEvent()，就可以移除相应的事件处理程序。 1234567var btn = document.getElementById(\"myBtn\");var handler = function()&#123; alert(\"Clicked\");&#125;;btn.attachEvent(\"onclick\", handler);//这里省略了其他代码btn.detachEvent(\"onclick\", handler); 支持IE 事件处理程序的浏览器有IE 和Opera。 5、跨浏览器的事件处理程序 要保证处理事件的代码能在大多数浏览器下一致地运行，只需关注冒泡阶段。 第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0 级方法、DOM2 级方法或IE 方法来添加事件。 addHandler()方法接受3 个参数：要操作的元素、事件名称和事件处理程序函数。 与addHandler()对应的方法是removeHandler()，它也接受相同的参数。这个方法的职责是移除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用DOM0 级方法。 1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125;; 1234567var btn = document.getElementById(\"myBtn\");var handler = function()&#123; alert(\"Clicked\");&#125;;EventUtil.addHandler(btn, \"click\", handler);//这里省略了其他代码EventUtil.removeHandler(btn, \"click\", handler);","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-事件流","slug":"javascript 事件流","date":"2017-12-12T17:33:28.000Z","updated":"2017-12-12T09:44:06.000Z","comments":true,"path":"2017/12/13/javascript 事件流/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/13/javascript 事件流/","excerpt":"","text":"事件流 事件流描述的是从页面中接收事件的顺序。 IE 的事件流是事件冒泡流，而Netscape Communicator 的事件流是事件捕获流。 1、事件冒泡 IE 的事件流叫做事件冒泡（eventbubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"myDiv\"&gt;Click Me&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345如果你单击了页面中的&lt;div&gt;元素，那么这个click 事件会按照如下顺序传播.(1) &lt;div&gt;(2) &lt;body&gt;(3) &lt;html&gt;(4) document 2、事件捕获 事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。 事件捕获的用意在于在事件到达预定目标之前捕获它。 12345单击&lt;div&gt;元素就会以下列顺序触发click 事件。(1) document(2) &lt;html&gt;(3) &lt;body&gt;(4) &lt;div&gt; 3、DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM扩展","slug":"DOM 扩展","date":"2017-12-07T17:33:28.000Z","updated":"2017-12-12T09:46:20.000Z","comments":true,"path":"2017/12/08/DOM 扩展/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/08/DOM 扩展/","excerpt":"","text":"选择符API Selectors API（www.w3.org/TR/selectors-api/）是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS 查询。 1、querySelector()方法 querySelector()方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。 12345678//取得body 元素var body = document.querySelector(\"body\");//取得ID 为\"myDiv\"的元素var myDiv = document.querySelector(\"#myDiv\");//取得类为\"selected\"的第一个元素var selected = document.querySelector(\".selected\");//取得类为\"button\"的第一个图像元素var img = document.body.querySelector(\"img.button\"); 2、querySelectorAll()方法 querySelectorAll()方法接收的参数也是一个CSS 选择符，这个方法返回的是一个NodeList 的实例。 123456//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于getElementsByTagName(\"em\")）var ems = document.getElementById(\"myDiv\").querySelectorAll(\"em\");//取得类为\"selected\"的所有元素var selecteds = document.querySelectorAll(\".selected\");//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(\"p strong\"); 要取得返回的NodeList中的每一个元素，可以使用item()方法，也可以使用方括号语法. 12345var i, len, strong;for (i=0, len=strongs.length; i &lt; len; i++)&#123; strong = strongs[i]; //或者strongs.item(i) strong.className = \"important\";&#125; 3、matchesSelector()方法 matchesSelector()方法接收一个参数，即CSS选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。 123if (document.body.matchesSelector(\"body.page1\"))&#123;//true&#125; IE 9+通过msMatchesSelector()支持该方法，Firefox3.6+通过mozMatchesSelector()支持该方法，Safari 5+和Chrome 通过webkitMatchesSelector()支持该方法。 想使用这个方法，最好是编写一个包装函数。 12345678910111213141516function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error(\"Not supported.\"); &#125;&#125;if (matchesSelector(document.body, \"body.page1\"))&#123;//执行操作&#125; ####元素遍历 对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用childNodes 和firstChild 等属性时的行为不一致。 为了弥补这一差异，而同时又保持DOM规范不变，ElementTraversal规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。 Element Traversal API 为DOM元素添加了以下5 个属性。 childElementCount：返回子元素（不包括文本节点和注释）的个数。 firstElementChild：指向第一个子元素；firstChild 的元素版。 lastElementChild：指向最后一个子元素；lastChild 的元素版。 previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。 nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。 利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM 元素。 12345678910111213141516171819202122/**要跨浏览器遍历某元素的所有子元素**///过去var i,len,child = element.firstChild;while(child != element.lastChild)&#123; if (child.nodeType == 1)&#123; //检查是不是元素 processChild(child); &#125; child = child.nextSibling;&#125;//使用Element Traversal 新增的元素var i,len,child = element.firstElementChild;while(child != element.lastElementChild)&#123; processChild(child); //已知其是元素 child = child.nextElementSibling;&#125; 支持Element Traversal 规范的浏览器有IE 9+、Firefox 3.5+、Safari 4+、Chrome 和Opera 10+。 ####HTML5 HTML5 规范则围绕如何使用新增标记定义了大量JavaScript API。其中一些API 与DOM 重叠，定义了浏览器应该支持的DOM扩展。 1、与类相关的扩充 (1)getElementsByClassName()方法、 1234//取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName(\"username current\");//取得ID 为\"myDiv\"的元素中带有类名\"selected\"的所有元素var selected = document.getElementById(\"myDiv\").getElementsByClassName(\"selected\"); (2)classList 属性 在操作类名时，需要通过className 属性添加、删除和替换类名。 1&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt; 要从中删除一个类名，需要把这三个类名拆开，删除不想要的那个，然后再把其他类名拼成一个新字符串。 1234567891011121314151617//删除\"user\"类//首先，取得类名字符串并拆分成数组var classNames = div.className.split(/\\s+/);//找到要删的类名var pos = -1,i,len;for (i=0, len=classNames.length; i &lt; len; i++)&#123; if (classNames[i] == \"user\")&#123; pos = i; break; &#125;&#125;//删除类名classNames.splice(i,1);//把剩下的类名拼成字符串并重新设置div.className = classNames.join(\" \"); HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList 属性。 classList 属性是新集合类型DOMTokenList的实例，具有包含多少元素的length属性，取得每个元素的item()方法，以及下列方法。 add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。 remove(value)：从列表中删除给定的字符串。 toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 极大地减少类似基本操作的复杂性 123456789101112131415161718192021222324&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt;``` ```javascript//删除\"user\"类div.classList.remove(\"user\");//删除\"disabled\"类div.classList.remove(\"disabled\");//添加\"current\"类div.classList.add(\"current\");//切换\"user\"类div.classList.toggle(\"user\");//确定元素中是否包含既定的类名if (div.classList.contains(\"bd\") &amp;&amp; !div.classList.contains(\"disabled\"))&#123; //执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125; 支持classList 属性的浏览器有Firefox 3.6+和Chrome。 2、焦点管理 (1)document.activeElement HTML5 也添加了辅助管理DOM 焦点的功能。首先就是document.activeElement 属性，这个属性始终会引用DOM 中当前获得了焦点的元素。 元素获得焦点的方式有页面加载、用户输入（通常是通过按Tab键）和在代码中调用focus()方法。 123var button = document.getElementById(\"myButton\");button.focus();alert(document.activeElement === button); //true 默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是document.body 元素的引用。 文档加载期间，document.activeElement 的值为null。 (2)document.hasFocus() 新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。 123var button = document.getElementById(\"myButton\");button.focus();alert(document.hasFocus()); //true 3、HTMLDocument的变化 (1)readyState 属性 Document 的readyState 属性有两个可能的值： loading，正在加载文档； complete，已经加载完文档。 123if (document.readyState == \"complete\")&#123;//执行操作&#125; (2)兼容模式 document的compatMode的属性，告诉开发人员浏览器采用了哪种渲染模式。 在标准模式下，document.compatMode的值等于”CSS1Compat”，而在混杂模式下，document.compatMode 的值等于”BackCompat”。 12345if (document.compatMode == \"CSS1Compat\")&#123; alert(\"Standards mode\");&#125; else &#123; alert(\"Quirks mode\");&#125; (3)head属性 -作为对document.body 引用文档的元素的补充，HTML5 新增了document.head 属性，引用文档的元素。 1var head = document.head || document.getElementsByTagName(\"head\")[0]; 4、字符集属性 (1)charset charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。 默认情况下，这个属性的值为”UTF-16”，但可以通过元素、响应头部或直接设置charset 属性修改这个值。 12alert(document.charset); //\"UTF-16\"document.charset = \"UTF-8\"; (2)defaultCharset defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。 如果文档没有使用默认的字符集，那charset 和defaultCharset 属性的值可能会不一样。 123if (document.charset != document.defaultCharset)&#123; alert(\"Custom character set being used.\");&#125; 5、自定义数据属性 HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。 这些属性可以任意添加、随便命名，只要以data-开头即可。 1&lt;div id=\"myDiv\" data-appId=\"12345\" data-myname=\"Nicholas\"&gt;&lt;/div&gt; 1234567891011var div = document.getElementById(\"myDiv\");//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = \"Michael\";//有没有\"myname\"值呢？if (div.dataset.myname)&#123; alert(\"Hello, \" + div.dataset.myname);&#125; 6、插入标记 (1)innerHTML属性 在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML 标记。 12345678&lt;div id=\"content\"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于上面的div元素来说，它的innerHTML 属性会返回如下字符串。 123456&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 在写模式下，innerHTML 会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。 123div.innerHTML = \"_&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\";div.innerHTML = \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\";div.innerHTML = \"&lt;input type=\\\"hidden\\\"&gt;&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\"; (2)outerHTML属性 在读模式下，outerHTML 返回调用它的元素及所有子节点的HTML 标签。 12345678&lt;div id=\"content\"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如果在元素上调用outerHTML，会返回与上面相同的代码，包括本身。 在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。 使用outerHTML 属性以下面这种方式设置值： 123456div.outerHTML = \"&lt;p&gt;This is a paragraph.&lt;/p&gt;\";//DOM 脚本代码var p = document.createElement(\"p\");p.appendChild(document.createTextNode(\"This is a paragraph.\"));div.parentNode.replaceChild(p, div); (3)insertAdjacentHTML()方法 insertAdjacentHTML()方法接收两个参数：插入位置和要插入的HTML 文本。 第一个参数必须是下列值之一，注意，这些值都必须是小写形式： “beforebegin”，在当前元素之前插入一个紧邻的同辈元素； “afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素； “beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素； “afterend”，在当前元素之后插入一个紧邻的同辈元素。 第二个参数是一个HTML 字符串，如果浏览器无法解析该字符串，就会抛出错误。 12345678//作为前一个同辈元素插入element.insertAdjacentHTML(\"beforebegin\", \"&lt;p&gt;Hello world!&lt;/p&gt;\");//作为第一个子元素插入element.insertAdjacentHTML(\"afterbegin\", \"&lt;p&gt;Hello world!&lt;/p&gt;\");//作为最后一个子元素插入element.insertAdjacentHTML(\"beforeend\", \"&lt;p&gt;Hello world!&lt;/p&gt;\");//作为后一个同辈元素插入element.insertAdjacentHTML(\"afterend\", \"&lt;p&gt;Hello world!&lt;/p&gt;\"); (4)内存与性能问题 不可避免地，创建和销毁HTML 解析器也会带来性能损失，所以最好能够将设置innerHTML或outerHTML 的次数控制在合理的范围内。 1234567891011121314for (var i=0, len=values.length; i &lt; len; i++)&#123; ul.innerHTML += \"&lt;li&gt;\" + values[i] + \"&lt;/li&gt;\"; //要避免这种频繁操作！！&#125;/**最好的做法是单独构建字符串，然后再一次性地将结果字符串赋值给innerHTML**/var itemsHtml = \"\";for (var i=0, len=values.length; i &lt; len; i++)&#123; itemsHtml += \"&lt;li&gt;\" + values[i] + \"&lt;/li&gt;\";&#125;ul.innerHTML = itemsHtml; 7、scrollIntoView()方法 scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。 如果给这个方法传入true作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。 如果传入false 作为参数，调用元素会尽可能全部出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐。 12//让元素可见document.forms[0].scrollIntoView(); ####专有扩展 (1)文档模式 要强制浏览器以某种模式渲染页面，可以使用HTTP头部信息X-UA-Compatible，或通过等价的标签来设置： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=IEVersion\"&gt; (2）children属性 这个属性是HTMLCollection 的实例，只包含元素中同样还是元素的子节点。 12var childCount = element.children.length;var firstChild = element.children[0]; （3）contains()方法 contains()方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回true；否则，返回false。 1alert(document.documentElement.contains(document.body)); //true 使用DOM Level 3 compareDocumentPosition()也能够确定节点间的关系。返回一个表示该关系的位掩码（ bitmask）。 支持这个方法的浏览器有IE9+、Firefox、Safari、Opera 9.5+和Chrome。 下表列出了这个位掩码的值。 掩码 节点关系 1 无关（给定的节点不在当前文档中） 2 居前（给定的节点在DOM树中位于参考节点之前） 4 居后（给定的节点在DOM树中位于参考节点之后） 8 包含（给定的节点是参考节点的祖先） 16 被包含（给定的节点是参考节点的后代） 可以对compareDocumentPosition()的结果执行按位与，以确定参考节点（调用compareDocumentPosition()方法的当前节点）是否包含给定的节点（传入的节点）。 12var result = document.documentElement.compareDocumentPosition(document.body);alert(!!(result &amp; 16)); 使用一些浏览器及能力检测，就可以写出如下所示的一个通用的contains 函数： 12345678910111213141516171819function contains(refNode, otherNode)&#123; if (typeof refNode.contains == \"function\" &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;= 522))&#123; /**检查了当前浏览器所用的WebKit 版本号，如果浏览器是WebKit 且至少是Safari 3（WebKit版本号为522 或更高）**/ return refNode.contains(otherNode); &#125; else if (typeof refNode.compareDocumentPosition == \"function\")&#123; return !!(refNode.compareDocumentPosition(otherNode) &amp; 16); &#125; else &#123; var node = otherNode.parentNode; do &#123; if (node === refNode)&#123; return true; &#125; else &#123; node = node.parentNode; &#125; &#125; while (node !== null); return false; &#125;&#125; (4)插入文本 在通过innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。 12345678&lt;div id=\"content\"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于这个例子中的元素而言，其innerText 属性会返回下列字符串 1234This is a paragraph with a list following it.Item 1Item 2Item 3 在通过innerText 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。 1div.innerText = \"Hello world!\"; 执行这行代码后，页面的HTML 代码就会变成如下所示。 1&lt;div id=\"content\"&gt;Hello world!&lt;/div&gt; Firefox 不支持innerText，支持作用类似的textContent 属性。 为了确保跨浏览器兼容，有必要编写一个类似于下面的函数来检测可以使用哪个属性。 12345678910111213function getInnerText(element)&#123; return (typeof element.textContent == \"string\") ? element.textContent : element.innerText;&#125;function setInnerText(element, text)&#123; if (typeof element.textContent == \"string\")&#123; element.textContent = text; &#125; else &#123; element.innerText = text; &#125;&#125;setInnerText(div, \"Hello world!\");alert(getInnerText(div)); //\"Hello world!\" 在读取文本值时，outerText 与innerText 的结果完全一样。 在写模式下，outerText就完全不同了：outerText不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。 12345div.outerText = \"Hello world!\";//这行代码实际上相当于如下两行代码：var text = document.createTextNode(\"Hello world!\");div.parentNode.replaceChild(text, div); (5)滚动 The scrollByLines method is only supported by Firefox, use the cross-browser scrollBy method instead. scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的alignCenter参数设置为true，则表示尽量将元素显示在视口中部（垂直方向）。 scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount 值可以是正值，也可以是负值。 scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM操作技术","slug":"DOM操作技术","date":"2017-12-01T17:33:28.000Z","updated":"2017-12-01T09:22:02.000Z","comments":true,"path":"2017/12/02/DOM操作技术/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/02/DOM操作技术/","excerpt":"","text":"动态脚本 使用&lt;script&gt;元素可以向页面中插入JavaScript代码，一种方式是通过其src特性包含外部文件，另一种方式就是用这个元素本身来包含代码 动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改DOM 动态添加的脚本。 创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript 代码。 动态加载的外部JavaScript 文件能够立即运行。 1&lt;script type=\"text/javascript\" src=\"client.js\"&gt;&lt;/script&gt; 创建这个节点的DOM 代码 1234567function loadScript(url)&#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = url; document.body.appendChild(script);&#125;loadScript(\"client.js\"); 另一种指定JavaScript 代码的方式是行内方式。 12345&lt;script type=\"text/javascript\"&gt; function sayHi()&#123; alert(\"hi\"); &#125;&lt;/script&gt; 12345678910111213function loadScriptString(code)&#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; //针对IE script.text = code; &#125; document.body.appendChild(script);&#125;loadScriptString(\"function sayHi()&#123;alert('hi');&#125;\"); 动态样式 能够把CSS 样式包含到HTML页面中的元素有两个。其中，&lt;link&gt;元素用于包含来自外部的文件，而&lt;style&gt;元素用于指定嵌入的样式。 动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt; 使用DOM 代码可以很容易地动态创建出这个元素 123456789function loadStyles(url)&#123; var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = url; var head = document.getElementsByTagName(\"head\")[0]; head.appendChild(link);&#125;loadStyles(\"styles.css\"); 另一种定义样式的方式是使用&lt;style&gt;元素来包含嵌入式CSS. 12345&lt;style type=\"text/css\"&gt;body &#123; background-color: red;&#125;&lt;/style&gt; 1234567891011121314function loadStyleString(css)&#123; var style = document.createElement(\"style\"); style.type = \"text/css\"; try&#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex)&#123; //针对IE style.styleSheet.cssText = css; &#125; var head = document.getElementsByTagName(\"head\")[0]; head.appendChild(style);&#125;loadStyleString(\"body&#123;background-color:red&#125;\"); 操作表格 为了方便构建表格，HTML DOM为&lt;table&gt;、&lt;tbody&gt;和&lt;tr&gt;元素添加了一些属性和方法。 为&lt;table&gt;元素添加的属性和方法如下。 caption：保存着对&lt;caption&gt;元素（如果有）的指针。 tBodies：是一个&lt;tbody&gt;元素的HTMLCollection。 tFoot：保存着对&lt;tfoot&gt;元素（如果有）的指针。 tHead：保存着对&lt;thead&gt;元素（如果有）的指针。 rows：是一个表格中所有行的HTMLCollection。 createTHead()：创建&lt;thead&gt;元素，将其放到表格中，返回引用。 createTFoot()：创建&lt;tfoot&gt;元素，将其放到表格中，返回引用。 createCaption()：创建&lt;caption&gt;元素，将其放到表格中，返回引用。 deleteTHead()：删除&lt;thead&gt;元素。 deleteTFoot()：删除&lt;tfoot&gt;元素。 deleteCaption()：删除&lt;caption&gt;元素。 deleteRow(pos)：删除指定位置的行。 insertRow(pos)：向rows 集合中的指定位置插入一行。 为&lt;tbody&gt;元素添加的属性和方法如下。 rows：保存着&lt;tbody&gt;元素中行的HTMLCollection。 deleteRow(pos)：删除指定位置的行。 insertRow(pos)：向rows 集合中的指定位置插入一行，返回对新插入行的引用。 为&lt;tr&gt;元素添加的属性和方法如下。 cells：保存着&lt;tr&gt;元素中单元格的HTMLCollection。 deleteCell(pos)：删除指定位置的单元格。 insertCell(pos)：向cells集合中的指定位置插入一个单元格，返回对新插入单元格的引用。 使用DOM创建HTML表格 123456789101112&lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell 1,2&lt;/td&gt; &lt;td&gt;Cell 2,2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 12345678910111213141516171819202122232425//创建tablevar table = document.createElement(\"table\");table.border = 1;table.width = \"100%\";//创建tbodyvar tbody = document.createElement(\"tbody\");table.appendChild(tbody);//创建第一行tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(\"Cell 1,1\"));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(\"Cell 2,1\"));//创建第二行tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(\"Cell 1,2\"));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(\"Cell 2,2\"));//将表格添加到文档主体中document.body.appendChild(table); 使用NodeList 从本质上说，所有NodeList 对象都是在访问DOM文档时实时运行的查询。 123456789//下列代码会导致无限循环var divs = document.getElementsByTagName(\"div\"),i,div;for (i=0; i &lt; divs.length; i++)&#123; div = document.createElement(\"div\"); document.body.appendChild(div);&#125; 要迭代一个NodeList，最好是使用length 属性初始化第二个变量，然后将迭代器与该变量进行比较。 12345678var divs = document.getElementsByTagName(\"div\"),i,len,div;for (i=0, len=divs.length; i &lt; len; i++)&#123; div = document.createElement(\"div\"); document.body.appendChild(div);&#125; 一般来说，应该尽量减少访问NodeList的次数。因为每次访问NodeList，都会运行一次基于文档的查询。所以，可以考虑将从NodeList 中取得的值缓存起来。 DOM小结 DOM是语言中立的API，用于访问和操作HTML 和XML 文档。 DOM1 级将HTML 和XML 文档形象地看作一个层次化的节点树，可以使用JavaScript 来操作这个节点树，进而改变底层文档的外观和结构。 DOM 由各种节点构成 最基本的节点类型是Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node。 Document 类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document 对象是Document 的一个实例。使用document 对象，有很多种方式可以查询和取得节点。 Element 节点表示文档中的所有HTML或XML元素，可以用来操作这些元素的内容和特性。 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA区域和文档片段。 访问DOM 的操作在多数情况下都很直观，不过在处理&lt;script&gt;和&lt;style&gt;元素时还是存在一些复杂性。 由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用innerHTML 时，以及在创建新元素时的一些问题。 理解DOM的关键，就是理解DOM 对性能的影响。 DOM操作往往是JavaScript程序中开销最大的部分，而因访问NodeList导致的问题为最多。 NodeList 对象都是“动态的”，这就意味着每次访问NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM-节点层次-DocumentType类型&DocumentFragment类型&Attr类型","slug":"DOM-节点层次-DocumentType类型&DocumentFragment类型&Attr类型","date":"2017-11-30T17:33:28.000Z","updated":"2017-11-30T09:15:26.000Z","comments":true,"path":"2017/12/01/DOM-节点层次-DocumentType类型&DocumentFragment类型&Attr类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/12/01/DOM-节点层次-DocumentType类型&DocumentFragment类型&Attr类型/","excerpt":"","text":"DocumentType类型 DocumentType 包含着与文档的doctype 有关的所有信息，它具有下列特征： nodeType 的值为10； nodeName 的值为doctype 的名称； nodeValue 的值为null； parentNode 是Document； 不支持（没有）子节点。 DOM1 级描述了DocumentType 对象的3 个属性：name、entities 和notations。 name 表示文档类型的名称；entities是由文档类型描述的实体的NamedNodeMap对象；notations 是由文档类型描述的符号的NamedNodeMap 对象。 12&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\"http://www.w3.org/TR/html4/strict.dtd\"&gt; 1alert(document.doctype.name); //\"HTML\" DocumentFragment类型 在所有节点类型中，只有DocumentFragment 在文档中没有对应的标记。 DocumentFragment 节点具有下列特征： nodeType 的值为11； nodeName 的值为”#document-fragment”； nodeValue 的值为null； parentNode 的值为null； 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection 或EntityReference。 虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。 要创建文档片段，可以使用document.createDocumentFragment()方法。 文档片段继承了Node 的所有方法，通常用于执行那些针对文档的DOM操作。 1&lt;ul id=\"myList\"&gt;&lt;/ul&gt; 123456789var fragment = document.createDocumentFragment();var ul = document.getElementById(\"myList\");var li = null;for (var i=0; i &lt; 3; i++)&#123; li = document.createElement(\"li\"); li.appendChild(document.createTextNode(\"Item \" + (i+1))); fragment.appendChild(li);&#125;ul.appendChild(fragment); Attr类型 元素的特性在DOM 中以Attr 类型来表示。在所有浏览器中（包括IE8），都可以访问Attr 类型的构造函数和原型。 特性就是存在于元素的attributes 属性中的节点。特性节点具有下列特征： nodeType 的值为2； nodeName 的值是特性的名称； nodeValue 的值是特性的值； parentNode 的值为null； 在HTML 中不支持（没有）子节点； 在XML 中子节点可以是Text 或EntityReference。 Attr 对象有3 个属性：name、value 和specified。 name 是特性名称（与nodeName 的值相同），value 是特性的值（与nodeValue 的值相同），而specified 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。 使用document.createAttribute()并传入特性的名称可以创建新的特性节点。 123456var attr = document.createAttribute(\"align\");attr.value = \"left\";element.setAttributeNode(attr);alert(element.attributes[\"align\"].value); //\"left\"alert(element.getAttributeNode(\"align\").value); //\"left\"alert(element.getAttribute(\"align\")); //\"left\"","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM-节点层次-Text类型&Comment类型","slug":"DOM-节点层次-Text类型&Comment类型","date":"2017-11-30T12:33:28.000Z","updated":"2018-12-04T12:13:54.351Z","comments":true,"path":"2017/11/30/DOM-节点层次-Text类型&Comment类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/DOM-节点层次-Text类型&Comment类型/","excerpt":"","text":"Text类型 文本节点由Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML 字符，但不能包含HTML 代码。 Text 节点具有以下特征： nodeType 的值为3； nodeName 的值为”#text”； nodeValue 的值为节点所包含的文本； parentNode 是一个Element； 不支持（没有）子节点。 可以通过nodeValue 属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。 使用下列方法可以操作节点中的文本。 appendData(text)：将text 添加到节点的末尾。 deleteData(offset, count)：从offset 指定的位置开始删除count 个字符。 insertData(offset, text)：在offset 指定的位置插入text。 replaceData(offset,count,text)：用text替换从offset指定的位置开始到offset+count 为止处的文本。 splitText(offset)：从offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从offset 指定的位置开始到offset+count 为止处的字符串。 123456&lt;!-- 没有内容，也就没有文本节点 --&gt;&lt;div&gt;&lt;/div&gt;&lt;!-- 有空格，因而有一个文本节点 --&gt;&lt;div&gt; &lt;/div&gt;&lt;!-- 有内容，因而有一个文本节点--&gt;&lt;div&gt;Hello World!&lt;/div&gt; 12var textNode = div.firstChild; //或者div.childNodes[0]div.firstChild.nodeValue = \"Some other message\"; 1、创建文本节点 使用document.createTextNode()创建新文本节点，这个方法接受一个参数——要插入节点中的文本。 1var textNode = document.createTextNode(\"&lt;strong&gt;Hello&lt;/strong&gt; world!\"); 除非把新节点添加到文档树中已经存在的节点中，否则我们不会在浏览器窗口中看到新节点。 123456//创建一个&lt;div&gt;元素并向其中添加一条消息。var element = document.createElement(\"div\");element.className = \"message\";var textNode = document.createTextNode(\"Hello world!\");element.appendChild(textNode);document.body.appendChild(element); 2、规范化文本节点 normalize()是能够将相邻文本节点合并的方法 如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。 12345678910111213141516var element = document.createElement(\"div\");element.className = \"message\";var textNode = document.createTextNode(\"Hello world!\");element.appendChild(textNode);var anotherTextNode = document.createTextNode(\"Yippee!\");element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length); //2element.normalize();alert(element.childNodes.length); //1alert(element.firstChild.nodeValue); // \"Hello world!Yippee!\" 3、分割文本节点 splitText()方法会将一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue 值。 原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的parentNode 相同。 123456789101112var element = document.createElement(\"div\");element.className = \"message\";var textNode = document.createTextNode(\"Hello world!\");element.appendChild(textNode);document.body.appendChild(element);var newNode = element.firstChild.splitText(5);alert(element.firstChild.nodeValue); //\"Hello\"alert(newNode.nodeValue); //\" world!\"alert(element.childNodes.length); //2 分割文本节点是从文本节点中提取数据的一种常用DOM 解析技术。 Comment类型 注释在DOM中是通过Comment 类型来表示的。Comment 节点具有下列特征： nodeType 的值为8； nodeName 的值为”#comment”； nodeValue 的值是注释的内容； parentNode 可能是Document 或Element； 不支持（没有）子节点。 Comment 类型与Text 类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。 可以通过nodeValue 或data属性来取得注释的内容。注释节点可以通过其父节点来访问。 1&lt;div id=\"myDiv\"&gt;&lt;!--A comment --&gt;&lt;/div&gt; 123var div = document.getElementById(\"myDiv\");var comment = div.firstChild;alert(comment.data); //\"A comment\" 使用document.createComment()并为其传递注释文本也可以创建注释节点。 1var comment = document.createComment(\"A comment \"); -如果要访问注释节点，一定要保证它们是元素的后代。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM-节点层次-Element类型","slug":"DOM-节点层次-Element类型","date":"2017-11-30T11:33:28.000Z","updated":"2017-11-30T09:08:04.000Z","comments":true,"path":"2017/11/30/DOM-节点层次-Element类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/DOM-节点层次-Element类型/","excerpt":"","text":"Element 类型 Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。 Element 节点具有以下特征： nodeType 的值为1； nodeName 的值为元素的标签名； nodeValue 的值为null； parentNode 可能是Document 或Element； 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection 或EntityReference。 要访问元素的标签名，可以使用nodeName 属性，也可以使用tagName 属性。1&lt;div id=\"myDiv\"&gt;&lt;/div&gt; 123var div = document.getElementById(\"myDiv\");alert(div.tagName); //\"DIV\"alert(div.tagName == div.nodeName); //true 在HTML 中，标签名始终都以全部大写表示；而在XML（有时候也包括XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在HTML 还是XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式。 123456if (element.tagName == \"div\")&#123; //不能这样比较，很容易出错！//在此执行某些操作&#125;if (element.tagName.toLowerCase() == \"div\")&#123; //这样最好（适用于任何文档）//在此执行某些操作&#125; 1、html元素 HTMLElement 类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。 id，元素在文档中的唯一标识符。 title，有关元素的附加说明信息，一般通过工具提示条显示出来。 lang，元素内容的语言代码，很少使用。 dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），也很少使用。 className，与元素的class 特性对应，即为元素指定的CSS类。 1&lt;div id=\"myDiv\" class=\"bd\" title=\"Body text\" lang=\"en\" dir=\"ltr\"&gt;&lt;/div&gt; 12345678910111213var div = document.getElementById(\"myDiv\");alert(div.id); //\"myDiv\"\"alert(div.className); //\"bd\"alert(div.title); //\"Body text\"alert(div.lang); //\"en\"alert(div.dir); //\"ltr\"//修改对应的每个特性div.id = \"someOtherId\";div.className = \"ft\";div.title = \"Some other text\";div.lang = \"fr\";div.dir =\"rtl\"; 2、获取特性 操作特性的DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()。 123456var div = document.getElementById(\"myDiv\");alert(div.getAttribute(\"id\")); //\"myDiv\"alert(div.getAttribute(\"class\")); //\"bd\"alert(div.getAttribute(\"title\")); //\"Body text\"alert(div.getAttribute(\"lang\")); //\"en\"alert(div.getAttribute(\"dir\")); //\"ltr\" 通过getAttribute()方法也可以取得自定义特性（即标准HTML 语言中没有的特性）的值。 1&lt;div id=\"myDiv\" my_special_attribute=\"hello!\"&gt;&lt;/div&gt; 1var value = div.getAttribute(\"my_special_attribute\"); 只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中。 123alert(div.id); //\"myDiv\"alert(div.my_special_attribute); //undefined（IE 除外）alert(div.align); //\"left\" 3、设置特性 setAttribute()，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性并设置相应的值。 12345div.setAttribute(\"id\", \"someOtherId\");div.setAttribute(\"class\", \"ft\");div.setAttribute(\"title\", \"Some other text\");div.setAttribute(\"lang\",\"fr\");div.setAttribute(\"dir\", \"rtl\"); removeAttribute()，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性。 1div.removeAttribute(\"class\"); attributes 属性 Element 类型是使用attributes 属性的唯一一个DOM 节点类型。 attributes 属性中包含一个NamedNodeMap，与NodeList 类似，也是一个“动态”的集合。 元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap 对象拥有下列方法。 getNamedItem(name)：返回nodeName 属性等于name 的节点； removeNamedItem(name)：从列表中移除nodeName 属性等于name 的节点； setNamedItem(node)：向列表中添加节点，以节点的nodeName 属性为索引； item(pos)：返回位于数字pos 位置处的节点。 attributes 属性中包含一系列节点，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。 12345678910111213//取得元素的id 特性var id = element.attributes.getNamedItem(\"id\").nodeValue;//简写形式var id = element.attributes[\"id\"].nodeValue;//设置特性的值element.attributes[\"id\"].nodeValue = \"someOtherId\";//直接删除具有给定名称的特性var oldAttr = element.attributes.removeNamedItem(\"id\"); //id='xxx'//为元素添加一个新特性element.attributes.setNamedItem(newAttr); attributes 的方法不够方便，因此开发更多会使用getAttribute()、removeAttribute()和setAttribute()方法。 如果想要遍历元素的特性，attributes属性倒是可以派上用场，在需要将DOM结构序列化为XML 或HTML 字符串时，多数都会涉及遍历元素特性。 12345678910111213141516/**迭代元素的每一个特性，然后将它们构造成name=\"value\" name=\"value\"这样的字符串格式。**/function outputAttributes(element)&#123; var pairs = new Array(), attrName, attrValue, i, len; for (i=0, len=element.attributes.length; i &lt; len; i++)&#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; if (element.attributes[i].specified) &#123; pairs.push(attrName + \"=\\\"\" + attrValue + \"\\\"\"); &#125; &#125; return pairs.join(\" \");&#125; 5、创建元素 使用document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。 1234var div = document.createElement(\"div\");div.id = \"myNewDiv\";div.className = \"box\";document.body.appendChild(div); 6、元素的子节点 元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的childNodes 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。 1234567&lt;!--如果是IE 来解析这些代码，那么&lt;ul&gt;元素会有3 个子节点，分别是3 个&lt;li&gt;元素。--&gt;&lt;!--如果是在其他浏览器中，&lt;ul&gt;元素都会有7 个元素，包括3 个&lt;li&gt;元素和4 个文本节点--&gt;&lt;ul id=\"myList\"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul &gt; 如果需要通过childNodes属性遍历子节点，那么一定不要忘记浏览器间的这一差别。在执行某项操作以前，通常都要先检查一下nodeTpye 属性。 12345for (var i=0, len=element.childNodes.length; i &lt; len; i++)&#123; if (element.childNodes[i].nodeType == 1)&#123; //执行某些操作 &#125;&#125;","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM—节点层次—Document类型","slug":"javascript DOM—节点层次—Document类型","date":"2017-11-29T16:33:28.000Z","updated":"2017-11-29T08:33:52.000Z","comments":true,"path":"2017/11/30/javascript DOM—节点层次—Document类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript DOM—节点层次—Document类型/","excerpt":"","text":"Document类型 JavaScript 通过Document 类型表示文档。 在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML 页面。 document 对象是window 对象的一个属性，因此可以将其作为全局对象来访问。 Document 节点具有下列特征： nodeType 的值为9； nodeName 的值为”#document”； nodeValue 的值为null； parentNode 的值为null； ownerDocument 的值为 null； 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。 1、文档的子节点 有两个内置的访问Document节点的子节点的快捷方式：documentElement属性和childNodes 列表。 12345&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 123var html = document.documentElement; //取得对&lt;html&gt;的引用alert(html === document.childNodes[0]); //truealert(html === document.firstChild); //true 作为HTMLDocument 的实例，document 对象还有一个body 属性，直接指向元素。 1var body = document.body; //取得对&lt;body&gt;的引用 Document 另一个可能的子节点是DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过doctype属性（在浏览器中是document.doctype）来访问它的信息。 1var doctype = document.doctype; //取得对&lt;!DOCTYPE&gt;的引用 浏览器对document.doctype 的支持差别很大，可以给出如下总结。 IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作Comment节点；而document.doctype 的值始终为null。 IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype是一个DocumentType节点，也可以通过document.firstChild或document.childNodes[0]访问同一个节点。 Safari、Chrome 和Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype 是一个DocumentType节点，但该节点不会出现在document.childNodes 中。 2、文档信息 作为HTMLDocument 的一个实例，document对象还有一些标准的Document对象所没有的属性。 通过title属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。 1234//取得文档标题var originalTitle = document.title;//设置文档标题document.title = \"New page title\"; 另3 个属性都与对网页的请求有关，它们是URL、domain 和referrer。 URL 属性中包含页面完整的URL（即地址栏中显示的URL）。 domain 属性中只包含页面的域名。 referrer属性中则保存着链接到当前页面的那个页面的URL，在没有来源页面的情况下，referrer 属性中可能会包含空字符串。 所有这些信息都存在于请求的HTTP头部，通过这些属性我们能够在JavaScrip中访问它们。 123456//取得完整的URLvar url = document.URL;//取得域名var domain = document.domain;//取得来源页面的URLvar referrer = document.referrer; 在这3 个属性中，只有domain是可以设置的。但由于安全方面的限制，也并非可以给domain 设置任何值。 如果URL 中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为”wrox.com”，不能将这个属性设置为URL 中不包含的域。 123//假设页面来自p2p.wrox.com 域document.domain = \"wrox.com\"; // 成功document.domain = \"nczonline.net\"; // 出错！ 浏览器对domain 属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）。 123//假设页面来自于p2p.wrox.com 域document.domain = \"wrox.com\"; //松散的（成功）document.domain = \"p2p.wrox.com\"; //紧绷的（出错！） 当页面中包含来自其他子域的框架或内嵌框架时，由于跨域安全限制，来自不同子域的页面无法通过JavaScript通信。而通过将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。 3、查找元素 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;title&gt;getElement&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"myDiv\" class = \"example\"&gt;Some text&lt;/div&gt; &lt;img src=\"myimage.gif\" name=\"myImage\" alt =\"myimg\"&gt; &lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=\"radio\" value=\"red\" name=\"color\" id=\"colorRed\"&gt; &lt;label for=\"colorRed\"&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=\"radio\"value=\"green\" name=\"color\" id=\"colorGreen\"&gt; &lt;label for=\"colorGreen\"&gt;Green&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=\"radio\" value=\"blue\" name=\"color\" id=\"colorBlue\"&gt; &lt;label for=\"colorBlue\"&gt;Blue&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/fieldset&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425//getElementById(),接收一个参数：要取得的元素的ID,严格区分大小写。//如果页面中多个元素的ID 值相同，getElementById()只返回文档中第一次出现的元素。var div = document.getElementById(\"myDiv\"); /**getElementsByTagName()。这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的NodeList**/var images = document.getElementsByTagName(\"img\");alert(images.length); //输出图像的数量alert(images[0].src); //输出第一个图像元素的src 特性aler t(images.item(0).src); //输出第一个图像元素的src 特性//使用namedItem()方法可以通过元素的name特性取得集合中的项。var myImage = images.namedItem(\"myImage\");//HTMLCollection 还支持按名称访问项var myImage = images[\"myImage\"];//取得文档中的所有元素var allElements = document.getElementsByTagName(\"*\");//返回带有给定name 特性的所有元素var radios = document.getElementsByName(\"color\");//获取指定类名的所有元素var div = document.getElementsByClassName(\"example\"); 4、特殊集合 document.anchors，包含文档中所有带name 特性的元素； document.links，包含文档中所有带href 特性的元素； document.forms，包含文档中所有的元素； document.images，包含文档中所有的元素； 5、文档写入 document具有将输出流写入到网页中的能力，方法包括write()、writeln()、open()和close() write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而writeln()则会在字符串的末尾添加一个换行符（\\n）。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;document.write() Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;The current date and time is: &lt;script type=\"text/javascript\"&gt; document.write(\"&lt;strong&gt;\" + (new Date()).toString() + \"&lt;/strong&gt;\"); &lt;/script&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 还可以使用write()和writeln()方法动态地包含外部资源 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;document.write() Example 3&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; document.write(\"&lt;script type=\\\"text/javascript\\\" src=\\\"file.js\\\"&gt;\" + \"&lt;\\/script&gt;\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; open()和close()分别用于打开和关闭网页的输出流","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-DOM—节点层次—Node类型","slug":"javascript DOM—节点层次—Node类型","date":"2017-11-29T16:32:28.000Z","updated":"2017-11-29T08:33:04.000Z","comments":true,"path":"2017/11/30/javascript DOM—节点层次—Node类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript DOM—节点层次—Node类型/","excerpt":"","text":"节点层次 DOM 可以将任何HTML 或XML 文档描绘成一个由多层节点构成的结构。 节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。 Node类型 每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列的数值常量来表示。 1var type = node.nodeType; 节点类型常量 常量 值 描述 Node.ELEMENT_NODE 1 一个 元素 节点，例如 和 。 Node.TEXT_NODE 3 Element 或者 Attr 中实际的 文字 Node.PROCESSING_INSTRUCTION_NODE 7 一个用于XML文档的 ProcessingInstruction ，例如 &lt;?xml-stylesheet … ? &gt; 声明。 Node.COMMENT_NODE 8 一个 Comment 节点。 Node.DOCUMENT_NODE 9 一个 Document 节点。 Node.DOCUMENT_TYPE_NODE 10 描述文档类型的 DocumentType 节点。 例如 &lt;!DOCTYPE html&gt; 就是用于 HTML5 的。 Node.DOCUMENT_FRAGMENT_NODE 11 一个 DocumentFragment 节点 已弃用的节点类型常量 常量 值 描述 Node.ATTRIBUTE_NODE 2 元素 的耦合属性 。在 DOM4 规范里Node 接口将不再实现这个元素属性。 Node.CDATA_SECTION_NODE 4 一个 CDATASection。 在 DOM4 规范里被移除。 Node.ENTITY_REFERENCE_NODE 5 一个 XML 实体引用节点。 在 DOM4 规范里被移除。 Node.ENTITY_NODE 6 一个 XML &lt;!ENTITY …&gt; 节点。 在 DOM4 规范中被移除。 Node.NOTATION_NODE 12 一个 XML &lt;!NOTATION …&gt; 节点。 在 DOM4 规范里被移除. 1234567891011121314151617/**不同的节点类型**/document.nodeType === Node.DOCUMENT_NODE; // truedocument.doctype.nodeType === Node.DOCUMENT_TYPE_NODE; // truevar fragment = document.createDocumentFragment();fragment.nodeType === Node.DOCUMENT_FRAGMENT_NODE; // truevar p = document.createElement(\"p\");p.textContent = \"一点人生经验...\";p.nodeType === Node.ELEMENT_NODE; // truep.firstChild.nodeType === Node.TEXT_NODE; // true/**注释**/var node = document.documentElement.firstChild;if (node.nodeType != Node.COMMENT_NODE) console.log(\"滚去写注释！\"); 1、nodeName和nodeValue属性 123if (someNode.nodeType == 1)&#123; value = someNode.nodeName; //nodeName 的值是元素的标签名&#125; 2、节点关系 每个节点都有一个childNodes 属性，其中保存着一个NodeList 对象。 NodeList 对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList 对象中。 1234//如何访问保存在NodeList 中的节点var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; 将NodeList 对象转换为数组 123456789101112131415//在IE8 及之前版本中无效var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);/**由于IE8 及更早版本将NodeList实现为一个COM 对象，在IE 中将NodeList 转换为数组，必须手动枚举所有成员。**/function convertToArray(nodes)&#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); //针对非IE 浏览器 &#125; catch (ex) &#123; array = new Array(); for (var i=0, len=nodes.length; i &lt; len; i++)&#123; array.push(nodes[i]); &#125; &#125; return array;&#125; 每个节点都有一个parentNode 属性，该属性指向文档树中的父节点。 包含在childNodes 列表中的每个节点相互之间都是同胞节点。 通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表中的其他节点。 列表中第一个节点的previousSibling属性值为null，而列表中最后一个节点的nextSibling 属性的值同样也为null。 12345if (someNode.nextSibling === null)&#123; alert(\"Last node in the parent’s childNodes list.\");&#125; else if (someNode.previousSibling === null)&#123; alert(\"First node in the parent’s childNodes list.\");&#125; 如果列表中只有一个节点，那么该节点的nextSibling 和previousSibling 都为null。 所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。 3、操作节点 appendChild()，用于向childNodes 列表的末尾添加一个节点。 123var returnedNode = someNode.appendChild(newNode);alert(returnedNode == newNode); //truealert(someNode.lastChild == newNode); //true 如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。 1234//someNode 有多个子节点var returnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.firstChild); //falsealert(returnedNode == someNode.lastChild); //true insertBefore()方法，把节点放在childNodes列表中某个特定的位置上， 这个方法接受两个参数：要插入的节点和作为参照的节点。 插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作. 12345678910//插入后成为最后一个子节点returnedNode = someNode.insertBefore(newNode, null);alert(newNode == someNode.lastChild); //true//插入后成为第一个子节点var returnedNode = someNode.insertBefore(newNode, someNode.firstChild);alert(returnedNode == newNode); //truealert(newNode == someNode.firstChild); //true//插入到最后一个子节点前面returnedNode = someNode.insertBefore(newNode, someNode.lastChild);alert(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true replaceChild()替换节点 此方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。 1234//替换第一个子节点var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);//替换最后一个子节点returnedNode = someNode.replaceChild(newNode, someNode.lastChild); removeChild()，用于移除节点 1234//移除第一个子节点var formerFirstChild = someNode.removeChild(someNode.firstChild);//移除最后一个子节点var formerLastChild = someNode.removeChild(someNode.lastChild); cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。 此方法接受一个布尔值参数，表示是否执行深复制。在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。 复制后返回的节点副本属于文档所有，但并没有为它指定父节点。 12345&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt; 12345var myList = document.getElementsByTagName('ul')[0];var deepList = myList.cloneNode(true);alert(deepList.childNodes.length); //3（IE &lt; 9）或7（其他浏览器）var shallowList = myList.cloneNode(false);alert(shallowList.childNodes.length); //0 normalize()，这个方法唯一的作用就是处理文档树中的文本节点。 由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。 当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-客户端检测","slug":"javascript-客户端检测","date":"2017-11-29T16:30:28.000Z","updated":"2017-11-29T08:32:46.000Z","comments":true,"path":"2017/11/30/javascript-客户端检测/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-客户端检测/","excerpt":"","text":"客户端检测是JavaScript开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。 能力检测：在编写代码之前先检测特定浏览器的能力。 采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下： 123if (object.propertyInQuestion)&#123; //使用object.propertyInQuestion&#125; 可靠的能力检测 1234567891011//不要这样做！这不是能力检测——只检测了是否存在相应的方法function isSortable(object)&#123; return !!object.sort;&#125;/**这个函数通过检测对象是否存在sort()方法，来确定对象是否支持排序。问题是，任何包含sort属性的对象也会返回true。**/var result = isSortable(&#123; sort: true &#125;);/**检测某个属性是否存在并不能确定对象是否支持排序。更好的方式是检测sort 是不是一个函数。**///这样更好：检查sort 是不是函数function isSortable(object)&#123; return typeof object.sort == \"function\";&#125; 在可能的情况下，要尽量使用typeof 进行能力检测。但IE早期版本中存在问题。 在浏览器环境下测试任何对象的某个特性是否存在，要使用下面这个函数。 123456789function isHostMethod(object, property) &#123; var t = typeof object[property]; return t=='function' || (!!(t=='object' &amp;&amp; object[property])) || t=='unknown';&#125;//可以像下面这样使用这个函数：result = isHostMethod(xhr, \"open\"); //trueresult = isHostMethod(xhr, \"foo\"); //false 能力检测无法精确地检测特定的浏览器和版本。 根据浏览器不同将能力组合起来是更可取的方式，如果你知道自己的应用程序需要使用某些特定的浏览器特性，那么最好是一次性检测所有相关特性，而不要分别检测。 12345//确定浏览器是否支持Netscape 风格的插件var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);//确定浏览器是否具有DOM1 级规定的能力var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp;document.getElementsByTagName); 怪癖检测：确定浏览器存在什么怪癖。 怪癖实际上是浏览器实现中存在的bug，例如早期的WebKit 中就存在一个怪癖，即它会在for-in 循环中返回被隐藏的属性。 怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖。 由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干扰脚本运行的情况下使用。 怪癖检测无法精确地检测特定的浏览器和版本。 用户代理检测：通过检测用户代理字符串来识别浏览器。 用户代理字符串中包含大量与浏览器有关的信息，包括浏览器、平台、操作系统及浏览器版本。 用户代理字符串有过一段相当长的发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗网站相信自己的浏览器是另外一种浏览器。 用户代理检测需要特殊的技巧，特别是要注意Opera会隐瞒其用户代理字符串的情况。 即便如此，通过用户代理字符串仍然能够检测出浏览器所用的呈现引擎以及所在的平台，包括移动设备和游戏系统。 完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows操作系统、移动设备和游戏系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157var client = function()&#123; //呈现引擎 var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //完整的版本号 ver: null &#125;; //浏览器 var browser = &#123; //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null &#125;; //平台、设备和操作系统 var system = &#123; win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, //游戏系统 wii: false, ps: false &#125;; //检测呈现引擎和浏览器 var ua = navigator.userAgent; if (window.opera)&#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\\/(\\S+)/.test(ua))&#123; engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); //确定是Chrome 还是Safari if (/Chrome\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[\"$1\"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[\"$1\"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312)&#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412)&#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[\"$1\"]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp[\"$1\"]; engine.gecko = parseFloat(engine.ver); //确定是不是Firefox if (/Firefox\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[\"$1\"]; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[\"$1\"]; engine.ie = browser.ie = parseFloat(engine.ver); &#125; //检测浏览器 browser.ie = engine.ie; browser.opera = engine.opera; //检测平台 var p = navigator.platform; system.win = p.indexOf(\"Win\") == 0; system.mac = p.indexOf(\"Mac\") == 0; system.x11 = (p == \"X11\") || (p.indexOf(\"Linux\") == 0); //检测Windows 操作系统 if (system.win)&#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/.test(ua))&#123; if (RegExp[\"$1\"] == \"NT\")&#123; switch(RegExp[\"$2\"])&#123; case \"5.0\": system.win = \"2000\"; break; case \"5.1\": system.win = \"XP\"; break; case \"6.0\": system.win = \"Vista\"; break; case \"6.1\": system.win = \"7\"; break; default: system.win = \"NT\"; break; &#125; &#125; else if (RegExp[\"$1\"] == \"9x\")&#123; system.win = \"ME\"; &#125; else &#123; system.win = RegExp[\"$1\"]; &#125; &#125; &#125; //移动设备 system.iphone = ua.indexOf(\"iPhone\") &gt; -1; system.ipod = ua.indexOf(\"iPod\") &gt; -1; system.ipad = ua.indexOf(\"iPad\") &gt; -1; system.nokiaN = ua.indexOf(\"NokiaN\") &gt; -1; //windows mobile if (system.win == \"CE\")&#123; system.winMobile = system.win; &#125; else if (system.win == \"Ph\")&#123; if(/Windows Phone OS (\\d+.\\d+)/.test(ua))&#123;; system.win = \"Phone\"; system.winMobile = parseFloat(RegExp[\"$1\"]); &#125; &#125; //检测iOS 版本 if (system.mac &amp;&amp; ua.indexOf(\"Mobile\") &gt; -1)&#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\")); &#125; else &#123; system.ios = 2; //不能真正检测出来，所以只能猜测 &#125; &#125; //检测Android 版本 if (/Android (\\d+\\.\\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1); &#125; //游戏系统 system.wii = ua.indexOf(\"Wii\") &gt; -1; system.ps = /playstation/i.test(ua); //返回这些对象 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 用户代理检测是客户端检测的最后一个选择。只要可能，都应该优先采用能力检测和怪癖检测。用户代理检测一般适用于下列情形。 不能直接准确地使用能力检测或怪癖检测。 同一款浏览器在不同平台下具备不同的能力。 为了跟踪分析等目的需要知道确切的浏览器。 选择客户端检测方法 在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。 怪癖检测是确定应该如何处理代码的第二选择。 用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-BOM小结","slug":"javascript-BOM小结","date":"2017-11-29T16:27:28.000Z","updated":"2017-11-29T08:31:38.000Z","comments":true,"path":"2017/11/30/javascript-BOM小结/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-BOM小结/","excerpt":"","text":"浏览器对象模型（BOM）以window对象为依托，表示浏览器窗口以及页面可见区域。 window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames 集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top 对象始终指向最外围的框架，也就是整个浏览器窗口。 parent 对象表示包含当前框架的框架，而self 对象则回指window。 使用location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。 调用replace()方法可以导航到一个新URL，同时该URL 会替换浏览器历史记录中当前显示的页面。 navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。 BOM 中还有两个对象：screen 和history，但它们的功能有限。 screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。 history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-screen对象 & history对象","slug":"javascript-BOM—screen 对象 & history对象","date":"2017-11-29T16:25:28.000Z","updated":"2017-12-13T09:21:14.000Z","comments":true,"path":"2017/11/30/javascript-BOM—screen 对象 & history对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-BOM—screen 对象 & history对象/","excerpt":"","text":"screen对象 screen 对象在编程中用处并不大，基本是只用来表示客户端的能力。 其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。 每个浏览器中的screen对象都包含着各不相同的属性，下表列出了所有属性及支持相应属性的浏览器。 属 性 说 明 IE Firefox Safari/Chrome Opera availHeight 屏幕的像素高度减系统部件高度之后的值（只读） -    availLeft 未被系统部件占用的最左侧的像素值（只读）   - availTop 未被系统部件占用的最上方的像素值（只读） -   - availWidth 屏幕的像素宽度减系统部件宽度之后的值（只读）     bufferDepth 读、写用于呈现屏外位图的位数  - - - colorDepth 用于表现颜色的位数；多数系统都是32（只读）     deviceXDPI 屏幕实际的水平DPI（只读）  - - - deviceYDPI 屏幕实际的垂直DPI（只读）  - - - fontSmoothingEnabled 表示是否启用了字体平滑（只读）  - - - height 屏幕的像素高度     left 当前屏幕距左边的像素距离 -  - - logicalXDPI 屏幕逻辑的水平DPI（只读）  - - - logicalYDPI 屏幕逻辑的垂直DPI（只读）  - - - pixelDepth 屏幕的位深（只读） -    top 当前屏幕距上边的像素距离 -  - - updateInterval 读、写以毫秒表示的屏幕刷新时间间隔  - - - width 屏幕的像素宽度     这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。不过，有时候也可能会用到其中的信息来调整浏览器窗口大小，使其占据屏幕的可用空间。 1window.resizeTo(screen.availWidth, screen.availHeight); history 对象 history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。 出于安全方面的考虑，开发人员无法得知用户浏览过的URL。 借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。 使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。 123456//后退一页history.go(-1);//前进一页history.go(1);//前进两页history.go(2); 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。 1234//跳转到最近的wrox.com 页面history.go(\"wrox.com\");//跳转到最近的nczonline.net 页面history.go(\"nczonline.net\"); 使用back()和forward()可以模仿浏览器的“后退”和“前进”按钮。 1234//后退一页history.back();//前进一页history.forward(); history 对象还有一个length 属性，保存着历史记录的数量。123if (history.length == 0)&#123; //这应该是用户打开窗口后的第一个页面&#125;","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-BOM-navigator 对象","slug":"javascript-BOM—navigator 对象","date":"2017-11-29T16:23:28.000Z","updated":"2017-11-29T08:30:52.000Z","comments":true,"path":"2017/11/30/javascript-BOM—navigator 对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-BOM—navigator 对象/","excerpt":"","text":"每个浏览器中的navigator对象也都有一套自己的属性。下表列出了存在于所有浏览器中的属性和方法，以及支持它们的浏览器版本。 属性或方法 说 明 IE Firefox Safari/Chrome Opera appCodeName 浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此 3.0+ 1.0+ 1.0+ 7.0+ appMinorVersion 次版本信息 4.0+ － － 9.5+ appName 完整的浏览器名称 3.0+ 1.0+ 1.0+ 7.0+ appVersion 浏览器的版本。一般不与实际的浏览器版本对应 3.0+ 1.0+ 1.0+ 7.0+ buildID 浏览器编译版本 － 2.0+ － － cookieEnabled 表示cookie是否启用 4.0+ 1.0+ 1.0+ 7.0+ cpuClass 客户端计算机中使用的CPU类型（x86、68K、Alpha、PPC或Other） 4.0+ － － － javaEnabled() 表示当前浏览器中是否启用了Java 4.0+ 1.0+ 1.0+ 7.0+ language 浏览器的主语言 － 1.0+ 1.0+ 7.0+ mimeTypes 在浏览器中注册的MIME类型数组 4.0+ 1.0+ 1.0+ 7.0+ onLine 表示浏览器是否连接到了因特网 4.0+ 1.0+ － 9.5+ oscpu 客户端计算机的操作系统或使用的CPU － 1.0+ － － platform 浏览器所在的系统平台 4.0+ 1.0+ 1.0+ 7.0+ plugins 浏览器中安装的插件信息的数组 4.0+ 1.0+ 1.0+ 7.0+ preference() 设置用户的首选项 － 1.5+ － － product 产品名称（如 Gecko） － 1.0+ 1.0+ － productSub 关于产品的次要信息（如Gecko的版本） － 1.0+ 1.0+ － register-ContentHandler() 针对特定的MIME类型将一个站点注册为处理程序 － 2.0+ － － register-ProtocolHandler() 针对特定的协议将一个站点注册为处理程序 － 2.0 － － systemLanguage 操作系统的语言 4.0+ － － － userAgent 浏览器的用户代理字符串 3.0+ 1.0+ 1.0+ 7.0+ userLanguage 操作系统的默认语言 4.0+ － － 7.0+ userProfile 借以访问用户个人信息的对象 4.0+ － － － vendor 浏览器的品牌 － 1.0+ 1.0+ － vendorSub 有关供应商的次要信息 － 1.0+ 1.0+ － 1、检测插件 检测浏览器中是否安装了特定的插件。对于非IE浏览器，可以使用plugins数组，该数组中的每一项都包含下列属性。 name：插件的名字 description：插件的描述。 filename：插件的文件名。 length：插件所处理的MIME 类型数量。 在检测插件时，需要循环迭代每个插件并将插件的name与给定的名字进行比较。 hasPlugin()函数接受一个参数：要检测的插件名 1234567891011121314/**检测插件（在IE 中无效）,在Firefox、Safari、Opera和Chrome中可以使用这种方法来检测插件。**/function hasPlugin(name)&#123;name = name.toLowerCase();for (var i=0; i &lt; navigator.plugins.length; i++)&#123;if (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; -1)&#123;return true;&#125;&#125;return false;&#125;//检测Flashalert(hasPlugin(\"Flash\"));//检测QuickTimealert(hasPlugin(\"QuickTime\")); 在IE 中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。 IE 是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。 12345678910111213//检测IE 中的插件function hasIEPlugin(name)&#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex)&#123; return false; &#125;&#125;//检测Flashalert(hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\"));//检测QuickTimealert(hasIEPlugin(\"QuickTime.QuickTime\")); 鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。 1234567891011121314151617181920//检测所有浏览器中的Flashfunction hasFlash()&#123; var result = hasPlugin(\"Flash\"); if (!result)&#123; result = hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\"); &#125; return result;&#125;//检测所有浏览器中的QuickTimefunction hasQuickTime()&#123; var result = hasPlugin(\"QuickTime\"); if (!result)&#123; result = hasIEPlugin(\"QuickTime.QuickTime\"); &#125; return result;&#125;//检测Flashalert(hasFlash());//检测QuickTimealert(hasQuickTime()); 2、注册处理程序 Firefox/Chrome等浏览器为navigator对象新增了registerContentHandler()和registerProtocolHandler()方法。这两个方法可以让一个站点指明它可以处理特定类型的信息。 registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL 以及应用程序的名称。 1234//将一个站点注册为处理RSS 源的处理程序navigator.registerContentHandler(\"application/rss+xml\",\"http://www.somereader.com?feed=%s\", \"Some Reader\");/**第一个参数是RSS 源的MIME 类型。第二个参数是应该接收RSS 源URL 的URL，其中的%s 表示RSS 源URL，由浏览器自动插入,当下一次请求RSS源时，浏览器就会打开指定的URL，而相应的Web 应用程序将以适当方式来处理该请求**/ registerProtocolHandler()方法，它也接收三个参数：要处理的协议（例如，mailto 或ftp）、处理该协议的页面的URL 和应用程序的名称。 1234567//将一个应用程序注册为默认的邮件客户端navigator.registerProtocolHandler(\"mailto\",\"http://www.somemailclient.com?cmd=%s\", \"Some Mail Client\");/**注册了一个mailto 协议的处理程序，该程序指向一个基于Web 的电子邮件客户端。同样，第二个参数仍然是处理相应请求的URL，而%s 则表示原始的请求。**/","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-BOM-Window对象","slug":"javascript-BOM - Window对象","date":"2017-11-29T16:18:28.000Z","updated":"2017-11-29T08:28:00.000Z","comments":true,"path":"2017/11/30/javascript-BOM - Window对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-BOM - Window对象/","excerpt":"","text":"BOM是浏览器对象模型 Window对象 BOM 的核心对象是window，它表示浏览器的一个实例。 在浏览器中，window 对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript 规定的Global 对象。 在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。 1、全局作用域 由于window 对象同时扮演着ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window 对象的属性和方法。 1234567var age = 29;function sayAge()&#123; alert(this.age);&#125;alert(window.age); //29sayAge(); //29window.sayAge(); //29 定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete 操作符删除，而直接在window 对象上的定义的属性可以。 12345678var age = 29;window.color = \"red\";//在IE &lt; 9 时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE &lt; 9 时抛出错误，在其他所有浏览器中都返回truedelete window.color; //returns truealert(window.age); //29alert(window.color); //undefined 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。 12345//这里会抛出错误，因为oldValue 未定义var newValue = oldValue;//这里不会抛出错误，因为这是一次属性查询//newValue 的值是undefinedvar newValue = window.oldValue; 2、窗口关系和框架 如果页面中包含框架，那么每个框架都有自己的window对象，并保存在frames集合中。 在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window 对象。 每个window 对象都有一个name 属性，其中包含框架的名称。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt; &lt;/head&gt; &lt;frameset rows=\"160,*\"&gt; &lt;frame src=\"frame.htm\" name=\"topFrame\"&gt; &lt;frameset cols=\"50%,50%\"&gt; &lt;frame src=\"anotherframe.htm\" name=\"leftFrame\"&gt; &lt;frame src=\"yetanotherframe.htm\" name=\"rightFrame\"&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架. 因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。 parent（父）对象始终指向当前框架的直接上层框架。 在某些情况下，parent 有可能等于top；但在没有框架的情况下，parent 一定等于top（此时它们都等于window） 3、窗口位置 用来确定和修改window 对象位置的属性和方法有很多 IE、Safari、Opera 和Chrome都提供了screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。 Firefox 则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。 12345//跨浏览器获取窗口左边和上边的位置var leftPos = (typeof window.screenLeft == \"number\") ?window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ?window.screenTop : window.screenY; 注意问题：如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop的值就是位于页面可见区域上方的浏览器工具栏的像素高度。在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y 轴坐标为0 时返回0。 兼容问题：Firefox、Safari和Chrome始终返回页面中每个框架的top.screenX和top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window对象使用screenX 和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值。最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值 使用moveTo()和moveBy()方法可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。 12345678//将窗口移动到屏幕左上角window.moveTo(0,0);//将窗向下移动100 像素window.moveBy(0,100);//将窗口移动到(200,300)window.moveTo(200,300);//将窗口向左移动50 像素window.moveBy(-50,0); 这两个方法可能会被浏览器禁用；而且，在Opera和IE7（及更高版本）中默认就是禁用的 4、窗口大小 IE9+、Firefox、Safari、Opera和Chrome均为此提供了4个属性：innerWidth、innerHeight、outerWidth 和outerHeight。 在IE9+、Safari 和Firefox中，outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从某个框架访问） 在Opera 中，outerWidth和outerHeight的值表示页面视图容器（Opera中单个标签页对应的浏览器窗口）的大小 innerWidth 和innerHeight则表示该容器中页面视图区的大小（减去边框宽度） 在Chrome 中，outerWidth、outerHeight与innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小。 IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM提供了页面可见区域的相关信息。虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小。 123456789101112var pageWidth = window.innerWidth,pageHeight = window.innerHeight;if (typeof pageWidth != \"number\")&#123; if (document.compatMode == \"CSS1Compat\")&#123; //混杂模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小。移动IE浏览器不支持这些属性，但通过document.documentElement.clientWidth 和document.documentElement.clientHeihgt提供了相同的信息随着页面的缩放，这些值也会相应变化。 在其他移动浏览器中，document.documentElement度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分） 移动IE 浏览器把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight 中。这些值不会随着页面缩放变化。 使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。这两个方法都接收两个参数，其中resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽度和高度之差。 123456//调整到100×100window.resizeTo(100, 100);//调整到200×150window.resizeBy(100, 50);//调整到 300×300window.resizeTo(300, 300); 5、导航和打开窗口 使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值 123//等同于&lt; a href=\"http://www.wrox.com\" target=\"topFrame\"&gt;&lt;/a&gt;window.open(\"http://www.wrox.com/\", \"topFrame\");/**如果有一个名叫\"topFrame\"的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就会创建一个新窗口并将其命名为\"topFrame\"。**/ 如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页. 如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口。 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。设 置 |值 |说 明:—-|:—-:|—-fullscreen |yes或no |表示浏览器窗口是否最大化。仅限IEheight |数值| 表示新窗口的高度。不能小于100left |数值| 表示新窗口的左坐标。不能是负值location| yes或no |表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器）menubar |yes或no |表示是否在浏览器窗口中显示菜单栏。默认值为noresizable| yes或no |表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为noscrollbars| yes或no |表示如果内容在视口中显示不下，是否允许滚动。默认值为nostatus| yes或no |表示是否在浏览器窗口中显示状态栏。默认值为notoolbar |yes或no |表示是否在浏览器窗口中显示工具栏。默认值为notop| 数值 |表示新窗口的上坐标。不能是负值width |数值 |表示新窗口的宽度。不能小于100 123window.open(\"http://www.wrox.com/\",\"wroxWindow\",\"height=400,width=400,top=10,left=10,resizable=yes\");/**打开一个新的可以调整大小的窗口，窗口初始大小为400×400 像素，并且距屏幕上沿和左边各10 像素。**/ window.open()方法会返回一个指向新窗口的引用。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口。 12345678910var wroxWin = window.open(\"http://www.wrox.com/\",\"wroxWindow\",\"height=400,width=400,top=10,left=10,resizable=yes\");//调整大小wroxWin.resizeTo(500,500);//移动位置wroxWin.moveTo(100,100);//调用close()方法还可以关闭新打开的窗口。对于浏览器的主窗口，如果没有//得到用户的允许是不能关闭它的wroxWin.close();alert(wroxWin.closed); //true 新创建的window 对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window对象（top）中有定义，而且指向调用window.open()的窗口或框架。 123var wroxWin = window.open(\"http://www.wrox.com/\",\"wroxWindow\",\"height=400,width=400,top=10,left=10,resizable=yes\");alert(wroxWin.opener == window); //true 在Chrome中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页. 1234var wroxWin = window.open(\"http://www.wrox.com/\",\"wroxWindow\",\"height=400,width=400,top=10,left=10,resizable=yes\");wroxWin.opener = null;/**将opener 属性设置为null就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。**/ 大多数浏览器都内置有弹出窗口屏蔽程序,而没有内置此类程序的浏览器，也可以安装Yahoo!,Toolbar 等带有内置屏蔽程序的实用工具. 如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了。 1234var wroxWin = window.open(\"http://www.wrox.com\", \"_blank\");if (wroxWin == null)&#123; alert(\"The popup was blocked!\");&#125; 如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch 块中。 123456789101112var blocked = false;try &#123; var wroxWin = window.open(\"http://www.wrox.com\", \"_blank\"); if (wroxWin == null)&#123; blocked = true; &#125;&#125; catch (ex)&#123; blocked = true;&#125;if (blocked)&#123; alert(\"The popup was blocked!\");&#125; 6、间歇调用和超时调用 JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。 超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。 第一个参数可以是一个包含JavaScript 代码的字符串，也可以是一个函数。 123456//由于传递字符串可能导致性能损失,不建议传递字符串！setTimeout(\"alert('Hello world!') \", 1000);//推荐的调用方式setTimeout(function() &#123; alert(\"Hello world!\");&#125;, 1000); 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。【原因】：JavaScript是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。 调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID 是计划执行代码的唯一标识符，可以通过它来取消超时调用。 要取消尚未执行的超时调用计划，可以调用clearTimeout*()方法并将相应的超时调用ID 作为参数传递给它。 123456//设置超时调用var timeoutId = setTimeout(function() &#123; alert(\"Hello world!\");&#125;, 1000);//注意：把它取消clearTimeout(timeoutId); 间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载. 设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同：要执行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。 123456//不建议传递字符串！setInterval (\"alert('Hello world!') \", 10000);//推荐的调用方式setInterval (function() &#123;alert(\"Hello world!\");&#125;, 10000); 调用setInterval()方法同样也会返回一个间歇调用ID，该ID可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。 取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。 123456789101112var num = 0;var max = 10;var intervalId = null;function incrementNumber() &#123; num++; //如果执行次数达到了max 设定的值，则取消后续尚未执行的调用 if (num == max) &#123; clearInterval(intervalId); alert(\"Done\"); &#125;&#125;intervalId = setInterval(incrementNumber, 500); 这个模式也可以使用超时调用来实现,在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。使用超时调用，则完全可以避免这一点。 123456789101112var num = 0;var max = 10;function incrementNumber() &#123; num++; //如果执行次数未达到max 设定的值，则设置另一次超时调用 if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert(\"Done\"); &#125;&#125;setTimeout(incrementNumber, 500); 7、系统对话框 浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。 它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。 通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。 1234567891011121314//使用alert()生成“警告”对话框alert(&quot;Hello World！&quot;);//调用confirm()方法生成确认框，包含【确认】和【取消】if (confirm(&quot;Are you sure?&quot;)) &#123; alert(&quot;I&apos;m so glad you&apos;re sure! &quot;);&#125; else &#123; alert(&quot;I&apos;m sorry to hear you&apos;re not sure. &quot;);&#125;/**调用prompt()方法生成“提示”框,提示框中除了包含【确认】和【取消】外，还会显示一个文本输入域，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。**/var result = prompt(&quot;What is your name? &quot;, &quot;&quot;);if (result !== null) &#123; alert(&quot;Welcome, &quot; + result);&#125; 如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面。 还有两个可以通过JavaScript打开的对话框，即“查找”和“打印”。这两个对话框都是异步显示的，能够将控制权立即交还给脚本。1234//显示“打印”对话框window.print();//显示“查找”对话框window.find();","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-函数表达式和闭包小结","slug":"javascript-函数表达式和闭包小结","date":"2017-11-29T16:18:28.000Z","updated":"2017-11-29T08:27:20.000Z","comments":true,"path":"2017/11/30/javascript-函数表达式和闭包小结/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-函数表达式和闭包小结/","excerpt":"","text":"在JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript 函数的强大方式。以下总结了函数表达式的特点。 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂； 递归函数应该始终使用arguments.callee来递归地调用自身，不要使用函数名——函数名可能会发生变化。 当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下。 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。 闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 即使JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。 JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-BOM-location对象","slug":"javascript-BOM -location对象","date":"2017-11-29T16:18:28.000Z","updated":"2017-11-29T08:28:34.000Z","comments":true,"path":"2017/11/30/javascript-BOM -location对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-BOM -location对象/","excerpt":"","text":"location 对象 location 提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。 window.location 和document.location 引用的是同一个对象。 location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。 属 性 名 例 子 说 明 hash “#contents” 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.wrox.com:80&quot; 返回服务器名称和端口号（如果有） hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 href “http:/www.wrox.com&quot; 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的目录和（或）文件名 port “8080” 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 1、查询字符串参数 location.search 返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。为此，可以创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象。 1234567891011121314151617181920212223242526272829function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"), //保存数据的对象 args =&#123;&#125;, 取得每一项 items = qs.length ? qs.split(\"&amp;\") : [], item = null, name = null, value = null, //在for循环中使用 i = 0, len = items.length; //逐个将每一项添加到args对象中 for(i = 0; i &lt; len; i++)&#123; item = items[i].split(\"=\"); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length)&#123; args[name] = value; &#125; &#125; return args;&#125;//假设查询字符串是?q=javascript&amp;num=10var args = getQueryStringArgs();alert(args[\"q\"]); //\"javascript\"alert(args[\"num\"]); //\"10\" 2、位置操作 使用location 对象可以通过很多方式来改变浏览器的位置。 123location.assign(\"http://www.wrox.com\");window.location = \"http://www.wrox.com\";location.href = \"http://www.wrox.com\"; 修改location 对象的其他属性也可以改变当前加载的页面。 1234567891011//假设初始URL 为http://www.wrox.com/WileyCDA///将URL 修改为\"http://www.wrox.com/WileyCDA/#section1\"location.hash = \"#section1\";//将URL 修改为\"http://www.wrox.com/WileyCDA/?q=javascript\"location.search = \"?q=javascript\";//将URL 修改为\"http://www.yahoo.com/WileyCDA/\"location.hostname = \"www.yahoo.com\";//将URL 修改为\"http://www.yahoo.com/mydir/\"location.pathname = \"mydir\";//将URL 修改为\"http://www.yahoo.com:8080/WileyCDA/\"location.port = 8080; 每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。 replace()方法 当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。 replace()方法只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;You won't be able to get back here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Enjoy this page for a second, because you won't be coming back here.&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(function () &#123; location.replace(\"http://www.wrox.com/\"); &#125;, 1000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; reload()方法 reload()，作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。 如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。 如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。 12location.reload(); //重新加载（有可能从缓存中加载）location.reload(true); //重新加载（从服务器重新加载） 位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-私有变量","slug":"javascript-私有变量","date":"2017-11-29T16:18:28.000Z","updated":"2017-11-29T08:26:32.000Z","comments":true,"path":"2017/11/30/javascript-私有变量/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-私有变量/","excerpt":"","text":"严格来讲，JavaScript 中没有私有成员的概念；所有对象属性都是公有的。 有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。 私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。 12345function add(num1, num2)&#123; var sum = num1 + num2; return sum;&#125;/**有三个私有变量:num1、num2、sum,在函数外部则不能访问它们**/ 如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。有权访问私有变量和私有函数的公有方法称为特权方法 1、在构造函数中定义特权方法 123456789101112function MyObject()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod = function ()&#123; privateVariable++; return privateFunction(); &#125;;&#125; 利用私有和特权成员，可以隐藏那些不应该被直接修改的数据 123456789101112function Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125;var person = new Person(\"Nicholas\");alert(person.getName()); //\"Nicholas\"person.setName(\"Greg\");alert(person.getName()); //\"Greg\" 在构造函数中定义特权方法有一个缺点，是必须使用构造函数模式，缺点是这对每个实例，都会创建同样一组新方法。而使用静态私有变量来实现特权方法就可以避免这个问题。 2、静态私有变量 通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法 12345678910111213141516(function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //构造函数 MyObject = function()&#123; &#125;; //公有/特权方法 MyObject.prototype.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)();/**这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数**/ 这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。123456789101112131415161718192021222324//在这种模式下，变量name 就变成了一个静态的、由所有实例共享的属性(function()&#123; var name = \"\"; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)();var person1 = new Person(\"Nicholas\");alert(person1.getName()); //\"Nicholas\"person1.setName(\"Greg\");alert(person1.getName()); //\"Greg\"var person2 = new Person(\"Michael\");alert(person1.getName()); //\"Michael\"alert(person2.getName()); //\"Michael\"/**调用setName()或新建一个Person 实例都会赋予name 属性一个新值。结果就是所有实例都会返回相同的值。**/ 模块模式 模块模式是为单例创建私有变量和特权方法 单例指的就是只有一个实例的对象。 按照惯例，JavaScript 是以对象字面量的方式来创建单例对象的。 123456var singleton = &#123; name : value, method : function () &#123; //这里是方法的代码 &#125;&#125;; 模块模式通过为单例添加私有变量和特权方法能够使其得到增强. 12345678910111213141516var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权/公有方法和属性 return &#123; publicProperty: true, publicMethod : function()&#123; privateVariable++; return privateFunction(); &#125; &#125;; //从本质上来讲，这个对象字面量定义的是单例的公共接口&#125;(); 这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。 123456789101112131415161718var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //公共 return &#123; getComponentCount : function()&#123; return components.length; &#125;, registerComponent : function(component)&#123; if (typeof component == \"object\")&#123; components.push(component); &#125; &#125; &#125;;&#125;();/**如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式**/ 增强的模块模式 增强的模块模式，即在返回对象之前加入对其增强的代码 这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况 1234567891011121314151617var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //创建对象 var object = new CustomType(); //添加特权/公有属性和方法 object.publicProperty = true; object.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;(); 如果前面演示模块模式的例子中的application对象必须是BaseComponent的实例，那么就可以使用以下代码。 12345678910111213141516171819var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建application 的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == \"object\")&#123; components.push(component); &#125; &#125;; //返回这个副本 return app;&#125;();","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-闭包&模仿块级作用域","slug":"javascript-闭包&模仿块级作用域","date":"2017-11-29T16:16:28.000Z","updated":"2017-11-29T08:25:46.000Z","comments":true,"path":"2017/11/30/javascript-闭包&模仿块级作用域/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-闭包&模仿块级作用域/","excerpt":"","text":"闭包 闭包是指有权访问另一个函数作用域中的变量的函数。 创建闭包的常见方式，就是在一个函数内部创建另一个函数。 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; //内部函数的作用域链中包含createComparisonFunction()的作用域 var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments 和其他命名参数的值来初始化函数的活动对象但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。 在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。 123456//创建函数var compareNames = createComparisonFunction(\"name\");//调用函数var result = compareNames(&#123; name: \"Nicholas\" &#125;, &#123; name: \"Greg\" &#125;);//解除对匿名函数的引用（以便释放内存）compareNames = null; 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（PublicMethod），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 闭包与变量 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。 1234567891011function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;//这个函数会返回一个函数数组,每个函数都返回10/**因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i 。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i 的同一个变量对象，所以在每个函数内部i 的值都是10**/ 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期 123456789101112function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function(num)&#123; //创建并返回了一个访问num 的闭包 return function()&#123; return num; &#125;; &#125;(i);//将立即执行改匿名函数的结果赋给数组 &#125; return result;&#125; 关于this对象 this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this 等于那个对象 匿名函数的执行环境具有全局性，因此其this对象通常指向window(在通过call()或apply()改变函数执行环境的情况下，this 就会指向其他对象。) 但有时候由于编写闭包的方式不同，这一点可能不会那么明显. 12345678910var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //\"The Window\"（在非严格模式下) 为什么匿名函数没有取得其包含作用域（或外部作用域）的this 对象呢？ 每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了. 123456789101112var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //\"My Object\"/**在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。即使在函数返回之后，that 也仍然引用着object，所以调用object.getNameFunc()()就返回了\"My Object\"。**/ 内存泄露 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。 如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁. 1234567function assignHandler()&#123; var element = document.getElementById(\"someElement\"); element.onclick = function()&#123; alert(element.id); &#125;;&#125;/**由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element 的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收**/ 解决方法是，在退出函数之前，将不使用的局部变量全部删除。 12345678function assignHandler()&#123; var element = document.getElementById(\"someElement\"); var id = element.id; element.onclick = function()&#123; alert(id); &#125;; element = null;&#125; 模仿块级作用域 javaScript 没有块级作用域的概念，意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的 1234567891011121314function outputNumbers(count)&#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; alert(i); //计数&#125;//即使像下面这样错误地重新声明同一个变量，也不会改变它的值。function outputNumbers(count)&#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; var i; //重新声明变量 alert(i); //计数&#125; 匿名函数可以用来模仿块级作用域并避免这个问题。 1234//用作块级作用域（通常称为私有作用域）的匿名函数的语法(function()&#123;//这里是块级作用域&#125;)(); 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 123456789(function()&#123; var now = new Date(); if (now.getMonth() == 0 &amp;&amp; now.getDate() == 1)&#123; alert(\"Happy new year!\"); &#125;&#125;)();/**这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。**/","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-函数表达式&递归","slug":"javascript-函数表达式&递归","date":"2017-11-29T16:14:28.000Z","updated":"2017-11-29T08:25:02.000Z","comments":true,"path":"2017/11/30/javascript-函数表达式&递归/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-函数表达式&递归/","excerpt":"","text":"定义函数的方式有两种：一是函数声明，另一种是函数表达式。 1、函数声明语法12345function functionName(arg0, arg1, arg2) &#123; //函数体&#125;//只在Firefox、Safari、Chrome 和Opera 有效alert(functionName.name); //\"functionName\" 函数声明有一个重要特征是函数声明提升，在执行代码之前会先读取函数声明。12345sayHi();function sayHi()&#123; alert(\"Hi!\");&#125;//这个例子不会抛出错误，因为在代码执行之前会先读取函数声明。 2、函数表达式语法形式12345678var functionName = function(arg0, arg1, arg2)&#123; //函数体&#125;;//函数表达式有几种不同的语法形式。这是最常见的一种形式。在使用前必须先赋值。sayHi(); //错误：函数还不存在var sayHi = function()&#123; alert(\"Hi!\");&#125;; 这种形式创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫做匿名函数或拉姆达函数 理解函数声明和函数表达式的区别 1234567891011//不要这样做！if(condition)&#123; function sayHi()&#123; alert(\"Hi!\"); &#125;&#125; else &#123; function sayHi()&#123; alert(\"Yo!\"); &#125;&#125;//在js中属于无效语法，javascript引擎会尝试修正错误，但各浏览器的修正机制不一致。 使用函数表达式 123456789101112//可以这样做var sayHi;if(condition)&#123; sayHi = function()&#123; alert(\"Hi!\"); &#125;;&#125; else &#123; sayHi = function()&#123; alert(\"Yo!\"); &#125;;&#125;//不同的函数会根据condition 被赋值给sayHi。 能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回. 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 递归 递归函数是在一个函数通过名字调用自身的情况下构成的 12345678910function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); //出错！ 为解决耦合问题，可以使用arguments.callee 12345678function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;//但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。 可以使用命名函数表达式来实现此递归函数 12345678var factorial = (function(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*(num-1); &#125;&#125;)//这种方式在严格模式和非严格模式下都行得通。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-对象与继承小结","slug":"js对象与继承小结","date":"2017-11-29T16:12:28.000Z","updated":"2017-11-29T08:24:24.000Z","comments":true,"path":"2017/11/30/js对象与继承小结/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/js对象与继承小结/","excerpt":"","text":"创建对象的模式 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的prototype 属性来指定那些应该共享的属性和方法。 组合使用构造函数模式和原型模式，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 继承 JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法。 原型链的问题是对象实例共享所有继承的属性和方法。 借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。 组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性，使用最多。 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"创建对象","slug":"创建对象","date":"2017-11-29T16:10:28.000Z","updated":"2017-11-29T08:22:56.000Z","comments":true,"path":"2017/11/30/创建对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/创建对象/","excerpt":"","text":"虽然Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。 工厂模式 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程 考虑到在ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");var person2 = createPerson(\"Greg\", 27, \"Doctor\"); 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型 构造函数模式 ECMAScript 中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。 也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); Person()函数取代了createPerson()函数，与它存在几个不同之处。 没有显式地创建对象 直接将属性和方法赋给了this对象 没有return 语句 按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头 要创建Person的新实例，必须要使用new操作符。以这种方式调用构造函数实际上会经历以下几个步骤。 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 对象的constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符要更可靠一些。 1234alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person2 instanceof Object); //truealert(person2 instanceof Person); //true 1.将构造函数当作函数 构造函数与其他函数的唯一区别，就在于调用它们的方式不同 任何函数，只要通过new 操作符来调用，那它就可以作为构造函数 任何函数，如果不通过new 操作符来调用，那它跟普通函数也不会有什么两样 12345678910// 当作构造函数使用var person = new Person(\"Nicholas\", 29, \"Software Engineer\");person.sayName(); //\"Nicholas\"// 作为普通函数调用Person(\"Greg\", 27, \"Doctor\"); // 添加到windowwindow.sayName(); //\"Greg\"// 在另一个对象的作用域中调用var o = new Object();Person.call(o, \"Kristen\", 25, \"Nurse\");o.sayName(); //\"Kristen\" 2.构造函数的问题 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍 每定义一个函数，也就实例化了一个对象。 创建的函数会导致不同的作用域链和标识符解析，不同的实例上的同名函数时不相等的。 1alert(person1.sayName == person2.sayName); //false 有this对象在，不用再执行代码前就把函数绑定到特定对象上面。通过吧函数定义到构造函数外部来解决实例重新创建问题、 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; alert(this.name);&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 原型模式 创建的每个函数都有一个prototype属性，它是一个指针，指向一个对象。这个对象包含由特定类型的所有实例共享的属性和方法。 使用原型对象，可以让所有对象实例共享它所包含的属性和方法。12345678910111213function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //\"Nicholas\"var person2 = new Person();person2.sayName(); //\"Nicholas\"alert(person1.sayName == person2.sayName); //true 1、理解原型对象 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype 属性所在函数的指针 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object 继承而来的。 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。 12alert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.prototype.isPrototypeOf(person2)); //true Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。 12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //\"Nicholas\" 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。 如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。 添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。 使用delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。 12345678910111213141516function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = &quot;Greg&quot;;alert(person1.name); //&quot;Greg&quot;——来自实例alert(person2.name); //&quot;Nicholas&quot;——来自原型delete person1.name;alert(person1.name); //&quot;Nicholas&quot;——来自原型 使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中 hasOwnProperty()从Object继承而来，只在给定属性存在于对象实例中时，才会返回true12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty(\"name\")); //falseperson1.name = \"Greg\";alert(person1.name); //\"Greg\"——来自实例alert(person1.hasOwnProperty(\"name\")); //truealert(person2.name); //\"Nicholas\"——来自原型alert(person2.hasOwnProperty(\"name\")); //falsedelete person1.name;alert(person1.name); //\"Nicholas\"——来自原型alert(person1.hasOwnProperty(\"name\")); //false 2、原型与in操作符 有两种方式使用in 操作符：单独使用和在for-in 循环中使用。 在单独使用时，in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。 1234567891011121314151617181920212223242526function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty(\"name\")); //falsealert(\"name\" in person1); //trueperson1.name = \"Greg\";alert(person1.name); //\"Greg\" ——来自实例alert(person1.hasOwnProperty(\"name\")); //truealert(\"name\" in person1); //truealert(person2.name); //\"Nicholas\" ——来自原型alert(person2.hasOwnProperty(\"name\")); //falsealert(\"name\" in person2); //truedelete person1.name;alert(person1.name); //\"Nicholas\" ——来自原型alert(person1.hasOwnProperty(\"name\")); //falsealert(\"name\" in person1); //true 同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中 1234function hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object); //属性存在于原型中返回true&#125; 使用hasPrototypeProperty()方法可以检测一个属性是否存在于原型中 123456789101112function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person = new Person();alert(hasPrototypeProperty(person, \"name\")); //trueperson.name = \"Greg\";alert(hasPrototypeProperty(person, \"name\")); //false 在使用for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。 屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false的属性）的实例属性也会在for-in 循环中返回 要取得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 123456789101112131415function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var keys = Object.keys(Person.prototype);alert(keys); //\"name,age,job,sayName\"var p1 = new Person();p1.name = \"Rob\";p1.age = 31;var p1keys = Object.keys(p1);alert(p1keys); //\"name,age\" 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。 12var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //\"constructor,name,age,job,sayName\" 3、更简单的原型语法 1234567891011121314151617function Person()&#123;&#125;Person.prototype = &#123; name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125;&#125;;//但有一个例外：constructor 属性不再指向Person 了，尽管instanceof//操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了var friend = new Person();alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //falsealert(friend.constructor == Object); //true 如果constructor 的值真的很重要,并兼容原生的constructor 属性默认是不可枚举的，可以使用Object.defineProperty()。123456789101112131415function Person()&#123;&#125;Person.prototype = &#123; name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125;&#125;;//重设构造函数，只适用于ECMAScript 5 兼容的浏览器Object.defineProperty(Person.prototype, \"constructor\", &#123; enumerable: false, value: Person&#125;); 4、原型的动态性 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。 12345var friend = new Person();Person.prototype.sayHi = function()&#123; alert(\"hi\");&#125;;friend.sayHi(); //\"hi\"（没有问题！） 实例中的指针仅指向原型，而不指向构造函数,如果是重写整个原型对象，会切断构造函数与最初原型链的关系。 12345678910111213function Person()&#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125;&#125;;friend.sayName(); //error 5、原生对象的原型 所有原生的引用类型，都是采用原型模式创建的。通过原生对象的原型，不仅可以取得所有默认方法的引用，也可以定义新方法。12345String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;;var msg = \"Hello world!\";alert(msg.startsWith(\"Hello\")); //true 6、原型对象的问题 它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。 原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，存在一定问题1234567891011121314151617181920function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", friends : [\"Shelby\", \"Court\"], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\"alert(person2.friends); //\"Shelby,Court,Van\"alert(person1.friends === person2.friends); //true//由于friends 数组存在于Person.prototype而非person1中，所以修改也会通过//person2.friends（与person1.friends 指向同一个数组）反映出来。 组合使用函数构造模式和原型模式 创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 这样，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。 这种混成模式还支持向构造函数传递参数。1234567891011121314151617181920function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Count,Van\"alert(person2.friends); //\"Shelby,Count\"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 动态原型模式 动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。 可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。1234567891011121314function Person(name, age, job)&#123;//属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); 寄生构造函数模式 在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。 这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象 从表面上看，这个函数又很像是典型的构造函数,除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。 123456789101112function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); //\"Nicholas\" 这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array 构造函数，因此可以使用这个模式。 1234567891011121314function SpecialArray()&#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments); //添加方法 values.toPipedString = function()&#123; return this.join(\"|\"); &#125;; //返回数组 return values;&#125;var colors = new SpecialArray(\"red\", \"blue\", \"green\");alert(colors.toPipedString()); //\"red|blue|green\" 寄生构造函数模式,不能依赖instanceof 操作符来确定对象类型 稳妥构造函数模式 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this 的对象。 稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。 稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。 按照稳妥构造函数的要求，可以将前面的Person 构造函数重写如下。12345678910111213141516function Person(name, age, job)&#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function()&#123; alert(name); &#125;; //返回对象 return o;&#125;var friend = Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); //\"Nicholas\"/**变量friend 中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据**/","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"继承","slug":"继承","date":"2017-11-29T16:05:28.000Z","updated":"2017-11-29T08:05:32.000Z","comments":true,"path":"2017/11/30/继承/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/继承/","excerpt":"","text":"javascript只支持实现继承，而且继承主要是依靠原型链来实现的。 原型链 javascript将原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 实现原型链有一种基本模式，其代码大致如下。1234567891011121314151617function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function Subtype()&#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue());//true 1、别忘记默认的原型 所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因 2、确定原型和实例的关系 可以通过两种方式来确定原型和实例之间的关系。 第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。 123alert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(instance instanceof SubType); //true 第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true 123alert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //truealert(SubType.prototype.isPrototypeOf(instance)); //true 3、谨慎地定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后，否则不生效。 123456789101112131415161718192021function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//添加新方法SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;//重写超类型中的方法SubType.prototype.getSuperValue = function ()&#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //false 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。 12345678910111213141516171819202122function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码无效SubType.prototype = &#123; getSubValue : function ()&#123; return this.subproperty; &#125;, someOtherMethod : function ()&#123; return false; &#125;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //error! 4、原型链的问题 在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。1234567891011121314function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType()&#123;&#125;//继承了SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors); //\"red,blue,green,black\" 借用构造函数 借用构造函数技术基本思想是在子类型构造函数的内部调用超类型构造函数。123456789101112function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType()&#123; //继承了SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors); //\"red,blue,green\" 1、传递参数 相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。123456789101112function SuperType(name)&#123; this.name = name;&#125;function SubType()&#123; //继承了SuperType，同时还传递了参数 SuperType.call(this, \"Nicholas\"); //实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); //\"Nicholas\";alert(instance.age); //29 2、借用构造函数的问题 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了 在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。 组合继承 指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。 其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承123456789101112131415161718192021222324252627function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"instance1.sayName(); //\"Nicholas\";instance1.sayAge(); //29var instance2 = new SubType(\"Greg\", 27);alert(instance2.colors); //\"red,blue,green\"instance2.sayName(); //\"Greg\";instance2.sayAge(); //27 原型式继承 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 1234567891011121314151617181920//object()对传入其中的对象执行了一次浅复制function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = object(person);anotherPerson.name = \"Greg\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"Linda\";yetAnotherPerson.friends.push(\"Barbie\");alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" ECMAScript 5 通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 在传入一个参数的情况下，Object.create()与object()方法的行为相同。 12345678910111213var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = \"Greg\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = \"Linda\";yetAnotherPerson.friends.push(\"Barbie\");alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 1234567891011121314var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = Object.create(person, &#123; name: &#123; value: \"Greg\" &#125;, friends:&#123; value:['xxxx','yyyy'] &#125;&#125;);alert(anotherPerson.name); //\"Greg\"alert(anotherPerson.friends); //\"xxxx,yyyy\" 支持Object.create()方法的浏览器有IE9+、Firefox4+、Safari5+、Opera12+和Chrome。 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。12345678910111213function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone; //返回这个对象&#125;var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //\"hi\" 寄生组合式继承 组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 1234567891011121314151617function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //第二次调用SuperType() this.age = age;/**这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。**/&#125;SubType.prototype = new SuperType(); //第一次调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法 基本思路是：不必为了指定子类型的原型而调用超类型的构造函数,使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型 1234567891011121314151617181920function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"javascript-理解对象属性","slug":"javascript-理解对象属性","date":"2017-11-29T16:04:10.000Z","updated":"2017-11-29T08:04:54.000Z","comments":true,"path":"2017/11/30/javascript-理解对象属性/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/javascript-理解对象属性/","excerpt":"","text":"ECMAScript 中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。 创建自定义对象的最简单方式就是创建一个Object 的实例，然后再为它添加属性和方法 1234567var person = new Object();person.name = \"Nicholas\";person.age = 29;person.job = \"Software Engineer\";person.sayName = function()&#123; alert(this.name);&#125;; 对象字面量成为创建这种对象的首选模式 12345678var person = &#123; name: \"Nicholas\", age: 29, job: \"Software Engineer\", sayName: function()&#123; alert(this.name); &#125;&#125;; 属性类型 ECMAScript 中有两种属性：数据属性和访问器属性。 1、数据属性 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。 [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，它们的这个特性默认值为true。 [Enumerable]]：表示能否通过for-in 循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为true。 [[Writable]]：表示能否修改属性的值。直接在对象上定义的属性，它们的这个特性默认值为true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。 要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和value。设置其中的一或多个值，可以修改对应的特性值。12345678var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Nicholas\"&#125;);alert(person.name); //\"Nicholas\"person.name = \"Greg\";alert(person.name); //\"Nicholas\" 123456789var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; configurable: false, value: \"Nicholas\"&#125;);alert(person.name); //\"Nicholas\"delete person.name;alert(person.name); //\"Nicholas\"//把configurable 设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。 一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用Object.defineProperty()方法修改除writable 之外的特性，都会导致错误 12345678910var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; configurable: false, value: \"Nicholas\"&#125;);//抛出错误Object.defineProperty(person, \"name\", &#123; configurable: true, value: \"Nicholas\"&#125;); 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable 和writable 特性的默认值都是false。 2、访问器属性 访问器属性不包含数据值，它们包含一对儿getter和setter函数（非必需），在读取访问器属性时，会调用getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。 [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。 [[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。 [[Get]]：在读取属性时调用的函数。默认值为undefined。 [[Set]]：在写入属性时调用的函数。默认值为undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义123456789101112131415161718var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);alert(book.year); //2004book.year = 2005;alert(book.edition); //2 定义多个属性 由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。 利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 读取属性的特性 使用ECMAScript 5 的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。 这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。 如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set。 如果是数据属性，这个对象的属性有configurable、enumerable、writable 和value。 1234567891011121314151617181920212223242526272829var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //\"undefined\"var descriptor = Object.getOwnPropertyDescriptor(book, \"year\");alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //\"function\" 在JavaScript 中，可以针对任何对象——包括 DOM 和BOM 对象，使用Object.getOwnPropertyDescriptor()方法。 支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-小结","slug":"js引用类型-小结","date":"2017-11-29T16:02:43.000Z","updated":"2017-11-29T08:03:12.000Z","comments":true,"path":"2017/11/30/js引用类型-小结/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/js引用类型-小结/","excerpt":"","text":"对象在javascript中被称为引用类型，而且有一些内置的引用类型可以用来创建特定的对象。 引用类型与传统面向对象程序设计中的类相似，但实现不同。 Object是一个基础类型，其它所有类型都从Object继承了基本方略行为。 Array类型是一组数值的有序列表，同时还提供了操作和转换这些值的功能。 Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能。 RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级正则表达式功能。 函数实际上是Function类型的实例，因此函数也是对象，所以函数也拥有方法，可以用来增强其行为。 因为有了基本包装类型，所以javascript中的基本类型可以被当做对象来访问。三种基本包装类型分别为：String、Boolean和Number。它们具备如下共同特征： 每个包装类型都映射到同名的基本类型。 在读取模式下访问基本类型时，就会创建对应的基本类型的一个对象，从而方便了数据操作。 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。 在所有代码执行之前，作用域中就已经存在两个内置对象:Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象。不过，web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象还提供了很多属性和方法，用于辅助完成复杂的数学计算任务。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-单体内置对象","slug":"js引用类型-单体内置对象","date":"2017-11-29T16:01:59.000Z","updated":"2017-11-29T08:02:26.000Z","comments":true,"path":"2017/11/30/js引用类型-单体内置对象/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/js引用类型-单体内置对象/","excerpt":"","text":"Global对象 不属于任何其他对象的属性和方法，最终都是Global对象的属性和方法 所有在全局作用域中定义的属性和函数，都是Global 对象的属性 诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法 1、URI 编码方法 Global 对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。 有效的URI 中不能包含某些字符，例如空格。而这两个URI 编码方法就可以对URI进行编码，它们用特殊的UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。 encodeURI()主要用于整个URI,不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号。 encodeURIComponent()主要用于对URI中的某一段,会对它发现的任何非标准字符进行编码 12345var uri = \"http://www.wrox.com/illegal value.htm#start\";//\"http://www.wrox.com/illegal%20value.htm#start\"alert(encodeURI(uri));//\"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start\"alert(encodeURIComponent(uri)); 与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。 decodeURI()只能对使用encodeURI()替换的字符进行解码 decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码12345var uri = \"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start\";//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23startalert(decodeURI(uri));//http://www.wrox.com/illegal value.htm#startalert(decodeURIComponent(uri)); 2、eval()方法 eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript （或JavaScript）字符串 当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript 语句来解析，然后把执行结果插入到原位置。 通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链 123456var msg = \"hello world\";eval(\"alert(msg)\"); //\"hello world\"eval(\"function sayHi() &#123; alert('hi'); &#125;\");sayHi();//\"hi\"eval(\"var msg = 'hello world'; \");alert(msg); //\"hello world\" 严格模式下，在外部访问不到eval()中创建的任何变量或函数，因此前面两个例子都会导致错误。同样，在严格模式下，为eval 赋值也会导致错误： 12\"use strict\";eval = \"hi\"; //causes error 3、Global对象的属性 属性 说明 属性 说明 undefined 特殊值undefined Date 构造函数Date NaN 特殊值NaN RegExp 构造函数RegExp Infinity 特殊值Infinity Error 构造函数Error Object 构造函数Object EvalError 构造函数EvalError Array 构造函数Array RangeError 构造函数RangeError Function 构造函数Function ReferenceError 构造函数ReferenceError Boolean 构造函数Boolean SyntaxError 构造函数SyntaxError String 构造函数String TypeError 构造函数TypeError Number 构造函数Number URIError 构造函数URIError ECMAScript 5 明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。 4、window对象 Web 浏览器都是将Global对象作为window对象的一部分加以实现的,在全局作用域中声明的所有变量和函数，都成为了window对象的属性。12345var color = \"red\";function sayColor()&#123; alert(window.color);&#125;window.sayColor(); //\"red\" Math对象 与我们在JavaScript 直接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。 Math 对象中还提供了辅助完成这些计算的属性和方法。 1、Math对象的属性 Math 对象包含的属性大都是数学计算中可能会用到的一些特殊值。下表列出了这些属性。 属 性 说 明 Math.E 自然对数的底数，即常量e的值 Math.LN10 10的自然对数 Math.LN2 2的自然对数 Math.LOG2E 以2为底e的对数 Math.LOG10E 以10为底e的对数 Math.PI π的值 Math.SQRT1_2 1/2的平方根（即2的平方根的倒数） Math.SQRT2 2的平方根 2、min()和max()方法 min()和max()方法用于确定一组数值中的最小值和最大值 这两个方法都可以接收任意多个数值参数 1234var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); //3 要找到数组中的最大或最小值，可以像下面这样使用apply()方法。12var values = [1, 2, 3, 4, 5, 6, 7, 8];var max = Math.max.apply(Math, values); 3、舍入方法 Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数； Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数；1234567891011alert(Math.ceil(25.9)); //26alert(Math.ceil(25.5)); //26alert(Math.ceil(25.1)); //26alert(Math.round(25.9)); //26alert(Math.round(25.5)); //26alert(Math.round(25.1)); //25alert(Math.floor(25.9)); //25alert(Math.floor(25.5)); //25alert(Math.floor(25.1)); //25 4、random()方法 Math.random()方法返回大于等于0 小于1 的一个随机数。 套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。 12345值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)//选择一个1到10 之间的数值var num = Math.floor(Math.random() * 10 + 1);//选择一个2到10之间的数值var num = Math.floor(Math.random() * 9 + 2); 多数情况下，其实都可以通过一个函数来计算可能值的总数和第一个可能的值。 12345678910function selectFrom(lowerValue, upperValue) &#123;var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var num = selectFrom(2, 10);alert(num); // 介于2 和10 之间（包括2 和10）的一个数值var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"purple\", \"brown\"];var color = colors[selectFrom(0, colors.length-1)];aler t(color); // 可能是数组中包含的任何一个字符串 5、其它方法 Math 对象中还包含其他一些与完成各种简单或复杂计算有关的方法 方 法 说 明 方 法 说 明 Math.abs(num) 返回num 的绝对值 Math.asin(x) 返回x 的反正弦值 Math.exp(num) 返回Math.E 的num次幂 Math.atan(x) 返回x 的反正切值 Math.log(num) 返回num 的自然对数 Math.atan2(y,x) 返回y/x 的反正切值 Math.pow(num,power) 返回num 的power次幂 Math.cos(x) 返回x 的余弦值 Math.sqrt(num) 返回num 的平方根 Math.sin(x) 返回x 的正弦值 Math.acos(x) 返回x 的反余弦值 Math.tan(x) 返回x 的正切值","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-基本包装类型","slug":"js引用类型-基本包装类型","date":"2017-11-29T16:00:22.000Z","updated":"2017-11-29T08:01:06.000Z","comments":true,"path":"2017/11/30/js引用类型-基本包装类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/30/js引用类型-基本包装类型/","excerpt":"","text":"为了便于操作基本类型值，ECMAScript 还提供了3 个特殊的引用类型：Boolean、Number和String。 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 12var s1 = \"some text\";var s2 = s1.substring(2); 引用类型与基本包装类型的主要区别就是对象的生存期。使用new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。 1234567var s1 = \"some text\";s1.color = \"red\";alert(s1.color); //undefinedvar s1 = new String(\"some text\");s1.name = \"sss\";console.log(s1.name);//sss 对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。 12var obj = new Object(\"some text\");alert(obj instanceof String); //true 使用new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。12345var value = \"25\";var number = Number(value); //转型函数alert(typeof number); //\"number\"var obj = new Number(value); //构造函数alert(typeof obj); //\"object\" Boolean 类型 理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，建议永远不要使用Boolean对象。 Boolean 类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()方法，返回字符串”true”和”false” Boolean 类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true 或false 值。 1var booleanObject = new Boolean(true); 布尔表达式中的所有对象都会被转换为true 基本类型与引用类型的布尔值还有两个区别. typeof 操作符对基本类型返回”boolean”，而对引用类型返回”object”。 由于Boolean 对象是Boolean 类型的实例，所以使用instanceof操作符测试Boolean 对象会返回true，而测试基本类型的布尔值则返回false。123456789101112var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;alert(result); //truevar falseValue = false;result = falseValue &amp;&amp; true;alert(result); //falsealert(typeof falseObject); //objectalert(typeof falseValue); //booleanalert(falseObject instanceof Boolean); //truealert(falseValue instanceof Boolean); //false Number 类型 Number 是与数字值对应的引用类型。要创建Number 对象，可以在调用Number构造函数时向其中传递相应的数值。 1var numberObject = new Number(10); Number 类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。 可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式 123456var num = 10;salert(num.toString()); //\"10\"alert(num.toString(2)); //\"1010\"alert(num.toString(8)); //\"12\"alert(num.toString(10)); //\"10\"alert(num.toString(16)); //\"a\" Number 类型还提供了一些用于将数值格式化为字符串的方法，其中，toFixed()方法会按照指定的小数位返回数值的字符串表示 12345var num = 10;alert(num.toFixed(2)); //\"10.00\"var num = 10.005;alert(num.toFixed(2)); //\"10.01\" 可用于格式化数值的方法是toExponential()，该方法返回以指数表示法（也称e 表示法）表示的数值的字符串形式。 12var num = 10;alert(num.toExponential(1)); //\"1.0e+1\" toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。 1234var num = 99;alert(num.toPrecision(1)); //\"1e+2\"alert(num.toPrecision(2)); //\"99\"aler t(num.toPrecision(3)); //\"99.0\" Number 对象是Number 类型的实例，而基本类型的数值则不是,不建议直接实例化Number 类型. 123456var numberObject = new Number(10);var numberValue = 10;alert(typeof numberObject); //\"object\"alert(typeof numberValue); //\"number\"alert(numberObject instanceof Number); //truealer t(numberValue instanceof Number); //false String类型 String 类型是字符串的对象包装类型，可以像下面这样使用String 构造函数来创建。123var stringObject = new String(\"hello world\");var stringValue = \"hello world\";alert(stringValue.length); //\"11\" 1、字符方法 charAt()、charCodeAt() 两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。这两个方法都接收一个参数，即基于0 的字符位置。 charAt()方法以单字符字符串的形式返回给定位置的那个字符 12var stringValue = \"hello world\";alert(stringValue.charAt(1)); //\"e\" charCodeAt()方法以字符编码的形式返回给定位置的字符的字符编码。 12var stringValue = \"hello world\";alert(stringValue.charCodeAt(1)); //输出\"101\" 在支持此方法的浏览器中（IE8 及Firefox、Safari、Chrome 和Opera 所有版本），可以使用方括号加数字索引来访问字符串中的特定字符 12var stringValue = \"hello world\";alert(stringValue[1]); //\"e\" 2、字符串操作方法 concat()、slice()、substr()和substring() concat()用于将一或多个字符串拼接起来，返回拼接得到的新字符串。 1234var stringValue = \"hello \";var result = stringValue.concat(\"world\");alert(result); //\"hello world\"alert(stringValue); //\"hello\" concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串 1234var stringValue = \"hello \";var result = stringValue.concat(\"world\", \"!\");alert(result); //\"hello world!\"alert(stringValue); //\"hello\" slice()、substr()和substring()这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。 slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置 substr()的第二个参数指定的则是返回的字符个数。 如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。 slice()、substr()和substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。 1234567var stringValue = \"hello world\";alert(stringValue.slice(3)); //\"lo world\"alert(stringValue.substring(3)); //\"lo world\"alert(stringValue.substr(3)); //\"lo world\"alert(stringValue.slice(3, 7)); //\"lo w\"alert(stringValue.substring(3,7)); //\"lo w\"alert(stringValue.substr(3, 7)); //\"lo worl\" 在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0。 1234567var stringValue = \"hello world\";alert(stringValue.slice(-3)); //\"rld\"alert(stringValue.substring(-3)); //\"hello world\"alert(stringValue.substr(-3)); //\"rld\"alert(stringValue.slice(3, -4)); //\"lo w\"alert(stringValue.substring(3, -4)); //\"hel\"alert(stringValue.substr(3, -4)); //\"\"（空字符串） 3、字符串位置方法: indexOf()和lastIndexOf() indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。 indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。 123var stringValue = \"hello world\";alert(stringValue.indexOf(\"o\")); //4alert(stringValue.lastIndexOf(\"o\")); //7 这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。 123var stringValue = \"hello world\";alert(stringValue.indexOf(\"o\", 6)); //7alert(stringValue.lastIndexOf(\"o\", 6)); //4 在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串. 12345678var stringValue = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\";var positions = new Array();var pos = stringValue.indexOf(\"e\");while(pos &gt; -1)&#123; positions.push(pos); pos = stringValue.indexOf(\"e\", pos + 1);&#125;alert(positions); //\"3,24,32,35,52\" 4、trim()方法 trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。 trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变. 1234var stringValue = \" hello world \";var trimmedStringValue = stringValue.trim();alert(stringValue); //\" hello world \"alert(trimmedStringValue); //\"hello world\" 支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。 Firefox 3.5+、Safari 5+和Chrome8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。 5、字符串大小写转换方法toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase() toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现12345var stringValue = \"hello world\";alert(stringValue.toLocaleUpperCase()); //\"HELLO WORLD\"alert(stringValue.toUpperCase()); //\"HELLO WORLD\"alert(stringValue.toLocaleLowerCase()); //\"hello world\"alert(stringValue.toLowerCase()); //\"hello world\" 6、字符串的模式匹配方法: match()、search()、replace()和split() match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp 对象。 1234567var text = \"cat, bat, sat, fat\";var pattern = /.at/;//与pattern.exec(text)相同var matches = text.match(pattern);alert(matches.index); //0alert(matches[0]); //\"cat\"alert(pattern.lastIndex); //0 search()方法的唯一参数也是字符串或RegExp对象指定的一个正则表达式。 search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。 search()方法始终是从字符串开头向后查找模式。 123var text = \"cat, bat, sat, fat\";var pos = text.search(/at/);aler t(pos); //1 replace()方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数 如果第一个参数是字符串，那么只会替换第一个子字符串。 要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志 12345var text = \"cat, bat, sat, fat\";var result = text.replace(\"at\", \"ond\");alert(result); //\"cond, bat, sat, fat\"result = text.replace(/at/g, \"ond\");aler t(result); //\"cond, bond, sond, fond\" 如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。 下表列出了ECMAScript 提供的这些特殊的字符序列字 符 序列|替换文本:——:|:—–$$ | $$&amp; |匹配整个模式的子字符串。与RegExp.lastMatch的值相同$’ | 匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同$`| 匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同$n|匹配第n个捕获组的子字符串，其中n等于0～9。例如，\\$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串$nn |匹配第nn个捕获组的子字符串，其中nn等于01～99。例如，\\$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串 123var text = \"cat, bat, sat, fat\";result = text.replace(/(.at)/g, \"word ($1)\");alert(result); //word (cat), word (bat), word (sat), word (fat) replace()方法的第二个参数也可以是一个函数。 在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。 在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。 12345678910111213141516function htmlEscape(text)&#123; return text.replace(/[&lt;&gt;\"&amp;]/g, function(match, pos, originalText)&#123; switch(match)&#123; case \"&lt;\": return \"&amp;lt;\"; case \"&gt;\": return \"&amp;gt;\"; case \"&amp;\": return \"&amp;amp;\"; case \"\\\"\": return \"&amp;quot;\"; &#125; &#125;);&#125;alert(htmlEscape(\"&lt;p class=\\\"greeting\\\"&gt;Hello world!&lt;/p&gt;\"));//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt; split()方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。 分隔符可以是字符串，也可以是一个RegExp 对象（这个方法不会将字符串看成正则表达式）。 split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小.1234var colorText = \"red,blue,green,yellow\";var colors1 = colorText.split(\",\"); //[\"red\", \"blue\", \"green\", \"yellow\"]var colors2 = colorText.split(\",\", 2); //[\"red\", \"blue\"]var colors3 = colorText.split(/[^\\,]+/); //[\"\", \",\", \",\", \",\", \"\"] 7、localeCompare()方法 localeCompare()，这个方法比较两个字符串，并返回下列值中的一个: 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）； 如果字符串等于字符串参数，则返回0； 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）。1234var stringValue = \"yellow\";alert(stringValue.localeCompare(\"brick\")); //1alert(stringValue.localeCompare(\"yellow\")); //0alert(stringValue.localeCompare(\"zoo\")); //-1 因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。 12345678910111213function determineOrder(value) &#123; var result = stringValue.localeCompare(value); if (result &lt; 0)&#123; alert(\"The string 'yellow' comes before the string '\" + value + \"'.\"); &#125; else if (result &gt; 0) &#123; alert(\"The string 'yellow' comes after the string '\" + value + \"'.\"); &#125; else &#123; alert(\"The string 'yellow' is equal to the string '\" + value + \"'.\"); &#125;&#125;determineOrder(\"brick\");determineOrder(\"yellow\");determineOrder(\"zoo\"); 8、fromCharCode()方法 String 构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。 从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。1alert(String.fromCharCode(104, 101, 108, 108, 111)); //\"hello\"","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-Function类型","slug":"js引用类型-Function类型","date":"2017-11-29T15:59:25.000Z","updated":"2017-11-29T08:00:04.000Z","comments":true,"path":"2017/11/29/js引用类型-Function类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/29/js引用类型-Function类型/","excerpt":"","text":"函数是对象，每个函数都是Function类型的实例，函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。 没有重载（深入理解） 1234567function addSomeNumber(num)&#123; return num + 100;&#125;function addSomeNumber(num) &#123; return num + 200;&#125;var result = addSomeNumber(100); //300 以上代码实际上与下面的代码没有什么区别,在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber1234567var addSomeNumber = function (num)&#123; return num + 100;&#125;;addSomeNumber = function (num) &#123; return num + 200;&#125;;var result = addSomeNumber(100); //300 函数声明与函数表达式 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行. 12345678alert(sum(10,10));function sum(num1, num2)&#123; return num1 + num2;&#125;/**正常执行，因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中**/ 把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。1234567alert(sum(10,10));//unexpected identifiervar sum = function(num1, num2)&#123; return num1 + num2;&#125;;/**运行会产生错误，因为函数位于一个初始化语句中，而不是一个函数声明。**/ 作为值的函数 因为ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。 12345678910111213function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125;function add10(num)&#123; return num + 10;&#125;var result1 = callSomeFunction(add10, 10);alert(result1); //20function getGreeting(name)&#123; return \"Hello, \" + name;&#125;var result2 = callSomeFunction(getGreeting, \"Nicholas\");alert(result2); //\"Hello, Nicholas\" 可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术 假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。123456789101112131415161718function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var data = [&#123;name: \"Zachary\", age: 28&#125;, &#123;name: \"Nicholas\", age: 29&#125;];data.sort(createComparisonFunction(\"name\"));alert(data[0].name); //Nicholasdata.sort(createComparisonFunction(\"age\"));alert(data[0].name); //Zachary 函数内部属性 在函数内部，有几个特殊的对象：arguments 、this、caller arguments是一个类数组对象，包含着传入函数中的所有参数 arguments 的主要作用是保存函数参数，此对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments 对象的函数。 12345678/**阶乘函数,递归算法**/function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125; 这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以使用arguments.callee 12345678910111213function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;;alert(trueFactorial(5)); //120aler t(factorial(5)); //0 this引用的是函数据以执行的环境对象——或者也可以说是this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是window） 12345678window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //\"red\"o.sayColor = sayColor;o.sayColor(); //\"blue\" caller这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null 123456789101112131415function outer()&#123; inner();&#125;function inner()&#123; alert(inner.caller);&#125;outer();/**为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。**/function outer()&#123; inner();&#125;function inner()&#123; alert(arguments.callee.caller);&#125;outer(); IE、Firefox、Chrome 和Safari 的所有版本以及Opera 9.6 都支持caller 属性。 当函数在严格模式下运行时，访问arguments.callee 会导致错误 严格模式还有一个限制：不能为函数的caller 属性赋值，否则会导致错误。 ECMAScript 5 还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined 函数属性和方法 ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length 和prototype length 属性表示函数希望接收的命名参数的个数 123456789101112function sayName(name)&#123; alert(name);&#125;function sum(num1, num2)&#123; return num1 + num2;&#125;function sayHi()&#123; alert(&quot;hi&quot;);&#125;alert(sayName.length); //1alert(sum.length); //2alert(sayHi.length); //0 每个函数都包含两个非继承而来的方法：apply()、call()和bind()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象。 1234567891011function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同,在使用call()方法时，传递给函数的参数必须逐个列举出来 1234567function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。 apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域 123456789window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue bind()方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值 1234567window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 支持bind()方法的浏览器有IE9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-RegExp类型","slug":"js引用类型-RegExp类型","date":"2017-11-29T15:58:13.000Z","updated":"2017-11-29T07:58:58.000Z","comments":true,"path":"2017/11/29/js引用类型-RegExp类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/29/js引用类型-RegExp类型/","excerpt":"","text":"ECMAScript 通过RegExp 类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。1var expression = / pattern / flags ; 其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用 每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为 正则表达式的匹配模式支持下列3 个标志: g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。 一个正则表达式就是一个模式与上述3 个标志的组合体。不同组合产生不同结果 123456789101112/** 匹配字符串中所有\"at\"的实例*/var pattern1 = /at/g;/** 匹配第一个\"bat\"或\"cat\"，不区分大小写*/var pattern2 = /[bc]at/i;/** 匹配所有以\"at\"结尾的3 个字符的组合，不区分大小写*/var pattern3 = /.at/gi; 与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： 1( [ &#123; \\ ^ $ | ) ? * + .]&#125; 这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义 12345678910111213141516/** 匹配第一个\"bat\"或\"cat\"，不区分大小写*/var pattern1 = /[bc]at/i;/** 匹配第一个\" [bc]at\"，不区分大小写*/var pattern2 = /\\[bc\\]at/i;/** 匹配所有以\"at\"结尾的3 个字符的组合，不区分大小写*/var pattern3 = /.at/gi;/** 匹配所有\".at\"，不区分大小写*/var pattern4 = /\\.at/gi; 创建正则表达式 以字面量形式来定义的正则表达式 1var expression = / pattern / flags ; 使用RegExp 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。 1234 /* * 与pattern1 相同，只不过是使用构造函数创建的 */var pattern2 = new RegExp(\"[bc]at\", \"i\"); 传递给RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp 构造函数） 由于RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。例如\\n（字符\\在字符串中通常被转义为\\，而在正则表达式字符串中就会变成\\\\） 字面量模式 等价的字符串 /[bc]at/ “\\\\[bc\\\\]at” /.at/ “\\\\.at” /name\\/age/ “name\\\\/age” /\\d.\\d{1,2}/ “\\\\d.\\\\d{1,2}” /\\w\\hello\\123/ “\\\\w\\\\\\\\hello\\\\\\\\123” 列表项使用正则表达式字面量必须像直接调用RegExp 构造函数一样，每次都创建新的RegExp 实例 RegExp实例属性 global：布尔值，表示是否设置了g 标志。 ignoreCase：布尔值，表示是否设置了i 标志。 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。 multiline：布尔值，表示是否设置了m 标志。 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 123456789101112 var pattern1 = /\\[bc\\]at/i;alert(pattern1.global); //falsealert(pattern1.ignoreCase); //truealert(pattern1.multiline); //falsealert(pattern1.lastIndex); //0alert(pattern1.source); //\"\\[bc\\]at\"var pattern2 = new RegExp(\"\\\\[bc\\\\]at\", \"i\");alert(pattern2.global); //falsealert(pattern2.ignoreCase); //truealert(pattern2.multiline); //falsealert(pattern2.lastIndex); //0aler t(pattern2.source); //\"\\[bc\\]at\" RegExp实例方法 1、exec() RegExp 对象的主要方法是exec()，该方法是专门为捕获组而设计的。 exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。 返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而input 表示应用正则表达式的字符串。 在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。 12345678var text = \"mom and dad and baby\";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);alert(matches.index); // 0alert(matches.input); // \"mom and dad and baby\"alert(matches[0]); // \"mom and dad and baby\"alert(matches[1]); // \" and dad and baby\"aler t(matches[2]); // \" and baby\" 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。 在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。 在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。 12345678910111213141516171819var text = \"cat, bat, sat, fat\";var pattern1 = /.at/;var matches = pattern1.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0matches = pattern1.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0var pattern2 = /.at/g;var matches = pattern2.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern2.lastIndex); //3matches = pattern2.exec(text);alert(matches.index); //5alert(matches[0]); //batalert(pattern2.lastIndex); //8 2、test() test()接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false 在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便 12345var text = \"000-00-0000\";var pattern = /\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;/;if (pattern.test(text))&#123; alert(\"The pattern was matched.\");&#125; 3、toLocaleString()、toString()、valueOf(） RegExp 实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关 正则表达式的valueOf()方法返回正则表达式本身。 1234var pattern = new RegExp(\"\\\\[bc\\\\]at\", \"gi\");alert(pattern.toString()); // /\\[bc\\]at/gialert(pattern.toLocaleString()); // /\\[bc\\]at/gialert(pattern.valueOf()); // /\\[bc\\]at/gi RegExp构造函数属性 RegExp 构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。长属性名 |短属性名|说 明—-| :—-:|—-input| \\$_ | 最近一次要匹配的字符串。Opera未实现此属性lastMatch| \\$&amp; |最近一次的匹配项。Opera未实现此属性lastParen |\\$+ |最近一次匹配的捕获组。Opera未实现此属性leftContext|\\$` |input字符串中lastMatch之前的文本multiline| \\$* |布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性rightContext| \\$’| Input字符串中lastMatch之后的文本 使用以上属性可以从exec()或test()执行的操作中提取出更具体的信息. 1234567891011121314 var text = \"this has been a short summer\"; var pattern = /(.)hort/g; /* * 注意：Opera 不支持input、lastMatch、lastParen 和multiline 属性 * Internet Explorer 不支持multiline 属性 */ if (pattern.test(text))&#123; alert(RegExp.input); // this has been a short summer alert(RegExp.leftContext); // this has been a alert(RegExp.rightContext); // summer alert(RegExp.lastMatch); // short alert(RegExp.lastParen); // s alert(RegExp.multiline); // false&#125; 使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的ECMAScript 标识符，因此必须通过方括号语法来访问它们。 1234567891011121314var text = \"this has been a short summer\";var pattern = /(.)hort/g;/** 注意：Opera 不支持input、lastMatch、lastParen 和multiline 属性* Internet Explorer 不支持multiline 属性*/if (pattern.test(text))&#123; alert(RegExp.$_); // this has been a short summeralert(RegExp[\"$`\"]); // this has been a alert(RegExp[\"$'\"]); // summeralert(RegExp[\"$&amp;\"]); // short alert(RegExp[\"$+\"]); // salert(RegExp[\"$*\"]); // false&#125; 除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.\\$1、RegExp.\\$2…RegExp.\\$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充. 123456var text = \"this has been a short summer\";var pattern = /(..)or(.)/g;if (pattern.test(text))&#123; alert(RegExp.$1); //shalert(RegExp.$2); //t&#125; 模式的局限性 下面列出了ECMAScript 正则表达式不支持的特性 匹配字符串开始和结尾的\\A 和\\Z 锚① 向后查找（lookbehind）② 并集和交集类 原子组（atomic grouping） Unicode 支持（单个字符除外，如\\uFFFF） 命名的捕获组③ s（single，单行）和x（free-spacing，无间隔）匹配模式 条件匹配 正则表达式注释 123① 但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。② 但完全支持向前查找（lookahead）。③ 但支持编号的捕获组。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-Date类型","slug":"js引用类型-Date类型","date":"2017-11-29T15:56:59.000Z","updated":"2017-11-29T07:57:44.000Z","comments":true,"path":"2017/11/29/js引用类型-Date类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/29/js引用类型-Date类型/","excerpt":"","text":"Date.parse()、Date.UTC()、Date.now() Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数 ECMA-262 没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异 如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN 12var someDate = new Date(Date.parse(\"May 25, 2004\"));var someDate = new Date(\"May 25, 2004\");//与上一行代码等价 Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息 Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1 到31）、小时数（0 到23）、分钟、秒以及毫秒数。 在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0 1234// GMT 时间2000 年1 月1 日午夜零时var y2k = new Date(Date.UTC(2000, 0));// GMT 时间2005 年5 月5 日下午5:55:55var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); Data.now()返回表示调用这个方法时的日期和时间的毫秒数。 1234567//取得开始时间var start = Date.now();//调用函数doSomething();//取得停止时间var stop = Date.now(),result = stop – start; 支持Date.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5 和Chrome。在不支持它的浏览器中，使用+操作符把Date对象转换成字符串，也可以达到同样的目的。 1234567//取得开始时间var start = +new Date();//调用函数doSomething();//取得停止时间var stop = +new Date(),result = stop - start; 继承的方法 Date 类型重写了toLocaleString()、toString()和valueOf()方法；但这些方法返回的值与其他类型中的方法不同 Date 类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。时间格式中会包含AM 或PM，但不会包含时区信息，具体的格式会因浏览器而异 toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0 到23）表示。 Date 类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。1234var date1 = new Date(2007, 0, 1); //\"January 1, 2007\"var date2 = new Date(2007, 1, 1); //\"February 1, 2007\"alert(date1 &lt; date2); //truealert(date1 &gt; date2); //false 日期格式化方法 Date 类型还有一些专门用于将日期格式化为字符串的方法 toDateString()——以特定于实现的格式显示星期几、月、日和年； toTimeString()——以特定于实现的格式显示时、分、秒和时区； toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年； toLocaleTimeString()——以特定于实现的格式显示时、分、秒； toUTCString()——以特定于实现的格式完整的UTC 日期。 以上这些字符串格式方法的输出也是因浏览器而异的 日期/时间组件方法 getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同 setTime(毫秒) 以毫秒数设置日期，会改变整个日期 getFullYear() 取得4位数的年份（如2007而非仅07） getUTCFullYear() 返回UTC日期的4位数年份 getMonth() 返回日期中的月份，其中0表示一月，11表示十二月 getUTCMonth() 返回UTC日期中的月份，其中0表示一月，11表示十二月 setMonth(月) 设置日期的月份。传入的月份值必须大于0，超过11则增加年份 setUTCMonth(月) 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份 getDate() 返回日期月份中的天数（1到31） getUTCDate() 返回UTC日期月份中的天数（1到31） setDate(日) 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 setUTCDate(日) 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 getDay() 返回日期中星期的星期几（其中0表示星期日，6表示星期六） getUTCDay() 返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六） getHours() 返回日期中的小时数（0到23） getUTCHours() 返回UTC日期中的小时数（0到23） getMinutes() 返回日期中的分钟数（0到59） getUTCMinutes() 返回UTC日期中的分钟数（0到59） setMinutes(分) 设置日期中的分钟数。传入的值超过59则增加小时数 setUTCMinutes(分) 设置UTC日期中的分钟数。传入的值超过59则增加小时数 getSeconds() 返回日期中的秒数（0到59） getUTCSeconds() 返回UTC日期中的秒数（0到59） setSeconds(秒) 设置日期中的秒数。传入的值超过了59会增加分钟数 setUTCSeconds(秒) 设置UTC日期中的秒数。传入的值超过了59会增加分钟数 getMilliseconds() 返回日期中的毫秒数 getUTCMilliseconds() 返回UTC日期中的毫秒数 setMilliseconds(毫秒) 设置日期中的毫秒数 setUTCMilliseconds(毫秒) 设置UTC日期中的毫秒数 getTimezoneOffset() 返回本地时间与UTC时间相差的分钟数。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"js引用类型-Array类型","slug":"js引用类型-Array类型","date":"2017-11-29T15:55:47.000Z","updated":"2017-11-29T07:57:16.000Z","comments":true,"path":"2017/11/29/js引用类型-Array类型/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/29/js引用类型-Array类型/","excerpt":"","text":"##1. 检测数组 对于一个网页，或者一个全局作用域而言，使用instanceof 操作符就能得到满意的结果：123if (value instanceof Array)&#123;//对数组执行某些操作&#125; instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从 一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自 不同的构造函数。 为了解决这个问题，ECMAScript 5 新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。这个方法的用法如下。123if (Array.isArray(value))&#123;//对数组执行某些操作&#125; 支持 Array.isArray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 Chrome。 ##2. 转换方法 toLocaleString()、toString()、valueOf()、join() 调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串 调用valueOf()返回的还是数组 123var colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含3 个字符串的数组console.log(colors.toString()); // red,blue,greenconsole.log(colors.valueOf()); // [\"red\", \"blue\", \"green\"] toLocaleString()方法经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。 1234567891011121314151617181920var person1 = &#123;toLocaleString : function () &#123;return \"Nikolaos\";&#125;,toString : function() &#123;return \"Nicholas\";&#125;&#125;;var person2 = &#123;toLocaleString : function () &#123;return \"Grigorios\";&#125;,toString : function() &#123;return \"Greg\";&#125;&#125;;var people = [person1, person2];alert(people); //Nicholas,Gregconsole.log(people.toString()); //Nicholas,Gregconsole.log(people.toLocaleString()); //Nikolaos,Grigorios 使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串 123var colors = [\"red\", \"green\", \"blue\"];console.log(colors.join(\",\")); //red,green,blueconsole.log(colors.join(\"||\")); //red||green||blue 如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。##3.栈方法 LIFO 后进先出， push() 、pop() push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度 pop()方法则从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。 12345678var colors = new Array(); // 创建一个数组var count = colors.push(\"red\", \"green\"); // 推入两项alert(count); //2count = colors.push(\"black\"); // 推入另一项alert(count); //3var item = colors.pop(); // 取得最后一项alert(item); //\"black\"alert(colors.length); //2 栈方法与其他数组方法连用 123456var colors = [\"red\", \"blue\"];colors.push(\"brown\"); // 添加另一项colors[3] = \"black\"; // 添加一项alert(colors.length); // 4var item = colors.pop(); // 取得最后一项aler t(item); //\"black\" ##4. 队列方法 LIFO（后进先出）shift()、unshift() shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。 12345678var colors = new Array(); //创建一个数组var count = colors.push(\"red\", \"green\"); //推入两项alert(count); //2count = colors.push(\"black\"); //推入另一项alert(count); //3var item = colors.shift(); //取得第一项alert(item); //\"red\"alert(colors.length); //2 unshift()与shift()的用途相反,它能在数组前端添加任意个项并返回新数组的长度。 12345678var colors = new Array(); //创建一个数组var count = colors.unshift(\"red\", \"green\"); //推入两项alert(count); //2count = colors.unshift(\"black\"); //推入另一项alert(count); //3var item = colors.pop(); //取得最后一项alert(item); //\"green\"alert(colors.length); //2 ##5. 重排序方法 reverse()、sort() reverse()和sort()方法的返回值是经过排序之后的数组。 reverse()方法会反转数组项的顺序 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //5,4,3,2,1 sort()排序数组，默认升序，为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串 123var values = [0, 1, 5, 10, 15];values.sort();alert(values); //0,1,10,15,5 sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。 123456789101112function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); //0,1,5,10,15 对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。 123function compare(value1, value2)&#123; return value2 - value1;&#125; ##6. 操作方法 (1)concat() concat()方法可以基于当前数组中的所有项创建一个新数组 在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本 如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中 如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾1234var colors = [\"red\", \"green\", \"blue\"];var colors2 = colors.concat(\"yellow\", [\"black\", \"brown\"]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brown (2)slice() slice()能够基于当前数组中的一或多个项创建一个新数组 slice()方法可以接受一或两个参数，即要返回项的起始和结束位置 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项 如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项 slice()方法不会影响原始数组12345var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow (3)splice() splice()的主要用途是向数组的中部插入项,使用方式有如下3种 删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。 插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。123456789var colors = [\"red\", \"green\", \"blue\"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, \"yellow\", \"orange\"); // 从位置1 开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, \"red\", \"purple\"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,blue ##7. 位置方法 indexOf() 、lastIndexOf() 两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。 indexOf()方法从数组的开头（位置0）开始向后查找 lastIndexOf()方法则从数组的末尾开始向前查找 两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。 要求查找的项必须严格相等 1234567891011var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3var person = &#123; name: \"Nicholas\" &#125;;var people = [&#123; name: \"Nicholas\" &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 使用indexOf()和lastIndexOf()方法查找特定项在数组中的位置非常简单，支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。##8. 迭代方法 every()、filter()、forEach()、map()、some() 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this 的值 传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身 根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 12345var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。12345var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;); map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 12345var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。以上方法都不会修改数组中的包含的值。 1234var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。##9. 归并方法 reduce()、reduceRight() 这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。 reduce()方法从数组的第一项开始，逐个遍历到最后 reduceRight()则从数组的最后一项开始，向前遍历到第一项 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值 传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。123456使用reduce()方法可以执行求数组中所有值之和的操作。var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15 123456使用reduceRight()的作用类似，只不过方向相反而已。var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123;return prev + cur;&#125;);alert(sum); //15 支持这两个归并函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5 和Chrome。","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/categories/javascript基础/"}],"tags":[{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/javascript高级程序设计/"},{"name":"前端基础","slug":"前端基础","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/tags/前端基础/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-28T09:19:22.000Z","updated":"2017-11-28T09:19:22.000Z","comments":true,"path":"2017/11/28/hello-world/","link":"","permalink":"http://shanruopeng.github.io/shanruopeng.github.io/2017/11/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}